<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://dirtmelon.github.io/</id><title>Dirtmelon</title><subtitle>A minimal, portfolio, sidebar, bootstrap Jekyll theme with responsive web design and focuses on text presentation.</subtitle> <updated>2022-01-27T16:40:51+08:00</updated> <author> <name>dirtmelon</name> <uri>https://dirtmelon.github.io/</uri> </author><link rel="self" type="application/atom+xml" href="https://dirtmelon.github.io/feed.xml"/><link rel="alternate" type="text/html" hreflang="zh-cn" href="https://dirtmelon.github.io/"/> <generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator> <rights> © 2022 dirtmelon </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>iOS 工程建设</title><link href="https://dirtmelon.github.io/posts/ios-summarize/" rel="alternate" type="text/html" title="iOS 工程建设" /><published>2022-01-19T22:24:00+08:00</published> <updated>2022-01-27T16:40:28+08:00</updated> <id>https://dirtmelon.github.io/posts/ios-summarize/</id> <content src="https://dirtmelon.github.io/posts/ios-summarize/" /> <author> <name>dirtmelon</name> </author> <summary> 最近一年多都在负责组件化和工程建设的相关事情，换了工作之后可能有段时间都不会接触这块的东西，所以这里记录下主要做了哪些事情。 从 pod install 开始 iOS 的包管理工具主要是 CocoaPods ， Swift Package Manager (aka SPM) 和 Carthage 。其中 CocoaPods 是历史最悠久的，第一次提交可以追溯到十年前 ：Ten years ago today @alloy started writing @CocoaPods 。虽然说其对工程的入侵一直被人诟病，但是毫无疑问， CocoaPods 依旧是 iOS 上最受欢迎的包管理工具，根据 JetBrains 2021 的调查报告 ：Swift 和 Objective-C - 2021 开发人员生态系统信息图 。大概有 70% 的开发者在使用 CocoaPods ： 如果... </summary> </entry> <entry><title>Promises 的 Swift 实现</title><link href="https://dirtmelon.github.io/posts/promise-third/" rel="alternate" type="text/html" title="Promises 的 Swift 实现" /><published>2021-12-13T10:22:00+08:00</published> <updated>2022-01-20T16:12:59+08:00</updated> <id>https://dirtmelon.github.io/posts/promise-third/</id> <content src="https://dirtmelon.github.io/posts/promise-third/" /> <author> <name>dirtmelon</name> </author> <summary> Promises 的 Swift 层是基于 Objective-C 层实现的，借由 Swift 的特性，提供了更加安全和便捷的接口。 基础属性 Promise 为 Swift 层提供的类，由于 Swift 有命名空间，所以不需要添加前缀。 Promise 内部定义了一个 alias ，使得调用更加清晰： public typealias ObjCPromise&amp;lt;Value: AnyObject&amp;gt; = FBLPromise&amp;lt;Value&amp;gt; Promise 的相关属性： let objCPromise: ObjCPromise&amp;lt;AnyObject&amp;gt; ，每个 Promise 内部都会有个对应的 objCPromise ； var isPending: Bool { return objCPromise.__i... </summary> </entry> <entry><title>Promises 的 Objective-C 实现</title><link href="https://dirtmelon.github.io/posts/promise-second/" rel="alternate" type="text/html" title="Promises 的 Objective-C 实现" /><published>2021-11-28T18:15:00+08:00</published> <updated>2021-11-28T18:15:00+08:00</updated> <id>https://dirtmelon.github.io/posts/promise-second/</id> <content src="https://dirtmelon.github.io/posts/promise-second/" /> <author> <name>dirtmelon</name> </author> <summary> https://github.com/google/promises 是 Google 开源的 Promise 库，支持 Objective-C 和 Swift ， podspec 分为 PromisesObjC.podspec 和 PromisesSwift.podspec ，可以看到 PromisesSwift.podspec 的 dependency 为 PromisesObjC 。下面会从 Promises 的 Objective-C 版基础用法开始解析源码。 创建 Promises PromiseState 的定义： typedef NS_ENUM(NSInteger, FBLPromiseState) { FBLPromiseStatePending = 0, FBLPromiseStateFulfilled, FBLPromiseStateReject... </summary> </entry> <entry><title>Promise - 介绍</title><link href="https://dirtmelon.github.io/posts/promise-first/" rel="alternate" type="text/html" title="Promise - 介绍" /><published>2021-11-23T09:38:00+08:00</published> <updated>2021-11-23T09:38:00+08:00</updated> <id>https://dirtmelon.github.io/posts/promise-first/</id> <content src="https://dirtmelon.github.io/posts/promise-first/" /> <author> <name>dirtmelon</name> </author> <summary> 异步代码的问题 通常来说，异步操作都会通过 block 的方式来执行回调，block 的参数会提供结果和错误。如果需要执行多个异步操作，需要将第二个异步操作嵌套在第一个操作的 block 中，同时也需要处理错误。在这样的嵌套代码中进行修改会变得非常痛苦。 Objective-C 的异步嵌套代码： - (void)getCurrentUserContactsAvatars:(void (^)(NSArray&amp;lt;UIImage *&amp;gt; *, NSError *))completion { [MyClient getCurrentUserWithCompletion:^(MyUser *currentUser, NSError *error) { if (error) { completion(nil, error); return; ... </summary> </entry> <entry><title>FBAllocationTracker</title><link href="https://dirtmelon.github.io/posts/fballocationtracker/" rel="alternate" type="text/html" title="FBAllocationTracker" /><published>2021-11-02T19:57:00+08:00</published> <updated>2021-11-02T19:57:00+08:00</updated> <id>https://dirtmelon.github.io/posts/fballocationtracker/</id> <content src="https://dirtmelon.github.io/posts/fballocationtracker/" /> <author> <name>dirtmelon</name> </author> <summary> 简单介绍下 FBAllocationTracker 是 Facebook 开源的一个用于查找当前存活的 Objective-C 对象的工具库。 FBAllocationTracker 提供了查找在内存中的 Objective-C 对象的接口。它可以获取指定类的所有对象，也可以像 Instruments 那样进行内存增长标记，然后只查找标记时间内创建的对象。 FBAllocationTracker 支持两种模式：记录对象和只是计算 alloc/dealloc 。第一种模式需要的操作步骤更多点，然后如果只是想进行统计，不想影响性能，可以使用第二种模式。相关操作接口由 FBAllocationTrackerManager 提供： #import &amp;lt;FBAllocationTracker/FBAllocationTrackerManager.h&amp;gt; int main(int a... </summary> </entry> </feed>
