[ { "title": "iOS 工程建设", "url": "/posts/ios-summarize/", "categories": "", "tags": "iOS", "date": "2022-01-19 22:24:00 +0800", "snippet": "最近一年多都在负责组件化和工程建设的相关事情，换了工作之后可能有段时间都不会接触这块的东西，所以这里记录下主要做了哪些事情。从 pod install 开始iOS 的包管理工具主要是 CocoaPods ， Swift Package Manager (aka SPM) 和 Carthage 。其中 CocoaPods 是历史最悠久的，第一次提交可以追溯到十年前 ：Ten years ago today @alloy started writing @CocoaPods 。虽然说其对工程的入侵一直被人诟病，但是毫无疑问， CocoaPods 依旧是 iOS 上最受欢迎的包管理工具，根据 JetBrains 2021 的调查报告 ：Swift 和 Objective-C - 2021 开发人员生态系统信息图 。大概有 70% 的开发者在使用 CocoaPods ：如果单看国内的数据， CocoaPods 的比例会更高。虽然下面有 51% 的开发者计划迁移到 SPM ，但是对于国内大厂来说，短期内应该不会这样操作。所以对于国内的开发者来说，在开发过程中可能会频繁输入这条命令： pod install ，下载 Pod 库。当执行 pod install 时如果报错说找不到某个库对应的版本时，我们就会输入 pod install --repo-update ，更新本地的 Spec 源。在构建机器上执行这条命令时，为了避免 install 失败，通常来说都会默认添加 --repo-update 的参数，来更新 Spec 源。不管是拉取 CocoaPods 官方的 Spec 源还是公司内部的 Spec 源，都需要一定的耗时，但是当前这次 pod install 不一定需要更新 Spec 源，有可能在前面的构建已经有更新过，拉取到库的对应版本，这次构建时更新 Spec 源的耗时是不必要的。为了解决这个问题， WordPress 家出了一个插件：cocoapods-repo-update 。通过 cocoapods-repo-update 插件，可以在执行 pod install 时动态判断是否需要添加 --repo-update 参数。其原理比较简单，就是通过 CocoaPods 的插件机制，对 pre_install 进行监听，在里面直接执行 CocoaPods 的依赖分析，如果没报错就不调用 update_repositories 方法。相关实现：cocoapods-repo-update/hooks.rb 。插件目前有个 bug ，没有处理对新增库这种情况进行处理，导致其直接报错，而不是执行 update_repositories ，提了个 PR 修复：cocoapods-repo-update/pull/1 ，目前还没有合并。当然了， CocoaPods 的依赖分析也是需要时间的，在我们公司的主工程上，每次依赖分析的耗时大概是 16s ，但是更新 Spec 源耗时是按分钟计的，网络不好时耗时更久。所以这个交易是比较划算的。更多优化可以看这个：抖音研发效能建设 - CocoaPods 优化实践如果没有专门的团队来做这个事情，实施起来会比较困难，可以看下有没有类似的开源方案，或者挑一些成本比较低的优化点来做。比如说将 GitHub/GitLab 的地址转为 HTTP 地址来进行下载，加快下载速度，有类似的开源方案：cocoapods-git-tarball 。如果要开启 generate_multiple_pod_projects 或者 Clang Module ，需要对 import 进行调整，可以使用 ImportSanitizer 这个工具来进行批量修改。生成二进制产物App 业务和体积大到一定程度之后，都会通过组件化来分隔业务线和基础框架的代码，避免它们耦合在一起或者循环依赖。而当我们把业务和基础框架拆成单独组件之后，通常来说下一步都会将它们转为二进制，减少构建耗时，否则主工程的单次构建动辄半个小时以上，尤其是发版日，需要快速修复和验证 bug ，构建耗时对效率的影响是比较大的。组件二进制产物的生产有以下两种方式。组件工程单独编译生成产物开源方案：cocoapods-bincocoapods-imy-bin对应文章：基于 CocoaPods 的组件二进制化实践优点： 涉及多个组件改动时可以在多台构建机器上并发进行； 如果有循环依赖或者错误依赖可以在单独编译时就收到相应的报错； 可以在多台机器间复用编译产物，一次编译，到处可用； 编译底层库不一定需要重新编译上层库。缺点： 要有构建部门支持，根据自己的工程需要开发一套对应的组件构建和发版系统； 每个组件单独构建时需要单独初始化工程，比如说 pod install ，有一定的耗时； 编译环境与主工程不一致，有可能会导致一些奇奇怪怪的问题； 无法直接查看源码或者 debug ，需要插件支持。通过主工程编译生成产物开源方案：Zabel对应的文章：iOS Pod 构建缓存方案优点： 方便操作，接入成本比较低； 在构建系统上只需要初始化主工程； 编译环境与主工程一致，避免一些奇奇怪怪的问题； 全源码，搜索代码或者 Debug 都方便。缺点 无法并发构建，当一次性修改多个组件时只能由该台构建机器单独完成改动组件的构建； 无法在多台机器间复用编译产物，导致在不同的机器上需要重复编译； 如果改动的头文件层级比较深，那么上层组件都需要重新生成，耗时增加； 无法提早发现循环依赖或者错误依赖。总结上面两种生成方案各有利弊，并没有说哪种方案就是完美的，需要根据项目实际的情况和人员配置来选择合适的方案。我们团队的方案分成两部分： 对于三方库和二方库，通过壳工程来编译，生成二进制产物上传到服务器缓存和共享，原因是我们的构建系统对工程配置和代码规范都有一定的要求，如果说三方库和二方库都通过构建系统来生成二进制产物，改动的工作量会比较大； 对于团队的组件库，则通过构建系统来生成二进制产物，同时使用自研的组件发版管理工具来简化组件构建和发版流程。宏上面提到组件和主工程编译环境不一致时会导致一些奇奇怪怪的问题，其中一个就是宏所带来的问题，下面展开说说。跨组件宏跨组件宏会带来两个问题： 下层组件改动宏，如果上层组件没有依赖新的下层组件进行重新编译，那么就会导致上层组件使用的还是旧的宏定义； 宏定义在组件工程和主工程中的编译配置不一致，导致两者的实现不一致，假设在底层组件 A 中有以下代码： // AComponent.h #if ENABLE#define ENABLE_VALUE 1#else#define ENABLE_VALUE 0#endif 在上层组件 B 的编译配置中设置 ENABLE == 1 ，那么组件 B 单独编译时 ENABLE_VALUE 为 1 。在主工程的编译配置中没有对 ENABLE 进行定义，那么编译主工程时 ENABLE_VALUE 为 0 。两者的 ENABLE_VALUE 不一致。如果我们需要各个工程的 ENABLE_VALUE 保持一致，那么就有可能带来一些问题。 __has_include如果某个组件要提供给不同的宿主使用，需要给不同的宿主提供一些差异化的实现，有些同学会选择使用 __has_include 来实现，这样会导致以下几个问题： 组件的 Spec 文件会越写越大，需要提供不同的 Subspec ，接入不同的目录； 如果是使用组件工程单独编译，那么就需要添加不同 Target ，或者在编译时动态添加特定渠道的文件，编译选项的增加需要非常谨慎，每增加一个选项都会增加开发同学的心智负担； 迁移 __has_include 所指向的文件时编译不会报错，导致缺失某个功能，需要等到运行时才有可能发现。总结上面是组件和宏一起工作时带来的一些问题，而宏本身也有一些别的问题： 多次调用代码量较大的宏，导致体积增大； 难以 debug 和查看代码逻辑； Swift 无法调用。即使是组件通过源码来引入，如果使用了宏，也有可能需要在主工程的 Podfile 中来对编译配置进行调整，导致 Podfile 的代码量增大。我的看法是除非某个功能一定要用宏才能实现时才使用宏，否则都是通过函数和运行时来决定。知乎上有个相关讨论：什么时候应该使用宏定义？Subspec为了方便对同一个 Spec 仓库内的代码进行模块划分， CocoaPods 提供了 Subspec 的能力。不同的 Subspec 提供不同的业务能力，接入方可以根据自己需要选择不同的 Subspec 。具体解析可以看这篇文章：5. PodSpec 文件分析但是当业务组件使用 Subspec 时会带来不少问题。 Subspec 具有传染性，当某个底层组件增加一个 Subspec ，针对某个宿主进行差异化时，上层组件如果有依赖对应的实现，也需要添加对应的 Subspec ，增加 podspec 文件的维护难度； 当直接使用源码 Subspec 时，都是通过主工程的构建来生成二进制产物，使用起来比较方便，不需要新建仓库和单独管理，直接新建一个目录，然后把文件迁移下位置就好了，但是当支持组件单独构建，自行生成二进制产物时，就要针对不同的 Subspec 进行管理了，主要有以下两套方案： 多 Target ，每个 Subspec 有自己 Target 。编译时可以采取指定的 Target 才生成产物，或者所有的 Target 都进行编译，这两种选择都有缺点。指定 Target 会增加构建选项，组件一多，操作起来就比较繁琐。所有 Target 都进行编译会增加编译耗时，本地下载产物时还要下载无用的 Subspec 产物。 单 Target ，编译时指定目录，动态添加文件，其缺点就是多 Target 时指定编译 Target 一样，会增加构建选项。 所以建议对粒度比较大，基础能力或者业务较多的组件进行隔离，分成粒度更小的，基础能力和业务更加纯粹的组件库，减少组件二进制的难度和编译选项，也更容易进行代码权限管理，而不是在一个大的仓库里，大家都往里面提交代码。工程质量Objective-C 作为一门基于 C 的语言，采取了“信任程序员”的做法，给程序员极大的发挥空间，当使用 Objective-C 编写不规范时，很多情况下只会得到警告，不会报错。警告这个东西就比较奇妙了，会有破窗效应，要么零个，要么无数个，要求项目里没有警告也不现实，又不是不能用，因此警告的作用基本上约等零。而且在频繁的业务迭代需求中，要求大家都进行 Code Review 也不现实，所以我们通过 git hooks 和借助编译器来添加工程规范，尽量提高工程质量。git hooks这是团队其他同学写的如何通过 git hooks 来进行工程规范管理的文章：手Y开发规范化建设二：手Y业务工程规范建设通过 git hooks 我们可以添加一些自定义的规则： 图片资源大小限制； API 限制； git commit 信息规范； 等等。借助编译器前面提到 Objective-C 在编写不规范时大多数情况下只会得到警告，不会报错。而通过编译器的设定，我们可以将一些警告改为报错，从而提高代码质量，避免一些运行时的错误，毕竟编译时的错误肯定要比运行的错误要好。通过在 Xcode 工程 Build Settings 的 Other Warning Flags 中将对应的警告标记为错误，举几个例子： -Werror=unused-variable ，如果有未使用的变量，在编译时报错； -Werror=protocol ， @protocol 相关的警告改为报错，比如说 @required 的方法没有实现； -Werror=implicit-retain-self ，隐式的持有 self ，有可能会造成循环引用。可以查看下面的文档，根据自己的需要添加对应的报错规则：Clang 12 documentation也可以通过在 Podfile 的 post_install 中设置 config.build_settings[&#39;WARNING_CFLAGS&#39;] 来给 Pod 库添加规则：config.build_settings[&#39;WARNING_CFLAGS&#39;] = [&#39;-Werror=protocol&#39;, &#39;-Werror=arc-unsafe-retained-assign&#39;, &#39;-Werror=implicit-retain-self&#39;]组件通讯组件间为了避免相互之间有依赖，都会通过通讯方案来进行解耦，一般来说有以下几种方案： 基于路由 URL ； 基于 Target-Action ； 基于 Protocol-Class 。基于 URL 的好处是其本身是一种跨端的协议， iOS ，Android 和 Web 可以统一使用，但是无法直接传输原生数据，需要进行一定的改造。且需要进行硬编码，增加维护成本。基于 Target-Action 的方案比较出名的就是：CTMediator相关文章：iOS应用架构谈 组件化方案Target-Action 方案的缺点就是需要编写大量的胶水代码，而且还是需要进行字符串硬编码。基于上面提到的问题，以及我们项目本身就有使用基于 Protocol-Class 的方案。为了减少团队成员的理解成本，目前我们大部分的情况还是使用 Protocol-Class 的方案，提供了两种匹配方式： 手动注册，把相关的 Protocol-Class 转为字符串的形式打进 Mach-O 的 Data Section 字段，运行时读取； 自动注册，自定义的字符串匹配规则。如何把字符串打进 Mach-O 的 Data Section 字段可以参考这里：一种延迟 premain code 的方法 。运行时优先看 Mach-O 里面手动注册的部分是否有对应 Class 数据，如果有，就调用该 Class 的方法来处理。如果没有，就走自定义的字符串匹配规则。比如说有协议： IYYAClass ，我们团队中使用 I 开头来表示协议。然后我们会通过 YYAClass ， AClass 字符串来查找是否有对应的 Class ，如果有找到对应的类且有实现协议，就调用该 Class 。通过字符串的自动匹配，大部分情况可以省去手动注册的步骤，然后如果匹配规则无法满足需求，或者上层业务方需要覆盖底层 Class 的实现，也可以通过手动注册的方式。这套方案目前使用起来还是比较舒服的，对开发同学的影响比较小，也没有字符串硬编码，当然了，不同团队的业务和架构情况都不同，根据自己团队的情况选择合适的通讯方案才是最好的。去工程化上面提到组件目前是通过单独编译来生成二进制产物，那么就需要单独管理组件的 Xcode 工程。这样带来的一个问题就是新增/删除/迁移文件时，操作都比较繁琐，需要在组件的 Xcode 工程中同步进行操作。所以我们采取动态生成 Xcode 工程的方式。比较流行的开源方案有以下几种：XcodeGentuistxcakestruct可以根据自己的实际需求来选择对应的方案，采取动态生成 Xcode 工程的好处如下： 可以从 git 中移除 .xcodeproj ，不再需要处理相关冲突； 目录的文件会自动保持同步，不需要手动管理； 进行工程配置时可读性更高，同时对 git 的处理也更加友好； 拷贝文件时不再需要在 Xcode 中进行编辑； 等等。差异化只要有不同的宿主，就会有差异化的需求。团队的差异化实现迭代过两个版本。在 1.0 版本，我们有以下几种方案来实现差异化： 配置表，在 plist 文件填写差异化数值； 头文件放在公共目录，实现层在各自的差异化目录下； 通过 Protocol-Class 的方式， Class 实现可以放在同一组件内，也可以放在上层组件。不管是方案 1 还是方案 2 ，我们都需要使用 Subspec ，其缺点上面有提到，且因为差异化的方式有多种，没有统一起来，增加开发同学的理解成本。由于我们已经采用了 Protocol-Class 的方式来进行组件通讯，在差异化的解决方案上我们也决定改为统一采用 Protocol-Class 。先说下为什么要使用差异化，举个例子，比如说有个自定义控件 DTButton ，我们期望在 A 宿主上其圆角 cornerRadius = 5 ，然后在 B 宿主上其圆角 cornerRadius = 8 ，但是这个 DTButton 的使用是分散在各个组件的内部的，我们无法在所有实例化的地方都手动进行设置，这个时候需要一个方案可以统一进行设置。基于 Protocol-Class 的方式我们可以实现以上需求，其和组件通讯的不同点如下： 差异化 Protocol 定义是在组件的接口仓库或者组件自己的仓库， Class 实现是在上层组件，一般会是宿主自己单独持有的组件，举个例子，我们会在 IDTButtonDiff 上定义需要进行差异化的相关方法，可以返回任何原生类型，包括 UIImage/UIColor/CGFloat 等，然后 DTButton 内部会通过和组件通讯相同的方式来访问 IDTButtonDiff ，再往上一层是 DTButtonDiff ，负责实现 IDTButtonDiff 协议，返回宿主的差异化数据，再往上就是 App 了： 组件通讯 Protocol 定义可以在公共的接口仓库，也可以在组件的接口仓库， Class 实现是在组件内部。整体的层级如下：通过这种方式我们还可以完全替换某个控件，交由宿主来负责实现，比如说 DTButton 对应的协议为 IDTButton ，其实现了 DTButton 对外提供的方法，然后统一通过和组件通讯相同的方式来访问 IDTButton ，上面有提到我们有字符串匹配的规则，所以这个时候会获取 DTButton 的实例。如果说宿主想完全接管 DTButton 的实现，可以通过上面提到的手动注册方式，为 IDTButton 注册一个新的实现 AAButton ，从而使得通过 IDTButton 协议获取到的实例都是 AAButton ，更加灵活和通用，也可以干掉 Subspec 。这套差异化方案目前用下来还不错，而且通过 @protocol 的 @required 和 @optional 标注可以更加清晰地描述哪些配置是必须的，哪些是提供默认实现的，减少理解成本。生命周期统一管理比起一般的组件化，我们团队的组件化需要处理的宿主更复杂一点。业务组件不仅需要提供给 YY iOS App 使用，也需要提供给百度系的 App ，作为 SDK 来使用。两者的生命周期不太相同。在 YY iOS App 上，组件的生命周期和 App 的生命周期可以是一致的，启动时就会进行初始化，但是在百度系的 App 上，只有当用户进入了 YY 的直播间才会初始化 SDK 。在一开始，我们选择手动初始化的方式，根据组件的要求，在对外提供的 SDK 初始化方法上添加需要调用的组件初始化方法。如果组件新增了初始化方法，就要手动在 YY iOS App 和 SDK 上同步。这样会带来以下几个问题： 中心式的写法，导致上层调用部分的代码量会非常大，增加维护难度； 新增初始化方法时需要手动在各个宿主上同步添加，容易遗留； 无法自动测量各个方法的耗时，需要手动统计。为了解决上面的问题，可以采取去中心化的方案，各个组件自己管理自己生命周期的相关方法。整体的实现原理和基于 Protocol-Class 的组件通讯方法类似，分为编译时和运行时两部分，编译时写入相关的注册类，运行时再读取，执行对应的方法。这里直接采用写入 Class 信息的做法，然后实现协议中的方法。使用协议的原因有以下几个： 当需要在生命周期某个阶段中调用组件的方法时，可以查看协议的方法说明，选择适合的方法； 与 UIApplicationDelegate 的方法类似，方便处理传递过来的参数，比如说 (UIApplication *)application 和 (NSDictionary *)launchOptions ； 某个组件内生命周期的方法可以集中到一个 Class 内，方便管理和统计。为了解决上面的问题，可以采取去中心化的方案，各个组件自己管理自己生命周期的相关方法。整体的实现原理和基于 Protocol-Class 的组件通讯方法类似，分为编译时和运行时两部分，编译时写入相关的注册类，运行时再读取，执行对应的方法。这里直接采用写入 Class 信息的做法，然后实现协议中的方法。使用协议的原因有以下几个： 当需要在生命周期某个阶段中调用组件的方法时，可以查看协议的方法说明，选择适合的方法； 与 UIApplicationDelegate 的方法类似，方便处理传递过来的参数，比如说 (UIApplication *)application 和 (NSDictionary *)launchOptions ； 某个组件内生命周期的方法可以集中到一个 Class 内，方便管理和统计。对应的实现在这里：DTComponentLifeCycle 生命周期相关方法在 IDTComponentLifeCycle.h ，用法可以看下里面的说明和 Demo ； IDTComponentLifeMetric 用于统计各个组件的调用情况，调用 registerMetricObservers 进行注册； DTComponentLifeCycleManager 负责调用组件生命周期的方法，由于在 YY iOS App 和 SDK 上的生命周期处理不同，这里没有用 hook ，我也不太喜欢用 hook ，如果有需要可以改用 hook 来实现，可以减少点代码量； 由于在 SDK 上是用户进入直播间后才会初始化，所以在 SDK 的初始化里手动一次调用生命周期关于初始化的方法即可。最后上面说了这么多，整个工程的基石还是我们日常开发中所编写代码的质量，重复代码是否有封装起来，而不是简单复制粘贴，是否有留意编译器报的一些警告，代码实现有没有考虑一些边界条件，比如调用 block 前是否有判空等等。如果日常开发的代码质量比较低，那么无论工程建设做得多好也是没办法弥补的。作为一名开发者，应该对代码抱有敬畏之心，持续提高代码质量，那么不管是后面做工程化建设还是其它一些改进都会非常容易着手。" }, { "title": "Promises 的 Swift 实现", "url": "/posts/promise-third/", "categories": "", "tags": "源码解析", "date": "2021-12-13 10:22:00 +0800", "snippet": "Promises 的 Swift 层是基于 Objective-C 层实现的，借由 Swift 的特性，提供了更加安全和便捷的接口。基础属性Promise 为 Swift 层提供的类，由于 Swift 有命名空间，所以不需要添加前缀。 Promise 内部定义了一个 alias ，使得调用更加清晰：public typealias ObjCPromise&amp;lt;Value: AnyObject&amp;gt; = FBLPromise&amp;lt;Value&amp;gt;Promise 的相关属性： let objCPromise: ObjCPromise&amp;lt;AnyObject&amp;gt; ，每个 Promise 内部都会有个对应的 objCPromise ； var isPending: Bool { return objCPromise.__isPending } ，获取 objCPromise 对应的状态，每个属性前都多了两个下划线，原因是在 Objective-C 层这个属性使用 NS_REFINED_FOR_SWIFT 进行声明，表示这个方法在 Swift 层会进行重定义，所以 Swift 调用这个方法时不会自动补全，而且需要加多两个下划线 https://developer.apple.com/documentation/swift/objective-c_and_c_code_customization/improving_objective-c_api_declarations_for_swift ； __value 在 Objective-C 层也使用了 NS_REFINED_FOR_SWIFT ，所以这里也要加一下下划线： var value: Value? { let objCValue = objCPromise.__value if Promise&amp;lt;AnyObject&amp;gt;.isBridgedNil(objCValue) { return nil } guard let value = objCValue as? Value else { preconditionFailure(&quot;Cannot cast \\\\(type(of: objCValue)) to \\\\(Value.self)&quot;) } return value} isBridgedNil 的实现： private static func isBridgedNil(_ value: Value?) -&amp;gt; Bool { // Swift nil becomes NSNull during bridging. return !(value is NSNull) &amp;amp;&amp;amp; (value as AnyObject is NSNull)} 这里处理分为两种情况：一个是 nil ，一个是 Optional 的 none 。 由于 Swift 是强类语言，所以 error 内部会先尝试转换为 PromiseError ： var error: Error? { guard let objCPromiseError = objCPromise.__error else { return nil } // Convert `NSError` to `PromiseError`, if applicable. return PromiseError(objCPromiseError) ?? objCPromiseError} 初始化Promise 提供了将 FBLPromise 作为参数的初始化方法：public init&amp;lt;Value&amp;gt;(_ objCPromise: ObjCPromise&amp;lt;Value&amp;gt;) { guard let objCPromise = objCPromise as? ObjCPromise&amp;lt;AnyObject&amp;gt; else { preconditionFailure(&quot;Cannot cast \\\\(Value.self) to \\\\(AnyObject.self)&quot;) } self.objCPromise = objCPromise}而通过 asObjCPromise() 方法可以获取到对应的 FBLPromise ：public func asObjCPromise&amp;lt;Value&amp;gt;() -&amp;gt; ObjCPromise&amp;lt;Value&amp;gt; { guard let objCPromise = objCPromise as? ObjCPromise&amp;lt;Value&amp;gt; else { preconditionFailure(&quot;Cannot cast \\\\(AnyObject.self) to \\\\(Value.self)&quot;) } return objCPromise}通过这两个方法可以便捷地在 Swift 和 Objective-C 的 class 之间进行转换：@interface ObjCTest : NSObject- (FBLPromise&amp;lt;NSString *&amp;gt; *)getString;- (FBLPromise&amp;lt;NSNumber *&amp;gt; *)getNumber:(NSString *)string;- (void)asyncWith:(NSString *)string and:(NSInteger)integer completion:(void(^)())handler;- (void)needsAPromise:(FBLPromise&amp;lt;NSString *&amp;gt; *)promise;@endSwift 也可以直接使用 ObjCTest 进行测试：let objc = ObjCTest()// 通过 FBLPromise 进行初始化Promise&amp;lt;String&amp;gt;(objc.getString()).then { string in return Promise&amp;lt;Int&amp;gt;(objc.getNumber(string))}.then { number in print(number)}wrap { handler in objc.async(with: &quot;hello&quot;, and: 42, completion: handler)}.then { _ in print(&quot;Success.&quot;)}.catch { error in print(error)}let stringPromise = Promise&amp;lt;String&amp;gt; { return &quot;Hello world!&quot;}// 通过 asObjCPromise 获取 FBLPromiseobjc.needsAPromise(stringPromise.asObjCPromise())@objc(providesAPromiseFromNumber:)func providesAPromise(from number: Int) -&amp;gt; Promise&amp;lt;String&amp;gt;.ObjCPromise&amp;lt;NSString&amp;gt; { return Promise&amp;lt;String&amp;gt; { &quot;The number is \\\\(number)&quot; }.asObjCPromise()}objc.needsAPromise(providesAPromise(42))其它部分Promise 其它的用法和 FBLPromise 区别不大，最大的区别是 all 操作符部分，为了在 Swift 上使用更加安全， all 操作符通过范型提供了强类型操作，但是最多支持 4 个 Promise 合并：public func all&amp;lt;A, B, C, D&amp;gt;( on queue: DispatchQueue = .promises, _ promiseA: Promise&amp;lt;A&amp;gt;, _ promiseB: Promise&amp;lt;B&amp;gt;, _ promiseC: Promise&amp;lt;C&amp;gt;, _ promiseD: Promise&amp;lt;D&amp;gt;) -&amp;gt; Promise&amp;lt;(A, B, C, D)&amp;gt; { let promises = [ promiseA.objCPromise, promiseB.objCPromise, promiseC.objCPromise, promiseD.objCPromise ] let promise = Promise&amp;lt;(A, B, C, D)&amp;gt;( Promise&amp;lt;(A, B, C, D)&amp;gt;.ObjCPromise&amp;lt;AnyObject&amp;gt;.__onQueue( queue, all: promises ).__onQueue(queue, then: { objCValues in guard let values = objCValues as [AnyObject]?, let valueA = Promise&amp;lt;A&amp;gt;.asValue(values[0]), let valueB = Promise&amp;lt;B&amp;gt;.asValue(values[1]), let valueC = Promise&amp;lt;C&amp;gt;.asValue(values[2]), let valueD = Promise&amp;lt;D&amp;gt;.asValue(values[3]) else { preconditionFailure(&quot;Cannot convert \\\\(type(of: objCValues)) to \\\\((A, B, C, D).self)&quot;) } return (valueA, valueB, valueC, valueD) }) ) // 让 Promises 持有 promise ，避免提早释放。 promises.forEach { $0.__addPendingObject(promise) } return promise}总的来说 Swift 相当于在 Objective-C 的实现上套了一层壳，提供了更加 Swifty 和安全的 API 。" }, { "title": "Promises 的 Objective-C 实现", "url": "/posts/promise-second/", "categories": "", "tags": "源码解析", "date": "2021-11-28 18:15:00 +0800", "snippet": "https://github.com/google/promises 是 Google 开源的 Promise 库，支持 Objective-C 和 Swift ， podspec 分为 PromisesObjC.podspec 和 PromisesSwift.podspec ，可以看到 PromisesSwift.podspec 的 dependency 为 PromisesObjC 。下面会从 Promises 的 Objective-C 版基础用法开始解析源码。创建 PromisesPromiseState 的定义：typedef NS_ENUM(NSInteger, FBLPromiseState) { FBLPromiseStatePending = 0, FBLPromiseStateFulfilled, FBLPromiseStateRejected,};FBLPromiseObserver 则定义了 Observer 的相关 block ：typedef void (^FBLPromiseObserver)(FBLPromiseState state, id __nullable resolution);gFBLPromiseDefaultDispatchQueue 是默认的处理队列，在 FBLPromise 的 initialize 方法中进行初始化：+ (void)initialize { if (self == [FBLPromise class]) { gFBLPromiseDefaultDispatchQueue = dispatch_get_main_queue(); }}FBLPromise 在 initialize 方法中对 gFBLPromiseDefaultDispatchQueue 进行初始化，这样就可以在 FBLPromise 第一次调用方法前就自动设置，至于为什么要判断 self 是否为 FBLPromise class ，可以看下 initialize 的解析。FBLPromise 的对象属性如下：@implementation FBLPromise { // Promise 当前的状态 FBLPromiseState _state; // 对处理中的对象进行强引用，处理完之后会自动置 nil NSMutableSet *__nullable _pendingObjects; // fulfilled 时对应的值 id __nullable _value; // rejected 时对应的 错误 NSError *__nullable _error; // 对应的 Observers ，当 Promise 处理完之后就会调用 NSMutableArray&amp;lt;FBLPromiseObserver&amp;gt; *_observers;}创建 Promises 有两种方式，一种是还没知道结果，依赖于后续的异步操作，一种是已经知道结果，是值或者错误。initPending 是还没知道结果，依赖于后续异步操作的初始化方法： (**instancetype**)initPending NS_SWIFT_UNAVAILABLE(&quot;&quot;) ， NS_SWIFT_UNAVAILABLE 表明这个方法在 Swift 中是不可用的： making_objective-c_apis_unavailable_in_swift 。- (instancetype)initPending { self = [super init]; if (self) { dispatch_group_enter(FBLPromise.dispatchGroup); } return self;}这里调用了一下 dispatch_group_enter ，但是整个库的实现并没有利用到 dispatch_group 的相关特性，这里之所以使用了 dispatch_group ，是为了方便测试，具体可以查看这里 https://github.com/google/promises/issues/13 的讨论。initWithResolution: 则是初始化时就知道对应的结果，不依赖后续的异步操作：- (instancetype)initWithResolution:(nullable id)resolution { self = [super init]; if (self) { // 根据 resolution 是否为 NSError 进行区分 if ([resolution isKindOfClass:[NSError class]]) { _state = FBLPromiseStateRejected; _error = (NSError *)resolution; } else { _state = FBLPromiseStateFulfilled; _value = resolution; } } return self;}同时为了方便调用，也通过 block 的方式来提供点语法的调用：+ (instancetype (^)(void))pending { return ^(void) { return [self pendingPromise]; };}+ (instancetype (^)(id __nullable))resolved { return ^(id resolution) { return [self resolvedWith:resolution]; };}使用方式：FBLPromise.pending()FBLPromise.resolved(value)FBLPromise 提供了 fulfill: 方法，可以在异步操作成功后处理对应的值：- (void)fulfill:(nullable id)value { // 由于 value 是 id 类型，所以这里加多了个是否为 NSError 的判断 if ([value isKindOfClass:[NSError class]]) { [self reject:(NSError *)value]; } else { @synchronized(self) { // 只有是 FBLPromiseStatePending 状态才可以转换为 FBLPromiseStateFulfilled if (_state == FBLPromiseStatePending) { _state = FBLPromiseStateFulfilled; _value = value; _pendingObjects = nil; // 通知 Observers for (FBLPromiseObserver observer in _observers) { observer(_state, _value); } _observers = nil; dispatch_group_leave(FBLPromise.dispatchGroup); } } }}FBLPromise 为了线程安全，不少方法都加上了 @synchronized(self) ，性能上可能会有点差距。可以考虑使用下 pthread_mutex ，具体可以看 Lock 的解析。FBLPromise 也提供了 reject: 方法，异步操作可以在由错误生成时调用：- (void)reject:(NSError *)error { NSAssert([error isKindOfClass:[NSError class]], @&quot;Invalid error type.&quot;); if (![error isKindOfClass:[NSError class]]) { // Release 模式下调用 throw 抛出错误 @throw error; // NOLINT } @synchronized(self) { // if (_state == FBLPromiseStatePending) { _state = FBLPromiseStateRejected; _error = error; _pendingObjects = nil; for (FBLPromiseObserver observer in _observers) { observer(_state, _error); } _observers = nil; dispatch_group_leave(FBLPromise.dispatchGroup); } }}结合 pending ， fulfill: 和 reject: 方法，我们就可以不通过异步 block 来进行一些异步操作：FBLPromise&amp;lt;NSString *&amp;gt; *promise = [FBLPromise pendingPromise];// ...if (success) { [promise fulfill:@&quot;Hello world&quot;];} else { [promise reject:someError];}也可以直接生成已经处理完成的 FBLPromise :- (FBLPromise&amp;lt;NSData *&amp;gt; *) getDataAtURL:(NSURL *)anURL { if (anURL.absoluteString.length == 0) { return [FBLPromise resolvedWith:nil]; } return [self loadURL:anURL];}FBLPromise 对内有提供添加 Observer 的方法，可以分别处理 fulfill 和 reject ：- (void)observeOnQueue:(dispatch_queue_t)queue fulfill:(FBLPromiseOnFulfillBlock)onFulfill reject:(FBLPromiseOnRejectBlock)onReject { @synchronized(self) { switch (_state) { // 如果是在 FBLPromiseStatePending 状态，就添加到 Observers 中 case FBLPromiseStatePending: { if (!_observers) { _observers = [[NSMutableArray alloc] init]; } [_observers addObject:^(FBLPromiseState state, id __nullable resolution) { dispatch_group_async(FBLPromise.dispatchGroup, queue, ^{ switch (state) { case FBLPromiseStatePending: break; case FBLPromiseStateFulfilled: onFulfill(resolution); break; case FBLPromiseStateRejected: onReject(resolution); break; } }); }]; break; } // 如果当前是 FBLPromiseStateFulfilled 状态，直接调用 onFulfill 处理 _value 即可 case FBLPromiseStateFulfilled: { dispatch_group_async(FBLPromise.dispatchGroup, queue, ^{ onFulfill(self-&amp;gt;_value); }); break; } // 如果当前是 FBLPromiseStateRejected 状态，直接调用 onnReject 处理 _error 即可 case FBLPromiseStateRejected: { dispatch_group_async(FBLPromise.dispatchGroup, queue, ^{ onReject(self-&amp;gt;_error); }); break; } } }}FBLPromise 也提供了链式调用的方法，虽然说 Objective-C 的 [] 方法调用会使得链式调用写起来比较啰嗦：- (FBLPromise *)chainOnQueue:(dispatch_queue_t)queue chainedFulfill:(FBLPromiseChainedFulfillBlock)chainedFulfill chainedReject:(FBLPromiseChainedRejectBlock)chainedReject { FBLPromise *promise = [[FBLPromise alloc] initPending]; // resolver 的 block __auto_type resolver = ^(id __nullable value) { // 判断一下 value 是否为 FBLPromise // 如果是 FBLPromise ，就添加一个 Observer ，在这个 FBLPromise 的回调中进行处理 if ([value isKindOfClass:[FBLPromise class]]) { [(FBLPromise *)value observeOnQueue:queue fulfill:^(id __nullable value) { [promise fulfill:value]; } reject:^(NSError *error) { [promise reject:error]; }]; } else { // 如果不是 FBLPromise ，就直接调用 fulfill: 方法 // fulfill 内部会判断 value 是否为 error ，所以这里不用进行区分 [promise fulfill:value]; } }; // 添加 Observer 到 self [self observeOnQueue:queue fulfill:^(id __nullable value) { value = chainedFulfill ? chainedFulfill(value) : value; resolver(value); } reject:^(NSError *error) { id value = chainedReject ? chainedReject(error) : error; resolver(value); }]; return promise;}FBLPromise 最基本的方法已经介绍完毕，通过 FBLPromise 的这些方法可以将一些异步操作转换为 Promise 的形式，而 Promise 这个库在基础的方法上又提供了一些扩展。基础用法Async通过 async 操作符，可以直接在 block 中异步处理任务，然后调用 fulfill() 或者 reject() ：FBLPromise&amp;lt;NSString *&amp;gt; *promise = [FBLPromise onQueue:dispatch_get_main_queue() async:^(FBLPromiseFulfillBlock fulfill, FBLPromiseRejectBlock reject) { // 异步执行任务 if (success) { fulfill(@&quot;Hello world.&quot;); } else { reject(someError); }}];typedef void (^FBLPromiseFulfillBlock)(Value __nullable value) NS_SWIFT_UNAVAILABLE(&quot;&quot;);typedef void (^FBLPromiseRejectBlock)(NSError *error) NS_SWIFT_UNAVAILABLE(&quot;&quot;);typedef void (^FBLPromiseAsyncWorkBlock)(FBLPromiseFulfillBlock fulfill, FBLPromiseRejectBlock reject) NS_SWIFT_UNAVAILABLE(&quot;&quot;);+ (instancetype)onQueue:(dispatch_queue_t)queue async:(FBLPromiseAsyncWorkBlock)work { FBLPromise *promise = [[FBLPromise alloc] initPending]; dispatch_group_async(FBLPromise.dispatchGroup, queue, ^{ // block 的参数还是两个 block work( // FBLPromiseFulfillBlock ^(id __nullable value) { // 返回的 value 是 FBLPromise ，就添加 Observer ，然后在 FBLPromise 的结果处理中调用原来 FBLPromise 的方法 if ([value isKindOfClass:[FBLPromise class]]) { [(FBLPromise *)value observeOnQueue:queue fulfill:^(id __nullable value) { [promise fulfill:value]; } reject:^(NSError *error) { [promise reject:error]; }]; } else { [promise fulfill:value]; } }, // FBLPromiseRejectBlock ^(NSError *error) { [promise reject:error]; }); }); return promise;}Do如果任务不需要异步执行，可以使用 do 操作符，它比 async 更加简介：FBLPromise&amp;lt;NSString *&amp;gt; *promise = [FBLPromise do:^id { // Called asynchronously on the default queue. return success ? @&quot;Hello world&quot; : someError;}];+ (instancetype)onQueue:(dispatch_queue_t)queue do:(FBLPromiseDoWorkBlock)work { FBLPromise *promise = [[FBLPromise alloc] initPending]; dispatch_group_async(FBLPromise.dispatchGroup, queue, ^{ // 和 async 不同，这里直接调用 work() block 获取结果 id value = work(); if ([value isKindOfClass:[FBLPromise class]]) { [(FBLPromise *)value observeOnQueue:queue fulfill:^(id __nullable value) { [promise fulfill:value]; } reject:^(NSError *error) { [promise reject:error]; }]; } else { [promise fulfill:value]; } }); return promise;}由于 Objective-C 不是强类型语言，这里只能通过判断返回的 value 是否为 FBLPromise 来进行不同的处理。Thenthen 操作符支持将 FBLPromise 转换为另一个 FBLPromise 或者 value 。FBLPromise&amp;lt;NSNumber *&amp;gt; *numberPromise = [FBLPromise resolvedWith:@42];// 返回新的 FBLPromiseFBLPromise&amp;lt;NSString *&amp;gt; *chainedStringPromise = [numberPromise then:^id(NSNumber *number) { return [self stringFromNumber:number];}];// 返回 valueFBLPromise&amp;lt;NSString *&amp;gt; *chainedStringPromise = [numberPromise then:^id(NSNumber *number) { return [number stringValue];}];// 返回错误FBLPromise&amp;lt;NSString *&amp;gt; *chainedStringPromise = [numberPromise then:^id(NSNumber *number) { return [NSError errorWithDomain:@&quot;&quot; code:0 userInfo:nil];}];// 假的 void return ，可以返回 nil 或者直接返回同样的 valueFBLPromise&amp;lt;NSString *&amp;gt; *chainedStringPromise = [numberPromise then:^id(NSNumber *number) { NSLog(@&quot;%@&quot;, number); return nil; // OR return number;}];then 的实现比较简单，只是直接调用了 chainOnQueue:chainedFulfill:chainedReject: ：- (FBLPromise *)onQueue:(dispatch_queue_t)queue then:(FBLPromiseThenWorkBlock)work { // error 部分会在新的 FBLPromise 中处理，所以这里的 chainedReject 传 nil 就可以了 return [self chainOnQueue:queue chainedFulfill:work chainedReject:nil];}由于 Objective-C 不支持方法重载，所以这里不能提供一个 void 返回的 then 操作符版本，只能通过返回 nil 或者返回原有的值来达到相同的目的，建议返回原有的值，后续还可以继续通过 then 来进行链式调用。通过 then 来进行链式调用：- (FBLPromise&amp;lt;NSString *&amp;gt; *)work1:(NSString *)string { return [FBLPromise do:^id { return string; }];}- (FBLPromise&amp;lt;NSNumber *&amp;gt; *)work2:(NSString *)string { return [FBLPromise do:^id { return @(string.integerValue); }];}- (NSNumber *)work3:(NSNumber *)number { return @(number.integerValue * number.integerValue);}[[[[self work1:@&quot;10&quot;] then:^id(NSString *string) { return [self work2:string];}] then:^id(NSNumber *number) { return [self work3:number];}] then:^id(NSNumber *number) { NSLog(@&quot;%@&quot;, number); // 100 return number;}];Catchcatch 操作符和 then 相反，只处理错误部分，同时也会隐式得返回新的 FBLPromise 。[[self numberFromString:@&quot;abc&quot;] catch:^(NSError *error) { NSLog(@&quot;Cannot convert string to number: %@&quot;, error);}];通过 catch 和 then 结合，可以不需要在每次异步操作时都需要进行错误处理 ，而在上层统一处理错误：- (FBLPromise&amp;lt;NSString *&amp;gt; *)work1:(NSString *)string { return [FBLPromise do:^id { return string; }];}- (FBLPromise&amp;lt;NSNumber *&amp;gt; *)work2:(NSString *)string { return [FBLPromise do:^id { NSInteger number = string.integerValue; return number &amp;gt; 0 ? @(number) : [NSError errorWithDomain:@&quot;&quot; code:0 userInfo:nil]; }];}- (NSNumber *)work3:(NSNumber *)number { return @(number.integerValue * number.integerValue);}[[[[[self work1:@&quot;abc&quot;] then:^id(NSString *string) { return [self work2:string];}] then:^id(NSNumber *number) { return [self work3:number]; // Never executed.}] then:^id(NSNumber *number) { NSLog(@&quot;%@&quot;, number); // Never executed. return number;}] catch:^(NSError *error) { NSLog(@&quot;Cannot convert string to number: %@&quot;, error);}];进阶通过上面的 async ， do ， then 和 catch 操作符，就可以使用 FBLPromise 实现大多数异步操作序列。如果需要开箱即用的模式，这里还有一些进阶操作符。Allall 操作符是由类方法提供，它会等待数组中所有的 FBLPromise 都变为 fulfilled 后才会调用 fulfill: 方法。只要有其中一个 FBLPromise 被 rejected 了， all 方法生成的 FBLPromise 都会收到相同的错误。// 相同类型的 FBLPromise[[FBLPromise all:[contacts fbl_map:^id(MyContact *contact) { return [MyClient getAvatarForContact:contact];}]] then:^id(NSArray&amp;lt;UIImage *&amp;gt; *avatars) { [self updateAvatars:avatars]; return nil;}];// 不同类型的 FBLPromise[[FBLPromise all:@[ [MyClient getLocationForContact:contact], [MyClient getAvatarForContact:contact] ]] then:^id(NSArray *locationAndAvatar) { [self updateContactLocation:locationAndAvatar.firstObject andAvatar:locationAndAvatar.lastObject]; return nil; }];由于 Objective-C 不是强类型语言，所以调用 all 时需要非常小心，避免传输错误的类型。上面的 Objective-C 代码使用了 NSArray 的 fbl_map 方法，这个是 Google 出的一个为 Objective-C 补上缺少的函数式操作符的库：https://github.com/google/functional-objc 。all 方法的实现也比较朴实无华，我本来以为会用到 dispatch_group 之类的，没想到并没有，只是用一个 for 循环，在每次更新数组的 FBLPromise 状态时判断是否所有 FBLPromise 都已经完成处理。+ (FBLPromise&amp;lt;NSArray *&amp;gt; *)onQueue:(dispatch_queue_t)queue all:(NSArray *)allPromises { // 如果 allPromises 为空，就直接返回 if (allPromises.count == 0) { return [[FBLPromise alloc] initWithResolution:@[]]; } NSMutableArray *promises = [allPromises mutableCopy]; return [FBLPromise onQueue:queue async:^(FBLPromiseFulfillBlock fulfill, FBLPromiseRejectBlock reject) { // 这里需要处理传进来的数据，如果不是 FBLPromise 则将它转换为 FBLPromise for (NSUInteger i = 0; i &amp;lt; promises.count; ++i) { id promise = promises[i]; if ([promise isKindOfClass:self]) { continue; } else if ([promise isKindOfClass:[NSError class]]) { // 如果是 NSError 就直接调用 reject 方法。 reject(promise); return; } else { [promises replaceObjectAtIndex:i withObject:[[FBLPromise alloc] initWithResolution:promise]]; } } for (FBLPromise *promise in promises) { [promise observeOnQueue:queue fulfill:^(id __unused _) { // 每个 promise fulfill 时都判断下是否还有 promise 没处理完， // 时间复杂度 O(n) ，但是一般 promise 数组的数量也不会太多，所以影响不大 for (FBLPromise *promise in promises) { if (!promise.isFulfilled) { return; } } // 通过 key-value 的方式来返回 promises 的 value 数组 fulfill([promises valueForKey:NSStringFromSelector(@selector(value))]); } reject:^(NSError *error) { reject(error); }]; } }];}Alwaysalways 操作符用于在 Promise 管道上执行一些代码，不管这个 Promise 是 fulfilled 还是 rejected ：[[[[self getCurrentUserContactsAvatars] then:^id(NSArray&amp;lt;UIImage *&amp;gt; *avatars) { [self updateAvatars:avatars]; return avatars;}] catch:^(NSError *error) { [self showErrorAlert:error];}] always:^{ self.label.text = @&quot;All done.&quot;;}];always 是通过 chainOnQueue:chainedFulfill:chainedReject: 来实现的，以此来生成新的 FBLPromise ，和在 filfilled 和 rejected 中都调用 work ：- (FBLPromise *)onQueue:(dispatch_queue_t)queue always:(FBLPromiseAlwaysWorkBlock)work { return [self chainOnQueue:queue chainedFulfill:^id(id value) { work(); return value; } chainedReject:^id(NSError *error) { work(); return error; }];}Anyany 操作符和 all 类似，但是只有所有 promises 都是 rejected 才会调用 reject 方法，只要有一个 promise 是 fulfilled 都会调用 fulfill 方法：// 获取 promises 中的 value 或者 errorstatic NSArray *FBLPromiseCombineValuesAndErrors(NSArray&amp;lt;FBLPromise *&amp;gt; *promises) { NSMutableArray *combinedValuesAndErrors = [[NSMutableArray alloc] init]; for (FBLPromise *promise in promises) { if (promise.isFulfilled) { [combinedValuesAndErrors addObject:promise.value ?: [NSNull null]]; continue; } if (promise.isRejected) { [combinedValuesAndErrors addObject:promise.error]; continue; } assert(!promise.isPending); }; return combinedValuesAndErrors;}+ (FBLPromise&amp;lt;NSArray *&amp;gt; *)onQueue:(dispatch_queue_t)queue any:(NSArray *)anyPromises { if (anyPromises.count == 0) { return [[FBLPromise alloc] initWithResolution:@[]]; } NSMutableArray *promises = [anyPromises mutableCopy]; return [FBLPromise onQueue:queue async:^(FBLPromiseFulfillBlock fulfill, FBLPromiseRejectBlock reject) { // 照样转换为 FBLPromise for (NSUInteger i = 0; i &amp;lt; promises.count; ++i) { id promise = promises[i]; if ([promise isKindOfClass:self]) { continue; } else { [promises replaceObjectAtIndex:i withObject:[[FBLPromise alloc] initWithResolution:promise]]; } } for (FBLPromise *promise in promises) { [promise observeOnQueue:queue fulfill:^(id __unused _) { // 判断是否还有 promise 在处理中 for (FBLPromise *promise in promises) { if (promise.isPending) { return; } } // 所有 promises 都处理完毕后，调用 fulfill fulfill(FBLPromiseCombineValuesAndErrors(promises)); } reject:^(NSError *error) { BOOL atLeastOneIsFulfilled = NO; for (FBLPromise *promise in promises) { if (promise.isPending) { return; } if (promise.isFulfilled) { atLeastOneIsFulfilled = YES; } } // 数组中只要有一个 promise 是 fulfilled ，就调用 fulfill if (atLeastOneIsFulfilled) { fulfill(FBLPromiseCombineValuesAndErrors(promises)); } else { reject(error); } }]; } }];}AwaitPromise使用 awaitPromise 操作符，可以通过同步的方式来等待不同线程中的 promise 完成处理。当需要从多个异步操作中以不同的方式混合多个操作结果时，就可以使用 awaitPromise 来进行操作：[[[FBLPromise do:^id { NSError *error; NSNumber *minusFive = FBLPromiseAwait([calculator negate:@5], &amp;amp;error); if (error) return error; NSNumber *twentyFive = FBLPromiseAwait([calculator multiply:minusFive by:minusFive], &amp;amp;error); if (error) return error; NSNumber *twenty = FBLPromiseAwait([calculator add:twentyFive to:minusFive], &amp;amp;error); if (error) return error; NSNumber *five = FBLPromiseAwait([calculator subtract:twentyFive from:twenty], &amp;amp;error); if (error) return error; NSNumber *zero = FBLPromiseAwait([calculator add:minusFive to:five], &amp;amp;error); if (error) return error; NSNumber *result = FBLPromiseAwait([calculator multiply:zero by:five], &amp;amp;error); if (error) return error; return result;}] then:^id(NSNumber *result) { // ...}] catch:^(NSError *error) { // ...}];FBLPromiseAwait 通过 dispatch_semaphore_t 来将异步操作强制为同步：id __nullable FBLPromiseAwait(FBLPromise *promise, NSError **outError) { static dispatch_once_t onceToken; static dispatch_queue_t queue; dispatch_once(&amp;amp;onceToken, ^{ queue = dispatch_queue_create(&quot;com.google.FBLPromises.Await&quot;, DISPATCH_QUEUE_CONCURRENT); }); dispatch_semaphore_t semaphore = dispatch_semaphore_create(0); id __block resolution; NSError __block *blockError; [promise chainOnQueue:queue chainedFulfill:^id(id value) { resolution = value; dispatch_semaphore_signal(semaphore); return value; } chainedReject:^id(NSError *error) { blockError = error; dispatch_semaphore_signal(semaphore); return error; }]; // 等待 promise 调用 fulfill 或者 reject dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); if (outError) { *outError = blockError; } return resolution;}Delaydelay 操作符支持在 fulfill 中加入延迟时间，或者直接调用 reject ，可以用来在 promise 链式调用中添加人为的暂停：- (FBLPromise *)onQueue:(dispatch_queue_t)queue delay:(NSTimeInterval)interval { FBLPromise *promise = [[FBLPromise alloc] initPending]; [self observeOnQueue:queue fulfill:^(id __nullable value) { dispatch_after(dispatch_time(0, (int64_t)(interval * NSEC_PER_SEC)), queue, ^{ [promise fulfill:value]; }); } reject:^(NSError *error) { [promise reject:error]; }]; return promise;}Racerace 操作符和 all 相似，但是它会采用第一个完成处理的 promise 的结果：+ (instancetype)onQueue:(dispatch_queue_t)queue race:(NSArray *)racePromises { NSArray *promises = [racePromises copy]; return [FBLPromise onQueue:queue async:^(FBLPromiseFulfillBlock fulfill, FBLPromiseRejectBlock reject) { for (id promise in promises) { if (![promise isKindOfClass:self]) { fulfill(promise); return; } } // 虽然订阅了所有的 promise ， // 但是只有第一个完成处理的 promise 开业改变所返回的 promise 的状态 for (FBLPromise *promise in promises) { [promise observeOnQueue:queue fulfill:fulfill reject:reject]; } }];}Recoverrecover 操作符允许我们 catch 错误，不会破坏 promise 的链式调用。[[[self getCurrentUserContactsAvatars] recover:^id(NSError *error) { NSLog(@&quot;Fallback to default avatars due to error: %@&quot;, error); return [self getDefaultsAvatars];}] then:^id(NSArray&amp;lt;UIImage *&amp;gt; *avatars) { [self updateAvatars:avatars]; return avatars;}];实现也比较简单，在链式调用中加多一个中间层的处理：- (FBLPromise *)onQueue:(dispatch_queue_t)queue recover:(FBLPromiseRecoverWorkBlock)recovery { return [self chainOnQueue:queue chainedFulfill:nil chainedReject:^id(NSError *error) { // 调用 recovery 对 error 进行转换 return recovery(error); }];}Reducereduce 操作符使得可以指定 block 来从 promises 集合中生成单个值。比如说将数字数组转换为单个字符串：NSArray&amp;lt;NSNumber *&amp;gt; *numbers = @[ @1, @2, @3 ];[[[FBLPromise resolvedWith:@&quot;0&quot;] reduce:numbers combine:^id(NSString *partialString, NSNumber *nextNumber) { return [NSString stringWithFormat:@&quot;%@, %@&quot;, partialString, nextNumber.stringValue];}] then:^id(NSString *string) { // Final result = 0, 1, 2, 3 NSLog(@&quot;Final result = %@&quot;, string); return nil;}];- (FBLPromise *)onQueue:(dispatch_queue_t)queue reduce:(NSArray *)items combine:(FBLPromiseReducerBlock)reducer { FBLPromise *promise = self; for (id item in items) { promise = [promise chainOnQueue:queue chainedFulfill:^id(id value) { return reducer(value, item); } chainedReject:nil]; } return promise;}Retryretry 操作符提供了 promise 相关任务在失败时重试的灵活性。默认情况下， retry 操作符会在第一次 reject 后延迟一秒进行重试。如果默认操作不满足自己的需求，可以自定义队列，最大重试次数，延迟时间间隔以及不满足条件时提前退出。- (FBLPromise&amp;lt;NSData *, NSURLResponse *&amp;gt; *)fetchWithURL:(NSURL *)url { return [FBLPromise wrap2ObjectsOrErrorCompletion:^(FBLPromise2ObjectsOrErrorCompletion handler) { [NSURLSession.sharedSession dataTaskWithURL:url completionHandler:handler]; }];}NSURL *url = [NSURL URLWithString:@&quot;https://myurl.com&quot;];// 默认延迟 1s[[[FBLPromise retry:^id { return [self fetchWithURL:url];}] then:^id(NSArray *values) { NSLog(@&quot;%@&quot;, values); return nil;}] catch:^(NSError *error) { NSLog(@&quot;%@&quot;, error);}];// 自定义队列，最大尝试次数，延迟时间和是否提前退出dispatch_queue_t customQueue = dispatch_get_global_queue(QOS_CLASS_USER_INITIATED, 0);[[[FBLPromise onQueue:customQueue attempts:5 delay:2.0 condition:^BOOL(NSInteger remainingAttempts, NSError *error) { return error.code == NSURLErrorNotConnectedToInternet; } retry:^id { return [self fetchWithURL:url];}] then:^id(NSArray *values) { // 当 retry 成功时就会调用 then NSLog(@&quot;%@&quot;, values); return nil;}] catch:^(NSError *error) { // 不满足 retry 条件时就会抛出 error NSLog(@&quot;%@&quot;, error);}];static void FBLPromiseRetryAttempt(FBLPromise *promise, dispatch_queue_t queue, NSInteger count, NSTimeInterval interval, FBLPromiseRetryPredicateBlock predicate, FBLPromiseRetryWorkBlock work) { __auto_type retrier = ^(id __nullable value) { if ([value isKindOfClass:[NSError class]]) { // 如果 count &amp;lt;= 0 或者不满足重试条件，就不进行重试 if (count &amp;lt;= 0 || (predicate &amp;amp;&amp;amp; !predicate(count, value))) { [promise reject:value]; } else { // 延迟指定时间后重试， count - 1 dispatch_after(dispatch_time(0, (int64_t)(interval * NSEC_PER_SEC)), queue, ^{ FBLPromiseRetryAttempt(promise, queue, count - 1, interval, predicate, work); }); } } else { // 如果不是 error ，就调用 fulfill: [promise fulfill:value]; } }; id value = work(); // 如果 work() 处理之后是 FBLPromise ，就添加对应的监听 if ([value isKindOfClass:[FBLPromise class]]) { [(FBLPromise *)value observeOnQueue:queue fulfill:retrier reject:retrier]; } else { retrier(value); }}+ (FBLPromise *)onQueue:(dispatch_queue_t)queue attempts:(NSInteger)count delay:(NSTimeInterval)interval condition:(nullable FBLPromiseRetryPredicateBlock)predicate retry:(FBLPromiseRetryWorkBlock)work { FBLPromise *promise = [[FBLPromise alloc] initPending]; FBLPromiseRetryAttempt(promise, queue, count, interval, predicate, work); return promise;}Timeouttimeout 操作符支持在等待指定时间后，如果 promise 还没完成，就主动调用 reject ，错误类型为 FBLPromiseErrorCodeTimedOut 。- (FBLPromise *)onQueue:(dispatch_queue_t)queue timeout:(NSTimeInterval)interval { FBLPromise *promise = [[FBLPromise alloc] initPending]; [self observeOnQueue:queue fulfill:^(id __nullable value) { [promise fulfill:value]; } reject:^(NSError *error) { [promise reject:error]; }]; typeof(self) __weak weakPromise = promise; // 超过指定时间后就主动调用 reject dispatch_after(dispatch_time(0, (int64_t)(interval * NSEC_PER_SEC)), queue, ^{ NSError *timedOutError = [[NSError alloc] initWithDomain:FBLPromiseErrorDomain code:FBLPromiseErrorCodeTimedOut userInfo:nil]; [weakPromise reject:timedOutError]; }); return promise;}Validatevalidate 操作符使得可以对值进行检查而不破坏 promise 的链式调用。它和 then 类似，接收 promise 解析后的值，然后返回一个 bool 值。如果返回 false ，就会抛出一个错误，错误类型为 FBLPromiseErrorCodeValidationFailure 。[[[[self getAuthToken] validate:^BOOL(NSString *authToken) { return authToken.length &amp;gt; 0;}] then:^id(NSString *authToken) { return [self getDataWithToken:authToken];}] catch:^(NSError *error) { NSLog(@&quot;Failed to get auth token: %@&quot;, error);}];validate 的实现，实现也比较简单：- (FBLPromise*)onQueue:(dispatch_queue_t)queue validate:(FBLPromiseValidateWorkBlock)predicate { FBLPromiseChainedFulfillBlock chainedFulfill = ^id(id value) { // predicate 判断下，如果不满足就抛出 FBLPromiseErrorCodeValidationFailure return predicate(value) ? value : [[NSError alloc] initWithDomain:FBLPromiseErrorDomain code:FBLPromiseErrorCodeValidationFailure userInfo:nil]; }; return [self chainOnQueue:queue chainedFulfill:chainedFulfill chainedReject:nil];}Wrapwrap 操作符提供了一个便利的转换方式，支持将比较通用的回调，比如说 ^(id, NSError *) 转换为 FBLPromise ：- (FBLPromise&amp;lt;NSData*&amp;gt; *)newAsyncMethodReturningAPromise { return [FBLPromise wrapObjectOrErrorCompletion:^(FBLPromiseObjectOrErrorCompletion handler) { [MyClient wrappedAsyncMethodWithTypicalCompletion:handler]; }];}wrap 的实现：typedef void (^FBLPromiseObjectOrErrorCompletion)(id __nullable, NSError* __nullable);+ (instancetype)onQueue:(dispatch_queue_t)queue wrapObjectOrErrorCompletion:(void (^)(FBLPromiseObjectOrErrorCompletion))work { return [self onQueue:queue async:^(FBLPromiseFulfillBlock fulfill, FBLPromiseRejectBlock reject) { // 调用 work 来获取异步操作的结果，然后调用 FBLPromise 对应的方法 work(^(id __nullable value, NSError *__nullable error) { if (error) { reject(error); } else { fulfill(value); } }); }];}其它一些需要注意的问题默认的 GCD 队列Promises 内部使用 GCD 来派发不同的任务到不同的队列。如果没有指定，默认是主队列，为了避免造成主队列过于忙碌，影响用户的体验，通常会调整默认队列：FBLPromise.defaultDispatchQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);循环引用对于 promise 来说，你几乎不需要关心它们的循环引用。当 promise 完成任务时，它会释放掉所有 block 的强引用。尽管如此，还是有可能会产生循环引用。比如给说在 promise 的链式调用 block 中使用 promise 对象，如果你已经 promise 保存在一个局部变量中，就可能会发生循环引用，特别是创建一个不关联任何 block 的未完成解析的 promise 时：@implementation MyClass { FBLPromise&amp;lt;NSNumber *&amp;gt; *_promise;}- (FBLPromise&amp;lt;NSString *&amp;gt; *)doSomething { if (_promise == nil) { _promise = [FBLPromise pendingPromise]; } return [_promise then:^id(id number) { return [self doSomethingElse:number]; }];}- (NSString *)doSomethingElse:(NSNumber *)number { return number.stringValue;}@endself 持有 promise ，而 promise 又在 then block 中捕获 self 。我们可以通过 weak 引用来解决，因为我们知道 MyClass 的代码细节，但是这种情况有可能变得更加难以察觉：[[myClass doSomething] then:^id(NSString *string) { [myClass doSomeOtherThing];}];我们通过 MyClass 的方法来获取一个 promise ，然后通过链式调用来添加监听 block ，在里面再捕获 MyClass 的对象，这样也会产生循环引用。这部分代码并不知道 MyClass 会对 promise 进行强引用，而且还没有对应的 reslove 代码，所以这个循环引用不会被打破。对于 Promise 的循环引用来说，它和我们日常开发中遇到的循环引用情况差不多，并没有银弹，我们需要单独考虑每种情况。尽量避免使用 pending 的 promises ，一旦 promise 完成解析，就调用对应的方法。Objective-C 的点语法当在 Objective-C 中使用链式调用时，就会出现大量的方括号和其它一些格式问题，对于每个操作符， FBLPromise 都通过 block 的方式提供了点语法的调用方式：[self work1:@&quot;abc&quot;] .then(^id(NSString *string) { return [self work2:string]; }) .then(^id(NSNumber *number) { return [self work3:number]; }) .then(^id(NSNumber *number) { NSLog(@&quot;%@&quot;, number); return nil; }) .catch(^(NSError *error) { NSLog(@&quot;Cannot convert string to number: %@&quot;, error); });总结Promises 的 Objective-C 层实现比较简单，也比较小巧，代码量不多，主要是按照 Promise 的规则来，结合 GCD 提供符合定义的接口就好来。" }, { "title": "Promise - 介绍", "url": "/posts/promise-first/", "categories": "", "tags": "源码解析", "date": "2021-11-23 09:38:00 +0800", "snippet": "异步代码的问题通常来说，异步操作都会通过 block 的方式来执行回调，block 的参数会提供结果和错误。如果需要执行多个异步操作，需要将第二个异步操作嵌套在第一个操作的 block 中，同时也需要处理错误。在这样的嵌套代码中进行修改会变得非常痛苦。 Objective-C 的异步嵌套代码：- (void)getCurrentUserContactsAvatars:(void (^)(NSArray&amp;lt;UIImage *&amp;gt; *, NSError *))completion { [MyClient getCurrentUserWithCompletion:^(MyUser *currentUser, NSError *error) { if (error) { completion(nil, error); return; } [MyClient getContactsForUser:currentUser completion:^(NSArray&amp;lt;MyContact *&amp;gt; *contacts, NSError *error) { if (error) { completion(nil, error); return; } if (contacts.count == 0) { completion(@[], nil); return; } NSMutableArray&amp;lt;UIImage *&amp;gt; *avatars = [NSMutableArray array]; NSUInteger __block count = contacts.count; BOOL __block errorReported = NO; for (NSUInteger index = 0; index &amp;lt; count; ++index) { [avatars addObject:[NSNull null]]; } [contacts enumerateObjectsUsingBlock:^(MyContact *contact, NSUInteger index, BOOL __unused *_) { [MyClient getAvatarForContact:contact completion:^(UIImage *avatar, NSError *error) { if (errorReported) { return; } if (error) { completion(nil, error); errorReported = YES; return; } if (avatar) { avatars[index] = avatar; } if (--count == 0) { completion(avatars, nil); } }]; }]; }]; }];}Swift 的：func getCurrentUserContactsAvatars(_ completion: ([UIImage]?, Error?) -&amp;gt; Void) { MyClient.getCurrentUser() { currentUser, error in guard error == nil else { completion(nil, error) return } MyClient.getContacts(currentUser) { contacts, error in guard error == nil else { completion(nil, error) return } guard let contacts = contacts, !contacts.isEmpty() else { completion([UIImage](), nil) return } var count = contacts.count var avatars = [UIImage](repeating: nil, count: count) var errorReported = false for (index, contact) in contacts.enumerated() { MyClient.getAvatar(contact) { avatar, error in if (errorReported) { return } guard error == nil { completion(nil, error) errorReported = true return } if let avatar = avatar { avatars[index] = avatar } count -= 1 if count == 0 { completion(avatars.flatMap { $0 }, nil) } } } } }}由于 Swift 是使用 . 语法进行方法调用的，少了方括号，所以看起来会舒服点。一般来说如果有多个异步操作嵌套时，可以通过方法来进行封装，不会像上面这样，把所有异步操作的处理都放在同一个方法里。但是我们也可以通过 Promise 来进行优化：Objective-C ：- (FBLPromise&amp;lt;NSArray&amp;lt;UIImage *&amp;gt; *&amp;gt; *)getCurrentUserContactsAvatars { return [[[MyClient getCurrentUser] then:^id(MyUser *currentUser) { return [MyClient getContactsForUser:currentUser]; }] then:^id(NSArray&amp;lt;MyContact *&amp;gt; *contacts) { return [FBLPromise all:[contacts fbl_map:^id(MyContact *contact) { return [MyClient getAvatarForContact:contact]; }]]; }];Swift ：func getCurrentUserContactsAvatars() -&amp;gt; Promise&amp;lt;[UIImage]&amp;gt; { return MyClient.getCurrentUser().then(MyClient.getContacts).then { contacts in all(contacts.map(MyClient.getAvatar)) }}而所有异步操作的 error 都可以上层调用中统一处理。什么是 Promise通常来说， Promise 代表了一个异步任务最终有可能发生的结果或者任务失败的原因。类似的概念有 futures ，具体可以看维基上的说明：Futures and promises 。 pending （处理中）， Promise 还没有处理完毕； fulfilled ， Promise 已完成解析，包含某个值； rejected ，Promise 已完成解析，包含某个错误。一旦转换至 fulfilled 或者 rejected ，Promise 就无法再改变状态。Promise 同时还可以有无数个观察者，监听着它的状态，一旦 Promise 的状态有所更新，观察者就会接收到相应的消息。每个观察者在进行订阅时会生成一个新的 Promise ，这样可以进行链式的调用，也可以在不同的线程上进行异步的处理或者值转换。因此， Promise 是一种格式化处理异步回调，使得链式异步处理更加容易的方式。使得以下操作更加容易： 链式执行有依赖的异步操作，并且在最后执行回调； 统一处理不同的错误； 同时执行独立的异步操作，在最后执行回调； 执行很多异步操作，并且返回第一个值； 重试异步操作； 等等。iOS 有不少实现来 Promise 或者有类似功能的库：PromisesPromiseKit: Promises for Swift &amp;amp; ObjC.BrightFutures: Write great asynchronous code in Swift using futures and promisesHydra: ⚡️ Lightweight full-featured Promises, Async &amp;amp; Await Library in SwiftRxSwift: Reactive Programming in Swift后续会对 Promises 和 PromiseKit 进行源码解析。" }, { "title": "FBAllocationTracker", "url": "/posts/fballocationtracker/", "categories": "", "tags": "源码解析", "date": "2021-11-02 19:57:00 +0800", "snippet": "简单介绍下FBAllocationTracker 是 Facebook 开源的一个用于查找当前存活的 Objective-C 对象的工具库。 FBAllocationTracker 提供了查找在内存中的 Objective-C 对象的接口。它可以获取指定类的所有对象，也可以像 Instruments 那样进行内存增长标记，然后只查找标记时间内创建的对象。FBAllocationTracker 支持两种模式：记录对象和只是计算 alloc/dealloc 。第一种模式需要的操作步骤更多点，然后如果只是想进行统计，不想影响性能，可以使用第二种模式。相关操作接口由 FBAllocationTrackerManager 提供：#import &amp;lt;FBAllocationTracker/FBAllocationTrackerManager.h&amp;gt;int main(int argc, char * argv[]) { [[FBAllocationTrackerManager sharedManager] startTrackingAllocations]; [[FBAllocationTrackerManager sharedManager] enableGenerations]; @autoreleasepool { return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); }}startTrackingAllocations 方法会 swizzle NSObject 的 +alloc 和 -dealloc 方法，以此来计算对象的初始化和释放，而 enableGenerations 则会开始跟踪对象实例。NSArray&amp;lt;FBAllocationTrackerSummary *&amp;gt; *summaries = [[FBAllocationTrackerManager sharedManager] currentAllocationSummary];FBAllocationTrackerSummary 会记录类对应的对象个数，也可以获取特定类的对象：NSArray *instances =[[FBAllocationTrackerManager sharedManager] instancesOfClasses:@[[ViewController class]]];Generations 的操作则类似于 Instruments 的 Allocations ，可以通过 markGeneration 来区分不同时间段内创建的对象：- (void)someFunction { // Enable generations (if not already enabled in main.m) [[FBAllocationTrackerManager sharedManager] enableGenerations]; // Object a will be kept in generation with index 0 NSObject *a = [NSObject new]; // We are marking new generation [[FBAllocationTrackerManager sharedManager] markGeneration]; // Objects b and c will be kept in second generation at index 1 NSObject *b = [NSObject new]; NSObject *c = [NSObject new]; [[FBAllocationTrackerManager sharedManager] markGeneration]; // Object d will be kept in third generation at index 2 NSObject *d = [NSObject new];}开启计数记录FBAllocationTrackerManager 的 startTrackingAllocations 实现比较简单，只是调用了一下 AllocationTracker 的 beginTracking 方法：- (void)startTrackingAllocations{ FB::AllocationTracker::beginTracking();}FB:: AllocationTracker:: beginTracking 则调用了 turnOnTracking 方法来进行 swizzle ：void beginTracking() { std::lock_guard&amp;lt;std::mutex&amp;gt; l(*_lock); if (_trackingInProgress) { return; } _trackingInProgress = true; turnOnTracking();}lock_guard 是基于 mutex 进行封装的，提供了 RAII 风格的机制，会在作用域内拥有一个 mutex 的变量。当创建一个 lock_guard 对象时，它会去获取 mutex 的所有权，当函数执行完毕，离开 lock_guard 所在的作用域时， lock_guard 会进行析构，而 mutex 也会被释放掉。turnOnTracking 则负责对 alloc 和 dealloc 方法进行 swizzle ，常规的 swizzle 操作，这里就不展开说明了：void turnOnTracking(void) { prepareOriginalMethods(); replaceSelectorWithSelector([NSObject class], @selector(allocWithZone:), @selector(fb_newAllocWithZone:), FBClassMethod); replaceSelectorWithSelector([NSObject class], sel_registerName(&quot;dealloc&quot;), @selector(fb_newDealloc), FBInstanceMethod);}FBAllocationTracker 会在 alloc 方法中对创建的对象进行记录：+ (id)fb_newAllocWithZone:(id)zone{ id object = [self fb_originalAllocWithZone:zone]; FB::AllocationTracker::incrementAllocations(object); return object;}void incrementAllocations(__unsafe_unretained id obj) { Class aCls = [obj class]; // 1. _shouldTrackClass 的实现非常简单，只是做了下防空判断，以及如果是 NSTaggedPointerStringCStringContainer 则跳过记录 if (!_shouldTrackClass(aCls)) { return; } // 2. 常规的 lock_guard 操作 std::lock_guard&amp;lt;std::mutex&amp;gt; l(*_lock); // 3. 使用 _allocations 记录计数 if (_trackingInProgress) { (*_allocations)[aCls]++; } // 4. 使用 _generationManager 记录对象 if (_generationManager) { _generationManager-&amp;gt;addObject(obj); }}incrementAllocations 的实现也比较简单，都是调用相关 API 。 TrackerMap 定义如下：using TrackerMap = std::unordered_map&amp;lt; __unsafe_unretained Class, NSUInteger, FB::AllocationTracker::ClassHashFunctor, FB::AllocationTracker::ClassEqualFunctor&amp;gt;Class 为 key ， 相关计数为 value ， ClassHashFunctor 和 ClassEqualFunctor 的实现：struct ClassHashFunctor { size_t operator()(const Class key) const { // 使用 size_t 对 Class 进行转换 return (size_t)(key); }};struct ClassEqualFunctor { bool operator()(const Class left, const Class right) const { return left == right; }};incrementDeallocations 的实现也和 incrementAllocations 类似，只不过使用了另外一个 map 来进行 dealloc 的计数：void incrementDeallocations(__unsafe_unretained id obj) { Class aCls = [obj class]; if (!_shouldTrackClass(aCls)) { return; } std::lock_guard&amp;lt;std::mutex&amp;gt; l(*_lock); // _deallocations 也是相同的 unordered_map if (_trackingInProgress) { (*_deallocations)[aCls]++; } if (_generationManager) { _generationManager-&amp;gt;removeObject(obj); }}计数相关操作就介绍完毕了，操作也比较简单： incrementAllocations 记录 Class 的 alloc 调用次数； incrementDeallocations 记录 Class 的 dealloc 调用次数。跟踪对象实例上面的计数操作只是对次数进行记录，记录的维度是 Class 级别，没有记录每个对象，如果想要对对象也进行记录，就需要调用 Generation 的相关方法。开启跟踪对象：/// FBAllocationTrackerManager- (void)enableGenerations{ dispatch_sync(_queue, ^{ if (self-&amp;gt;_generationsClients == 0) { FB::AllocationTracker::enableGenerations(); FB::AllocationTracker::markGeneration(); } self-&amp;gt;_generationsClients += 1; });}/// AllocationTrackervoid enableGenerations() { std::lock_guard&amp;lt;std::mutex&amp;gt; l(*_lock); if (_generationManager) { return; } /// 创建 `GenerationManager` ，`GenerationManager` 负责维护对象和 `Generation` 之间的映射关系。 _generationManager = new GenerationManager();}/// AllocationTrackervoid markGeneration(void) { std::lock_guard&amp;lt;std::mutex&amp;gt; l(*_lock); if (_generationManager) { _generationManager-&amp;gt;markGeneration(); }}Generation 与 GenerationManagerGeneration 则实现了类似 Instruments 的 allocations 操作，让你对特定时间段内创建的对象进行标记。 Generation 提供了一个以 Class 为 key ， value 为 unordered_set&amp;lt;__unsafe_unretained id&amp;gt; ，也就是说可以根据 Class 或者指定 Generation 来查找所包含的对象。Generation 的属性也比较简单，只有一个 objects 属性：typedef std::unordered_set&amp;lt;__unsafe_unretained id, ObjectHashFunctor, ObjectEqualFunctor&amp;gt; GenerationList;typedef std::unordered_map&amp;lt;Class, GenerationList, ClassHashFunctor, ClassEqualFunctor&amp;gt; GenerationMap;class Generation { private: GenerationMap objects; };}GenerationMap 对外也提供了相关的添加和移除操作：void Generation::add(__unsafe_unretained id object) { Class aCls = [object class]; objects[aCls].insert(object);} void Generation::remove(__unsafe_unretained id object) { Class aCls = [object class]; objects[aCls].erase(object); }GenerationManager 负责管理 Generation ，它提供了在 O(1) 时间复杂度内查找指针来自哪个 Generation 的操作。包含两个私有属性：// 用于在 O(1) 时间内查找对象来自哪一个 Generation ，提高性能std::unordered_map&amp;lt;__unsafe_unretained id, NSInteger, ObjectHashFunctor, ObjectEqualFunctor&amp;gt; generationMapping;// Generation 对应的 vectorstd::vector&amp;lt;Generation&amp;gt; generations;调用 markGeneration 方法可以创建新的 Generation ，添加到 generations 中，而 GenerationManager 会把创建的对象加到最新的 Generation 中：void GenerationManager::markGeneration() { generations.emplace_back(Generation {});}addObject 方法则会把 object 添加到 lastGeneration 中，同时建立 object 和 Generation 的映射关系：void GenerationManager::addObject(__unsafe_unretained id object){ NSInteger numberOfGenerations = generations.size(); if (numberOfGenerations == 0) { return; } Generation &amp;amp;lastGeneration = generations.back(); // 所对应的层级为当前的 size - 1 generationMapping[object] = numberOfGenerations - 1; lastGeneration.add(object);}removeObject 实现也比较简单，基本上就是把 addObject 的改动回滚下：void GenerationManager::removeObject(__unsafe_unretained id object) { auto it = generationMapping.find(object); if (it == generationMapping.end()) { return; } NSInteger generationNumber = it-&amp;gt;second; // 根据 generationMapping 找到对象所对应的层级，然后找到对应的 Generation Generation &amp;amp;generation = generations[generationNumber]; generation.remove(object); generationMapping.erase(object);}获取统计数据当完成数据收集后，我们可以通过 FBAllocationTrackerManager 提供的接口来获取相关数据， currentAllocationSummary 可以获取当前所有的对象，而 FBAllocationTrackerSummary 也提供了相关的数据：NSArray&amp;lt;FBAllocationTrackerSummary *&amp;gt; *summaries = [[FBAllocationTrackerManager sharedManager] currentAllocationSummary];// FBAllocationTrackerSummary.h@property (nonatomic, readonly) NSUInteger allocations;@property (nonatomic, readonly) NSUInteger deallocations;@property (nonatomic, readonly) NSInteger aliveObjects;@property (nonatomic, copy, readonly, nonnull) NSString *className;@property (nonatomic, readonly) NSUInteger instanceSize;而 FBAllocationTrackerSummary 则是由 struct SingleClassSummary 转换而来的：// AllocationSummary 定义typedef std::unordered_map&amp;lt;Class, SingleClassSummary, ClassHashFunctor, ClassEqualFunctor&amp;gt; AllocationSummary;// SingleClassSummary 定义struct SingleClassSummary { NSUInteger allocations; NSUInteger deallocations; NSUInteger instanceSize;};- (NSArray&amp;lt;FBAllocationTrackerSummary *&amp;gt; *)currentAllocationSummary{ // 通过 AllocationTracker 来获取 AllocationSummary FB::AllocationTracker::AllocationSummary summary = FB::AllocationTracker::allocationTrackerSummary(); NSMutableArray&amp;lt;FBAllocationTrackerSummary *&amp;gt; *array = [NSMutableArray new]; // Allocation 是一个以 Class 为 key ， SingleClassSummary 为 value 的 unordered_map // 因此可以利用其 key he value 来生成 FBAllocationTrackerSummary for (const auto &amp;amp;item: summary) { FB::AllocationTracker::SingleClassSummary singleSummary = item.second; Class aCls = item.first; NSString *className = NSStringFromClass(aCls); FBAllocationTrackerSummary *summaryObject = [[FBAllocationTrackerSummary alloc] initWithAllocations:singleSummary.allocations deallocations:singleSummary.deallocations aliveObjects:singleSummary.allocations - singleSummary.deallocations className:className instanceSize:singleSummary.instanceSize]; [array addObject:summaryObject]; } return array;}AllocationSummary allocationTrackerSummary() { TrackerMap allocationsUntilNow; TrackerMap deallocationsUntilNow; { std::lock_guard&amp;lt;std::mutex&amp;gt; l(*_lock); // 创建当前所对应的新的 TrackerMap allocationsUntilNow = TrackerMap(*_allocations); deallocationsUntilNow = TrackerMap(*_deallocations); } // Class 的 unordered_set ，记录所存活的对象对应的 Class std::unordered_set&amp;lt; __unsafe_unretained Class, FB::AllocationTracker::ClassHashFunctor, FB::AllocationTracker::ClassEqualFunctor&amp;gt; keys; for (const auto &amp;amp;kv: allocationsUntilNow) { keys.insert(kv.first); } for (const auto &amp;amp;kv: deallocationsUntilNow) { keys.insert(kv.first); } AllocationSummary summary; for (Class aCls: keys) { // 如果 alloc 的次数小于 dealloc 的次数，则表明该类在内存中的所有对象都已经释放，不需要处理 if (allocationsUntilNow[aCls] - deallocationsUntilNow[aCls] &amp;lt;= 0) { continue; } // 生成 SingleClassSummary SingleClassSummary singleSummary = { .allocations = allocationsUntilNow[aCls], .deallocations = deallocationsUntilNow[aCls], .instanceSize = class_getInstanceSize(aCls), }; summary[aCls] = singleSummary; } return summary; }FBAllocationTrackerManager 也提供了根据 Generation 进行划分的接口：/// GenerationSummary 定义为以 Class 为 key , 存活计数为 valuetypedef std::unordered_map&amp;lt;Class, NSInteger, ClassHashFunctor, ClassEqualFunctor&amp;gt; GenerationSummary;/// FullGenerationSummary 为基于不同层级的 Generation 生成的 vector&amp;lt;GenerationSummary&amp;gt;typedef std::vector&amp;lt;GenerationSummary&amp;gt; FullGenerationSummary;- (NSArray&amp;lt;NSArray&amp;lt;FBAllocationTrackerSummary *&amp;gt; *&amp;gt; *)currentSummaryForGenerations{ FB::AllocationTracker::FullGenerationSummary summary = FB::AllocationTracker::generationSummary(); if (summary.size() == 0) { return nil; } NSMutableArray *array = [NSMutableArray new]; for (const auto &amp;amp;generation: summary) { [array addObject:[self _getSingleGenerationSummary:generation]]; } return array;}取出的 FullGenerationSummary 还不能直接使用，需要转化为 Objective-C 层级的对象：- (NSArray&amp;lt;FBAllocationTrackerSummary *&amp;gt; *)_getSingleGenerationSummary:(const FB::AllocationTracker::GenerationSummary &amp;amp;)summary{ NSMutableArray *array = [NSMutableArray new]; for (const auto &amp;amp;kv: summary) { // 如上所述，key 为 Class ， value 为存活计数 FBAllocationTrackerSummary *summaryObject = [[FBAllocationTrackerSummary alloc] initWithAllocations:0 deallocations:0 aliveObjects:kv.second className:NSStringFromClass(kv.first) instanceSize:class_getInstanceSize(kv.first)]; [array addObject:summaryObject]; } return array;}而 FullGenerationSummary 则由 FBAllocationTracker 负责生成：FullGenerationSummary generationSummary() { std::lock_guard&amp;lt;std::mutex&amp;gt; l(*_lock); /// 如果 _generationManager 为 nil ，则表示没有开启 Generation 记录，直接返回一个空的 FullGenerationSummary if (_generationManager) { return _generationManager-&amp;gt;summary(); } return FullGenerationSummary {};}FullGenerationSummary GenerationManager::summary() const { FullGenerationSummary fullSummary; // 获取每个 Generation 的 summary （全部存活对象的计数），以 Class 为 key for (const auto &amp;amp;generation: generations) { fullSummary.push_back(generation.getSummary()); } return fullSummary;}GenerationSummary Generation::getSummary() const { GenerationSummary summary; // 简单地遍历下 Generation 的 objects for (const auto &amp;amp;kv: objects) { Class aCls = kv.first; const GenerationList &amp;amp;list = kv.second; NSInteger count = list.size(); summary[aCls] = count; } return summary;}其它FBAllocationTracker 基于 Objective-C/C++ 进行混编，使用了不少 C++ 特性，比如说 std::lock_guard - cppreference.com 。这是一个很好的示例。不少追求性能的 Objective-C 开源库都有类似的操作，在对性能有要求的部分可以使用 C/C++ 来编写，提供给外部的接口和对象可以转为 Objective-C 。FBAllocationTracker 是一个比较简单的库，支持的功能也比较简单，它只支持监听 Objective-C 的对象，不支持 C++/C 在堆上操作的对象，如果需要更全面的监控信息，可以考虑使用 OOMDetector ，当然能力越大责任也越大， OOMDetector 由于使用了 fishhook 对 alloc 相关方法进行了 hook ，更加底层，且影响面更大，接入时需要更加小心和谨慎。 OOMDetector 的相关 hook 操作：OOMDetector/CMallocHook.mm 。通过 FBAllocationTracker 可以获取到存活的对象，结合 FBRetainCycleDetector 可以检测是否是循环引用导致的，FBMemoryProfiler 基于这两者提供了方便操作的 UI 视图。" }, { "title": "Objective-C Direct Methods", "url": "/posts/objective-c-direct-methods/", "categories": "", "tags": "Objective-C", "date": "2021-06-22 23:54:00 +0800", "snippet": "Objective-C Direct MethodsClang 13 documentationcommit :Implement attribute((objc_direct)), attribute((objc_direct_me… · llvm/llvm-project@d4e1ba3Clang 13 新增了 objc_direct 声明，对应的 Xcode 版本为 12 。使用 objc_direct 标记的 Objective-C 方法为直接派发方法。 direct 方法在调用时类似于静态方法，降低了一定的性能损耗，但是也牺牲了 Objective-C 的一些特性。direct 方法的消息发送会像 C 函数那样直接调用实现，没有走 Objective-C 的消息发送流程。这里速度会比较快和有可能进行函数内联，这同时意味着方法不能够被重写或者动态替换。因此 direct 方法不会出现在 class 的方法列表中，可以减少代码段的大小。虽然说 direct 方法会当做 C 函数来进行静态调用，但是它仍然遵循以下 Objective-C 语义： 如果接收者为 nil ，则不会进行任何处理和返回方法返回值中对应的 zero 值； 调用 direct 方法也会触发 class 的初始化，包括调用 +initiablize 方法； 保留方法选择器的隐式参数 _cmd ，但是如果 _cmd 参数没有在方法中进行调用，那么实现中将不会保留对 _cmd 的引用，以减少代码段的大小。同时不支持以下操作： 在 protocol 中声明 direct 方法； 在子类重写 direct 方法； 在子类中重写非 direct 方法，同时定义为 direct ； 相同的方法在不同的类接口中对 direct 的声明不一致； 在 interface 和 implement 中对 direct 的声明不一致； 不可以通过 @selector 和方法名来获取 direct 方法的 SEL 。class 的 interface 包括了 class 的 @interface block ，extensions ， categories ，protocol 和父类的 interface 。Objective-C 属性也支持声明为 direct 属性，在没有显示声明 getter 和 setter 的前提下，会默认声明为 direct 。如果需要批量声明，可以使用 objc_direct_members 声明。可以在 @interface 或者 @implementation 中进行声明，对应的 .m 中的方法都会被设为 direct 。当 objc_direct_members 放置在 @interface 时，只有出现在 @interface 的方法会设置为 direct ，这包括了属性的隐式方法声明。如果在 @implementation 中进行声明，除了已在其它 @interface 声明为 non-direct 的方法，其它方法都会声明为 direct 。如果没办法保证外部调用会如何处理方法，那么比较保守的策略就是只处理 .m 里的私有方法和属性。Pierre H. 🔥🌸 on Twitter: “About objc_direct, a thread.I should have probably anticipated that people would raise eyebrows and spent more time explaining the point in the LLVM commit, so here it is… https://t.co/zgnaKD6n4A / Twitter”这条推下面详细说明了 Objective-C 消息发送机制带来的损耗，主要包括以下四方面： 代码段大小，由于需要查找方法指针 IMP ，所以需要传递 sekf 和 _cmd 参数。每次调用会带来额外 8 字节的消耗，由于 objc_msgSend 的调用非常频繁，所以 8 字节叠加后占比非常大。在 CloudKit 中，这两个指令占了 __text 段 10.7% 的大小； 优化阻碍，为了更强的动态性和 ARC 等特性， Objective-C 要求编译器做出巨大的保护性编程。拒绝内联是比较明显的一个问题，还有的是在获取可读的 integer 属性时也会带来影响，ARC 会插入 objc_retain()/objc_releas() 方法包围属性的 getter 方法； 静态元数据，每个 Objective-C 的方法都会增加 150-250 字节大小。 类的方法列表中会增加 24 字节； 方法的 type 字符串超过 60 字节，如果不使用 NSInvocation 则没有不需要该字符串； 方法的选择器平均为 20+ 字节。 运行时元数据，为了加快消息发送的速度，运行时会创建 IMP 缓存，即使是一些只调用一次的方法，也会带进程带来负担，同时由于运行时初始化时需要重定位指针，也会对启动性能带来影响。Objective-C Direct Methods大多数情况下， direct 方法其实不会带来明显的性能收益， objc_msgSend 的处理速度其实非常快，这得益于极其侵略的缓存策略，广泛的底层优化以及现代处理器的进步。在存量代码比较多的情况下，把方法改写为 direct 会减少一定的代码段大小。Direct Calls with Objective-C性能相关数据：PSPDFKit 替换了 3717 个方法，减少了 700 KB ，平均每个方法减少了 200 字节。建议只在内部属性或者方法中使用，在公开的属性或者方法中使用时，如果有新开启 direct ，上层有调用相关接口的二进制库都需要重新编译。†" }, { "title": "一种使用 CocoaPods 同步 Git hooks 的方案", "url": "/posts/cocoapods-sync-githooks/", "categories": "", "tags": "CocoaPods", "date": "2021-05-23 21:19:00 +0800", "snippet": "Git hooks 是什么Git hooks 是一段脚本，可以在 Git 执行某些操作之前或者之后执行，比如说 commit ， push 或者 receive 。随便打开某个 Git 项目的目录，可以在 .git/hooks 这个目录下看到 Git hooks 的示例代码，不过都是以 .sample 后缀结尾，需要把 .sample 去掉后才会生效。Git hooks 可以使用多种语言编写，包括 Shell ， Ruby ， Perl 和 Python 等。如果想要跳过 Git hooks 的检查，可以在执行 Git 命令时添加 —no-verify 参数，那么就算 Git hooks 失败，命令也会继续执行。但是必须要清楚明白跳过 Git hooks 的后果。Git hooks 作用Git-SCM Git - Git Hooks 详细说明了各种 hooks 的类型，同时也提供了中文版本 Pro Git - Git hooks 。常用的 hooks ： pre-commit ：执行 git commit 时触发，可以用于代码规范等，就 iOS 来说，如果团队间禁止使用 xib 或者 storyboard ，那么在 commit 时可以检测是否有 xib 或者 storyboard 文件。也可以用于资源大小的检测，可以设置图片资源大小不能超过某个尺寸； prepare-commit-msg ： 在执行 git commit 时会调用，可用于提供 commit 信息的模版； commit-msg ：在完成 commit message 编写和提交后出发，可用于校验 commit 的说明是否符合规范，结合 prepare-commit-msg 可以在团队间设置 commit 信息的规范； post-commit ：在完成 commit 之后执行，不接受任何参数，但是可以通过 git log -1 HEAD 来获取最后一次的提交信息，可以用于发送邮件提醒之类。同步问题Git hooks 所在目录 .git/hooks 不会被 Git 记录，所以只能通过其它工具来辅助同步。比较粗糙的方法是把 Git hooks 脚本放到另外一个 Git 仓库下，然后通知团队的其他成员进行同步。每次有改动时再手动进行同步。这种方法一听起来就比较粗糙，于是各种包管理工具和语言就开发出自己的 Git hooks 管理工具，比如说 husky 。CocoaPods 也有一个插件用于管理 Git hooks 脚本：cocoapods-githooks ，但是这个插件有以下几个问题： Git hooks 脚本和仓库绑定在一起，无法在各个项目间共享； 所有 Git hooks 脚本都放在同一个文件中，无法根据不同的功能进行组装。新的插件其实 CocoaPods 已经为我们提供了包管理功能，所以我们可以通过 Podfile 来使用和管理不同的 Git hooks 脚本。首先通过 CocoaPods 的 plugin 命令来创建插件：pod plugins create cocoapods-sync-githooks原理解析CocoaPods 为插件提供了 post_install 和 post_update 的 hook 入口，所以插件可以通过注册对应 hook_name 来在 pod install 和 pod update 时进行一些操作，这部分代码添加在 cocoapods_plugin.rb 中：require &#39;cocoapods-sync-githooks/command&#39;require &#39;cocoapods-sync-githooks/sync_githooks&#39;module CocoapodsGitHooks Pod::HooksManager.register(&#39;cocoapods-sync-githooks&#39;, :post_install) do |context| CocoapodsGitHooks::GitHooksManager.sync end Pod::HooksManager.register(&#39;cocoapods-sync-githooks&#39;, :post_update) do |context| CocoapodsGitHooks::GitHooksManager.sync endendcocoapods_plugin.rb 对应实现：def sync Pod::UI.message &#39;Start syncing Git Hook&#39; do # 1. 校验是否有 .git 目录 return unless validate_git_directory? # 2. 如果没有 .git/hooks 目录，就主动创建 FileUtils.mkdir &#39;.git/hooks&#39; unless File.directory?(&#39;.git/hooks&#39;) # 3. 找到对应的 Githooks 库 abstract_target = abstract_target_of_githooks return if abstract_target.nil? dependencies = dependencies_in_target(abstract_target) if dependencies.nil? || dependencies.empty? Pod::UI.warn &#39;The dependencies of SyncGithooks is nil or empty.&#39; return end dependencies.each { |dependency| Pod::UI.message &quot;- #{dependency.name}&quot; } #4. 开始同步 sync_githooks_in_dependencies(dependencies) end Pod::UI.message &#39;Githooks are synced&#39; endend为了区分普通的 Pod 库和 Git hooks 专用 Pod 库， Podfile 中需要新增一个 Githooks 的 abstract_target ，所有 Git hooks 相关库都放到这个 target 下。# @return [TargetDefinition]def abstract_target_of_githooks abstract_target = nil # 通过 Podfile 来获取所有 target podfile = Pod::Config.instance.podfile podfile.target_definition_list.each do |target| if target.name == &#39;Githooks&#39; abstract_target = target break end end unless podfile.target_definition_list.nil? if abstract_target.nil? Pod::UI.puts &#39;The abstract_target of SyncGithooks is not defined.&#39; return nil end # 找到 Githooks 的 target abstract_targetend找到 GitHooks 对应的库后，开始同步 Git hooks 脚本到 .git/hooks 目录下。 sync_githooks_in_dependencies 写得有点长，会分成两部分来说明：# @return [Array&amp;lt;String&amp;gt;]def hook_types %w(applypatch-msg commit-msg fsmonitor-watchman post-update pre-applypatch pre-commit pre-merge-commit pre-push pre-rebase prepare-commit-msg push-to-checkout)enddef sync_githooks_in_dependencies(dependencies) pods_directory = &quot;#{Dir.pwd}/Pods&quot; hook_dependencies = Hash.new([]) dependencies.each do |dependency| # 1. 由于 `dependency` 为 `local pod` 时对应的目录为 Pod 库自己所在的目录， # 所以 `dependency_directory` 需要判断一下是否为 `local` ，如果是 `local` 就使用 `external_source[:path]` ， # 否则使用 `pods_directory` 和 `dependency.name` 来拼成对应的目录 dependency_directory = if dependency.local? File.expand_path(dependency.external_source[:path]) else &quot;#{pods_directory}/#{dependency.name}&quot; end hook_types.each { |hook_type| # 2. 如果 `dependency` 对应的目录下 （ `githooks` ）中有对应类型的脚本，就把 `dependency` 添加到 `hook_dependencies[hook_type]` 中 file_path = &quot;#{dependency_directory}/githooks/#{hook_type}&quot; if File.exist?(file_path) hook_dependencies[hook_type] += [dependency] end } end # ...end收集好对应的 Git hooks 脚本后就可以开始同步：git_hook_directory = &#39;.git/hooks&#39;hook_dependencies.each_pair { |key, dependencies| file_path = &quot;#{git_hook_directory}/#{key}&quot; # 1. 先删除原有的 Git hook 对应类型的脚本 File.delete(file_path) if File.exist?(file_path) File.new(file_path, &#39;w&#39;) File.open(file_path, File::RDWR) do |file| # 2. 设置语言环境，以便可以直接执行语言 file.write(&quot;#!/bin/sh\\n&quot;) file.write(&quot;#!/usr/bin/env ruby\\n&quot;) file.write(&quot;#!/usr/bin/env python\\n&quot;) dependencies.each do |dependency| dependency_directory = if dependency.local? File.expand_path(dependency.external_source[:path]) else &quot;#{pods_directory}/#{dependency.name}&quot; end # 3. 获取对应类型的 Git hook 脚本目录 hook_file_path = &quot;#{dependency_directory}/githooks/#{key}&quot; file.write(&quot;# #{dependency.name} githook\\n&quot;) # 4. 生成对应的脚本方法，同步 Git hook 库的脚本到方法中 file.write(&quot;if [ -f \\&quot;#{hook_file_path}\\&quot; ]; then\\n&quot;) file.write(&quot; function #{dependency.name}(){\\n&quot;) file.write(&quot; local script_directory=#{dependency_directory}/scripts\\n&quot;) File.readlines(hook_file_path).each { |line| file.write(&quot; #{line}&quot;) } file.write(&quot;\\n }\\n&quot;) # 5. 执行对应的方法 file.write(&quot; #{dependency.name}\\n&quot;) file.write(&quot;fi\\n&quot;) end FileUtils.chmod(&#39;+x&#39;, file_path) end}为了保证 Git hook 源脚本的简洁，插件提供了执行 scripts 中脚本的方法， Git hook 库的可以直接调用 scripts 中的脚本，githooksA/pre-commit：export LC_ALL=en_US.UTF-8set -euruby ${script_directory}/Test.rb上面提到 local pod 时对应的 Pod 库目录会不同，所以提供了 ${script_directory} 变量，通过 ${script_directory} 不管是否为 local pod 都可以访问到对应的 Git hooks 的 script 目录。相关插件地址：GitHub - dirtmelon/cocoapods-sync-githooksDemo 地址：GitHub - dirtmelon/githooksAGitHub - dirtmelon/githooksBGitHub - dirtmelon/SyncGithooksDemo延伸阅读： [Git Hooks Learn how to use pre-commit hooks, post-commit hooks, post-receive hooks, and more.](https://githooks.com/) Pro Git " }, { "title": "CocoaPods 学习记录 - 官方文档", "url": "/posts/cocoapods-first/", "categories": "", "tags": "CocoaPods", "date": "2021-03-13 18:12:00 +0800", "snippet": "CocoaPods 的官方文档写得比较详细，建议都过一遍，以免用错方法和漏掉一些可以提高效率的小技巧。pod install vs pod updateCocoaPods Guides - pod install vs. pod update很多人都认为只有在第一次配置 CocoaPods 时才使用 pod install ，后面都是使用 pod update ，然而事实并非如此。TL;DR: 使用 pod install 来下载新的 pods ，即使你已经有 Podfile 且之前已经执行过 pod install 。就算只是给已使用 CocoaPods 的项目添加或者移除 pods ，也是执行 pod install ； 当你想要更新 pods 至一个更新的版本时，执行 pod update [PODNAME] 。pod install ： 每次执行 pod install 来下载和安装新的 pods 时，它都会把新的 pods 对应的版本和名字写进 Podfile.lock 中，以此来锁定 pods 的版本； 当你执行执行 pod install 时，它只会解析没有 Podfile.lock 中没有出现过的 pods 依赖： 如果在 Podfile.lock 中有出现，它就会下载 Podfile.lock 中对应的版本，不去检查是否有更新的版本； 如果在 Podfile.lock 中没有出现，它就会去搜索 Podfile 中所匹配的版本，例如 pod ‘MyPod’, ‘~&amp;gt; 1.2’ 。 通过 pod outdated 可以检查是否有更新的版本。当执行 pod update PodNAME 时， CocoaPods 会尝试在匹配 Podfile 中版本条件的前提下更新至最新版本，而不是直接使用 Podfile.lock 的版本。如果说执行 pod update 时没有输入 PODNAME ，那么 CocoaPods 会更新 Podfile 中所有 pod 版本。只有在想要更新某个 pod 的版本时才使用 pod update PODNAME ，否则使用 pod install ， pod install 不会更新已经安装的 pod 。当添加一个 pod 到 Podfile 时，应该执行 pod install 而不是 pod update ，以免同时更新其它的库。把 Podfile.lock 提交到代码仓库中，以此来锁定 pod 库的版本。咋一看只使用 Podfile 应该足够获取 pod 库的精确版本了，其实不然。像是在 Podfile 中指定版本 pod ‘A’, ’1.0.0’ ，不管是 pod install 或者 pod update 都会更新其它 pod 的版本，因为它们已经在 Podfile 中指定版本了。假设有 pod A 依赖了 pod A2 ，声明在 A.podspec 中： dependency ‘A2’, ‘~&amp;gt; 3.0’ 。在这个例子中，通过 pod ‘A’, ‘1.0.0’ 可以指定所有成员都使用 pod A 的 1.0.0 版本，但是： 成员 A 可能使用的 pod A2 是 3.4 版本，因为这是 A2 的最新版本； 当用户 B 执行 pod install 时，他下载的 pod A2 库版本是 3.5 ，因为 A2 后面可能会放了一个新的版本处理。所以需要通过 Podfile.lock 来指定所有依赖库的版本，这样就可以确保所有人的依赖库版本都是一致的。团队成员之间合理使用 pod install 和 pod update 可以大大提高开发效率。Using CocoaPodsCocoaPods Guides - Using CocoaPods是否需要把 Pods 目录添加到版本管理记录中。 Cocoapods 官方推荐说不要把 Pods 目录添加到 .gitignore 中，但是就一般大型项目来说都会把 Pods 目录添加到 .gitignore 中，否则整个 Git 仓库会非常大。把 Pods 目录添加到记录中的好处： 把仓库 clone 下来后可以直接编译运行，不需要额外再下载 CocoaPods 。不需要执行 pod install 和连接网络； 即使 Pod 的源（例如 Github ）挂掉了，项目中的 Pod 库也还可以使用； Pod 库中的代码可以保证一致。忽略掉 Pods 目录的好处： 仓库会占用更小的空间； 只要 Pods 的源可用， CocoaPods 就可以执行相同的安装过程； 在执行版本管理操作比如合并不同分支时 Pods 库不会有冲突。Using a GemfileCocoaPods Guides - Using a GemfileCocoaPods 借鉴了很多版本管理工具的思想，比如说 RubyGems ， Bundler ， npm 和 Gradle 。通过 RubyGems 加 Bundler 可以给应用设置特定的环境，指定库的版本。其用法和 CocoaPods 类似，通过 Gemfile 来进行配置，然后执行 bundle install 来获取对应的库。一个 Gemfile 的写法也和 Podfile 类似：source &#39;https://rubygems.org&#39;gem &#39;cocoapods&#39;gem &#39;cocoapods-keys&#39;gem &#39;fui&#39;, &#39;~&amp;gt; 0.3.0&#39;gem &#39;xcpretty&#39;gem &#39;second_curtain&#39;, &#39;~&amp;gt; 0.2.3&#39;gem &#39;fastlane&#39;执行完 bundle install 之后， Gemfile 相关的命令都需要加上 bundle exec ，比如说 pod XX YY 需要改为 bundle exec pod XX YY 。为什么我们要使用 RVM / Bundler ？可以通过安装 rubygems-bundler 来避免每次都要输入 bundle exec ， 1.11.0 以上的 RVM 版本在安装 Ruby 时会默认安装 rubygems-Bundler ，可以通过 gem list rubygems-Bundler 来检查是否安装了这个 Gem 。Bundler Version Autoswitch如果你安装了 Bundler 2 ，那么 Bundler 会根据 Gemfile.lock 中的版本自动进行切换。如果你的 lockfile 是使用 Bundler 1 进行创建，那么就会使用 Bundler 1 运行，如果是使用 Bundler 2 创建，那么就会使用 Bundler 2 运行。例如下面的 Gemfile.lock 是使用 Bundler 1.17.1 创建：GEM remote: https://rubygems.org/ specs: rack (2.0.6)PLATFORMS rubyDEPENDENCIES rackBUNDLED WITH 1.17.1Bundler 会读取 BUNDLED WITH 的区域来决定使用哪个版本，运行以下命令可以查看所使用的 Bundler 版本：$ grep -A 1 &quot;BUNDLED WITH&quot; Gemfile.lockBUNDLED WITH 1.17.1$ bundle versionBundler version 1.17.1如果 Gemfile 是使用 Bundler 2 创建或者经由开发者手动从 Bundler 1 升级到 Bundler 2 ，那么就会使用 Bundler 2 版本运行：$ grep -A 1 &quot;BUNDLED WITH&quot; Gemfile.lockBUNDLED WITH 2.0.0$ bundle versionBundler version 2.0.0而在应用环境外运行时，则会使用已安装的最新版本：$ ls -a. ..$ bundle versionBundler version 2.0.0How to use CocoaPods pluginsCocoaPods Guides - How to use CocoaPods pluginsCocoaPods 不仅提供了依赖库版本管理的功能，还提供了插件功能，社区也提供了不少插件，以此来提高开发效率。CocoaPods 插件能做什么： hook 整个 install 过程，包括 install 前和 install 后； 支持设置 pod 子命令； Ruby 是门动态语言，受益于此，插件可以做任何你想做的事情。通过 Gemfile 可以安装插件，安装 cocoapods-repo-update：source &#39;https://rubygems.org&#39;gem &#39;cocoapods&#39;gem &#39;cocoapods-repo-update&#39;gem &#39;fastlane&#39;然后修改 Podfile 添加对应的插件：platform :ios, &#39;9.0&#39;plugin &#39;cocoapods-repo-update&#39;use_frameworks!# OWS Podspod &#39;SignalCoreKit&#39;, git: &#39;https://github.com/signalapp/SignalCoreKit.git&#39;, testspecs: [&quot;Tests&quot;]然后运行 bundle exec pod install 来运行插件。通过 Check 插件可以优化 CI 的时间，三方库比较多时 pod install 可以需要耗费较多的时间，为了减少这部分的时间损耗，可以通过 pod check 来判断是否需要执行 pod install ，完整命令如下：bundle exec pod check || bundle exec pod install通过 leavez/cocoapods-binary 预编译库来减少编译时间。在执行 pod install 之后，即使 Pods 没有任何改变， Xcode 仍然会重新编译所有的库。 cocoapods-binary 通过在 pod install 时期就执行预编译，生成二进制资源比如说 .framework ，然后 Xcode 直接使用二进制资源而不是源码。这个流程如下： 拉取需要预编译的 pods ； 编译这些 pods ； 修改 .podspec 文件，从指向源码改为指向编译好的 frameworks 。可以通过一下方式来指定需要使用预编译的 pods ： plugin &#39;cocoapods-binary&#39; use_frameworks! target &quot;HP&quot; do- pod &quot;ExpectoPatronum&quot;+ pod &quot;ExpectoPatronum&quot;, :binary =&amp;gt; true endPodfile 和 Podspec 语法Podfile 用于描述一个或者多个 Xcode 项目中的 targets 依赖和一些配置，Podfile 文件可以非常简单：target &#39;MyApp&#39;pod &#39;AFNetworking&#39;, &#39;~&amp;gt; 1.0&#39;也可以很复杂，一般大工程都会在 Podfile 干各种事情和 hook 操作。CocoaPods Guides - Podfile Syntax Reference 详细说明了 Podfile 的相关语法。熟悉 Podfile 语法后，可以借助 Podfile 来干不少事情，比如说添加自定义的脚本：script_phase :name =&amp;gt; &#39;HelloWorldScript&#39;, :script =&amp;gt; &#39;echo &quot;Hello World&quot;&#39;script_phase :name =&amp;gt; &#39;HelloWorldScript&#39;, :script =&amp;gt; &#39;puts &quot;Hello World&quot;&#39;, :shell_path =&amp;gt; &#39;/usr/bin/ruby&#39;使用插件：plugin &#39;cocoapods-keys&#39;, :keyring =&amp;gt; &#39;Eidolon&#39;plugin &#39;slather&#39;hook pre_install ，执行时机为 pods 完成下载但是还没安装：# installer 为 Pod::Installerpre_install do |installer| # Do something fancy!endhook post_install 用于配置生成 Xcode 项目的相关配置，或者执行其它一些任务：post_install do |installer| installer.pods_project.targets.each do |target| target.build_configurations.each do |config| config.build_settings[&#39;GCC_ENABLE_OBJC_GC&#39;] = &#39;supported&#39; end endendPodspec 文件则用于描述 pod 库的配置， source ， files ， build settings 等等，都可以进行配置。CocoaPods Guides - Podspec Syntax Reference 这里有列出 Podspec 文件支持的配置。 Podspec 可以很简单，也可以很复杂。由于 CocoaPods 在生成 pod 库对应的 Target 时是根据 Podspec 文件来生成的，所以 Xcode 的 编译属性也有支持。Podspec 在指定配置相关的文件时也支持进行格式匹配：group_file_patterns 。" }, { "title": "IGListKit - 完结篇", "url": "/posts/iglistkit-fifth/", "categories": "", "tags": "源码解析", "date": "2021-02-19 14:52:00 +0800", "snippet": "IGListCollectionViewLayoutIGListCollectionViewLayout 其实不太算得上是 IGListKIt 的内容，它主要作用是提供一个可变宽度和高度的流式布局。看下来发现这块写得太好了，从里面可以学到很多如何高效编写一个自定义的 UICollectionViewLayout 的相关技巧。IGListCollectionViewLayout 提供了一些常用的 static 的方法，用于在计算布局时根据滑动方向获取不同的属性，其中一个例子如下：static CGFloat UIEdgeInsetsLeadingInsetInDirection(UIEdgeInsets insets, UICollectionViewScrollDirection direction) { switch (direction) { case UICollectionViewScrollDirectionVertical: return insets.top; case UICollectionViewScrollDirectionHorizontal: return insets.left; }}设置 UICollectionViewLayoutAttributes 的 zIndex ，这样使得 FooterView 可以在 sticky 时不被 Cell 覆盖：static void adjustZIndexForAttributes(UICollectionViewLayoutAttributes *attributes) { const NSInteger maxZIndexPerSection = 1000; const NSInteger baseZIndex = attributes.indexPath.section * maxZIndexPerSection; switch (attributes.representedElementCategory) { case UICollectionElementCategoryCell: attributes.zIndex = baseZIndex + attributes.indexPath.item; break; case UICollectionElementCategorySupplementaryView: attributes.zIndex = baseZIndex + maxZIndexPerSection - 1; break; case UICollectionElementCategoryDecorationView: attributes.zIndex = baseZIndex - 1; break; }}这里取了个巧，假设每个 Section 的 Item 数量不超过 1000 个，每个 Section 的起始 zIndex 为 baseZIndex ，值为 attributes.indexPath.section * maxZIndexPerSection ，然后根据 attributes.representedElementCategory 进行判断： UICollectionElementCategoryCell ，baseZIndex + attributes.indexPath.item ，根据 indexPath.item 进行叠加； UICollectionElementCategorySupplementaryView ，位于每个 Section 的顶部，所以 zIndex 为 baseZIndex + maxZIndexPerSection - 1 ； UICollectionElementCategoryDecorationView 用于设置背景，所以应该位于最底部；一般来说 iOS 应该很少出现单个 Section 超过 1000 ，如果出现了而又设置 stickyHeaders 为 true ，那么就可能会出现 Cell 把 HeaderView 覆盖的情况。如何实现 stickyHeaders 功能。IGListKit 自定义了一个 UICollectionViewLayoutInvalidationContext 的子类 IGListCollectionViewLayoutInvalidationContext ，用于在布局信息失效时提供相关变量：@interface IGListCollectionViewLayoutInvalidationContext : UICollectionViewLayoutInvalidationContext@property (nonatomic, assign) BOOL ig_invalidateSupplementaryAttributes;@property (nonatomic, assign) BOOL ig_invalidateAllAttributes;@endig_invalidateSupplementaryAttributes 表示 Header 和 Footer 相关布局信息都失效，需要重新计算；ig_invalidateAllAttributes 表示所有布局信息都失效，都需要重新计算；如果需要自定义 UICollectionViewLayoutInvalidationContext ，需要重写下面的方法，返回对应的子类：+ (Class)invalidationContextClass { return [IGListCollectionViewLayoutInvalidationContext class];}当 UICollectionView 的 bounds 将要发生变化时，会调用 shouldInvalidateLayoutForBoundsChange: 方法，如果返回 YES 则会调用 invalidationContextForBoundsChange: 获取新的 IGListCollectionViewLayoutInvalidationContext 。- (BOOL)shouldInvalidateLayoutForBoundsChange:(CGRect)newBounds { const CGRect oldBounds = self.collectionView.bounds; // 如果 size 改变了， if (!CGSizeEqualToSize(oldBounds.size, newBounds.size)) { return YES; } // 2. if (CGRectGetMinInDirection(newBounds, self.scrollDirection) != CGRectGetMinInDirection(oldBounds, self.scrollDirection)) { return self.stickyHeaders; } return NO;} 如果 size 改变了， 布局肯定是会失效的，所以这里直接返回 YES ； 如果滑动方向上的坐标改变了，则返回 stickyHeaders 的值，因为当 stickyHeaders 为 YES 时，我们需要重新计算 Header 的布局；- (UICollectionViewLayoutInvalidationContext *)invalidationContextForBoundsChange:(CGRect)newBounds { const CGRect oldBounds = self.collectionView.bounds; IGListCollectionViewLayoutInvalidationContext *context = (IGListCollectionViewLayoutInvalidationContext *)[super invalidationContextForBoundsChange:newBounds]; context.ig_invalidateSupplementaryAttributes = YES; if (!CGSizeEqualToSize(oldBounds.size, newBounds.size)) { context.ig_invalidateAllAttributes = YES; } return context;}整体流程如下： 1. 创建一个自定义的 IGListCollectionViewLayoutInvalidationContext ，通过 ig_invalidateSupplementaryAttributes 来标记 supplementary attributes 失效； 2. 在 -shouldInvalidateLayoutForBoundsChange: 中返回 YES ； 3. 在 -invalidationContextForBoundsChange: 标记 IGListCollectionViewLayoutInvalidationContext 的 ig_invalidateSupplementaryAttributes 为 YES ； 4. 在 -invalidateLayoutWithContext: 方法中，如果 context 的 ig_invalidateSupplementaryAttributes 为 YES ，则清除 supplementaryAttributesCache ； 5. -layoutAttributesForSupplementaryViewOfKind:atIndexPath: 获取布局信息时，先检查 supplementaryAttributesCache 是否有对应的布局信息，如果没有，则重新生成； 6. 确保 -layoutAttributesForElementsInRect: 通过 -layoutAttributesForSupplementaryViewOfKind:atIndexPath: 获取布局信息。其它https://twitter.com/_ryannystrom/status/1344322269099810822这条推总结了 IGListKit 的开发历程。作者在 Instagram 时，产品的迭代在假期中会变慢，所以他们决定用这段时间来偿还技术债务。在 2014 年的冬季，为了从 UITableView 迁移至 UICollectionView ，作者 review 了超过 12K 行的代码。同时也去掉了对 iOS5 的支持，使得可以直接使用 iOS6 新增的 API 。通过这次重构，作者也总结了以下经验： 数据源应该统一在一处修改，否则会产生数据不一致的异常； UIView 的第一次布局可能会自动调用 reloadData ； 如果 header view 需要设置为 sticky ，即滚动时始终停留在顶部，那么就需要在滚动时进行 frame 的计算，会有性能损耗。Instagram 之前直接使用 reloadData ，大部分情况下表现都没问题，但是以下两件事情一直困扰作者： 不支持动画； 图片会闪烁，而且进行中的动画也会取消。这些都是因为 reloadData 的机制造成的，在 reloadData 时，所有显示在屏幕上的 Cell 都会进行复用。因此即使 UI 不变， Cell 仍然需要进行复用（或者初始化），重新绑定数据，设置图像等，这涉及到大量的计算和操作。以 Instagram 的点赞操作为例，当点赞某条 post 时，会调用 reloadData 。因为所有 Cell 都进行了复用，所以需要记录点赞的 Cell 所在的 row ，然后进行 reload ，再执行类型的动画。如果动画开始后某些操作又触发了 reloadData ，那么动画就会被取消，也就导致了 UI 错误。图片闪烁的问题就比较简单，当包含图片的 Cell 被复用时，会将背景设置为灰色，然后从缓存或者网络中异步获取图片，进行设置。复用和从缓存中获取/设置图片之间的异步时间差是造成闪烁的原因。作者开始思考为什么不仅仅更新有数据修改的 Cell 呢？其他框架也有类似的解决方案，不如 React ：将数据绑定到 View ，当数据更改时只是将修改的数据重新绑定到 View ，同时触发 View 的修改。按照只在一个地方更新数据源的原则，需要计算新旧数据的不同，使用 UICollectionView 的 API 来进行传入/删除/重新加载/移动，不接触其它没有改动的地方。作者研究了好几种 diff 算法： rsync ， Myers ，React ，最后选择了 Paul Heckel 的算法 https://dl.acm.org/doi/10.1145/359460.359467 ，原因如下： 计算结果与 UICollectionView 的 API 匹配：插入，删除，更新和移动； 能够理解部分的实例实现。另一个关键的决定是如何定义 identity 和 equality 。作者本来是想直接使用 NSObject 的 -hash 和 -isEqual: ，以免工程师需要编写/理解差异概念。但是 ryanolsonk 认为作者是错误的，因为 -hash 是非常复杂的算法：mikeash.com: Friday Q&amp;amp;A 2010-06-18: Implementing Equality and HashingFoundation 的 hash 有可能会产生冲突，比如 NSString ，只使用前缀/中间/后缀部分的 32 个字符来进行 hash 的计算：https://twitter.com/jaredsinclair/status/746013622095208450?lang=enobjective c - Hash value of NSDictionary - Stack OverflowNSDictionary 的 hash 计算也有问题，下面两个 NSDictionary 的 hash 值是相等的：NSDictionary *dictA = @{ @&quot;foo&quot; : @YES };NSDictionary *dictB = @{ @&quot;foo&quot; : @NO };BOOL equal = [dictA hash] == [dictB hash];NSAssert(!equal, @&quot;Assuming, that different dictionaries have different hash values.&quot;);根据 CoreFoundation 开源版本的代码： static CFHashCode __CFDictionaryHash(CFTypeRef cf) { return __CFBasicHashHash((CFBasicHashRef)cf);}__private_extern__ CFHashCode __CFBasicHashHash(CFTypeRef cf) { CFBasicHashRef ht = (CFBasicHashRef)cf; return CFBasicHashGetCount(ht);}只是简单地使用了 NSDictionary 中存储的 key-value 数量来作为 hash 值，换句话说 dictA 和 dictB 的 hash 值都是 1 。 如果想要一个更加可靠的 hash 值，那么需要自己在 Category 中提供自定义的方法。作者最后选择了 protocol 来提供 identifier 和 -isEqual: ，不使用 NSObject tricks 的解决方案，因为有可能被滥用和遗漏，从而导致崩溃。后来 jesse_squires 和作者一起重构了大约 20k 行的代码，使得可以在旧的基础上运行 IGListKit ，以此来安全地进行 AB 测试。首先是从单项的 Feed 信息流开始，然后很快就开始支持首页的信息流，而首页信息流非常复杂（这个时候开始支持在信息流中插入广告）。如果说可以替换掉信息流的实现，那么 App 的其它部分也可替换了。ocrickard 和作者一起画了几个月的时间来研究崩溃和提升性能。这段时间内，作者学到了很多 Objective-C ++ 的知识，比如说 unordered_map 比 NSDictionary 快很多。同时也发现了 UICollectionView 的一些 bug ：Issues · Instagram/IGListKit · GitHub当所有这些准备工作都完成后，开始在 App 内大范围使用。作者花了一年时间来协助工程师重构和弃用旧的实现。个人资料页的重构比较困难，作者只能自己来完成这部分的工作。当个人资料页完成后，多达 12k 行的改动。作者提到一开始他们就希望开源 IGListKit ，因此带来了大量的书面工作和内部一些政治事务。整个开发周期从 2015 年末开始，2015 年开始编写，2016 年夏季在 Feed 信息流中应用， 2017 年初替换了旧的实现。在整个过程中 Instagram 也在逐步成长，工程师团队扩大了 10 倍，用户量则是 4 倍， Instagram 开设了纽约办公室等， UICollectionView 也支持了 diffable 的数据源。可以看到由于 Instagram 项目非常庞大的关系，整个过程持续了一年半，从算法选型，实现，ABTest 到完全替换。虽然 IGListKit 是一个使用 Objective-C 编写的库，但是对 Swift 的支持非常友好，可以无痕支持 Swift 项目。作者后来去了 Github ，原推的评论区也有提到 Github iOS App 使用 IGListKit 的 Swift 版本，或许在不久的将来可以开源。顺带一提前几天大火的 ClubHouse 也有使用 IGListKit 。这里有个 UITableView 版本的 IGListKit ：UITableView 组件化 · 阿毛的蛋疼地 。" }, { "title": "IGListKit 的数据处理 - Updater&amp;Diff", "url": "/posts/iglistkit-fourth/", "categories": "", "tags": "源码解析", "date": "2021-01-02 17:30:00 +0800", "snippet": "IGListAdapterUpdater在初始化 IGListAdapter 时提供了一个 id&amp;lt;IGListUpdatingDelegate&amp;gt; updater 参数，调用者可以自己自定义一个支持 IGListUpdatingDelegate 协议的类，来实现 IGListUpdatingDelegate 的方法。 IGListAdapter 在更新 UICollectionView 和数据源时都是通过 updater 来进行操作， IGListKit 为我们提供了一个默认的 updater ： IGListAdapterUpdater ， IGListAdapter 支持 UICollectionView 的局部更新操作。// 当更新逻辑执行完成时调用的 `block` ， `finished` 表示更新是否完成。typedef void (^IGListUpdatingCompletion)(BOOL finished);// 当 `adapter` 对 `UICollectionView` 进行改动时调用， `toObjects` 表示新的 `objects`typedef void (^IGListObjectTransitionBlock)(NSArray *toObjects);// 包含所有更新的 `block` typedef void (^IGListItemUpdateBlock)(void);// `adapter` 对 `UICollectionView` 进行 `reload` 是调用typedef void (^IGListReloadUpdateBlock)(void);// 返回转换后的 `objects`typedef NSArray * _Nullable (^IGListToObjectBlock)(void);// 获取执行更新的 `UICollectionView`typedef UICollectionView * _Nullable (^IGListCollectionViewBlock)(void);// `IGListUpdatingDelegate` 用于处理 `section` 和 `row` 级别的更新，接口的实现需要对集合处理或者转发。@protocol IGListUpdatingDelegate &amp;lt;NSObject&amp;gt;// 用于在集合中寻找 `object` 。- (NSPointerFunctions *)objectLookupPointerFunctions;/*用于判断如何在 `objects` 进行转换。可以在 `objects` 直接执行 diff ， reload 每个 section ，或者直接调用 `UICollectionView` 的 `-reloadData` 方法。最后， `UICollectionView` 必须要配置好 `toObjects` 数组中对应的每个 `section` 。*/- (void)performUpdateWithCollectionViewBlock:(IGListCollectionViewBlock)collectionViewBlock fromObjects:(nullable NSArray&amp;lt;id &amp;lt;IGListDiffable&amp;gt;&amp;gt; *)fromObjects toObjectsBlock:(nullable IGListToObjectBlock)toObjectsBlock animated:(BOOL)animated objectTransitionBlock:(IGListObjectTransitionBlock)objectTransitionBlock completion:(nullable IGListUpdatingCompletion)completion;// 插入对应的 indexPaths- (void)insertItemsIntoCollectionView:(UICollectionView *)collectionView indexPaths:(NSArray &amp;lt;NSIndexPath *&amp;gt; *)indexPaths;// 删除对应的 indexPaths- (void)deleteItemsFromCollectionView:(UICollectionView *)collectionView indexPaths:(NSArray &amp;lt;NSIndexPath *&amp;gt; *)indexPaths;// 移动对应的 indexPath- (void)moveItemInCollectionView:(UICollectionView *)collectionView fromIndexPath:(NSIndexPath *)fromIndexPath toIndexPath:(NSIndexPath *)toIndexPath;// reload 对应的 fromIndexPath 和 toIndexPath- (void)reloadItemInCollectionView:(UICollectionView *)collectionView fromIndexPath:(NSIndexPath *)fromIndexPath toIndexPath:(NSIndexPath *)toIndexPath;// section 级别的处理，移动 index 对应的 section- (void)moveSectionInCollectionView:(UICollectionView *)collectionView fromIndex:(NSInteger)fromIndex toIndex:(NSInteger)toIndex;// 执行 reload data- (void)reloadDataWithCollectionViewBlock:(IGListCollectionViewBlock)collectionViewBlock reloadUpdateBlock:(IGListReloadUpdateBlock)reloadUpdateBlock completion:(nullable IGListUpdatingCompletion)completion;// reload 对应的 sections- (void)reloadCollectionView:(UICollectionView *)collectionView sections:(NSIndexSet *)sections;// 执行 `IGListItemUpdateBlock`- (void)performUpdateWithCollectionViewBlock:(IGListCollectionViewBlock)collectionViewBlock animated:(BOOL)animated itemUpdates:(IGListItemUpdateBlock)itemUpdates completion:(nullable IGListUpdatingCompletion)completion;@endIGListAdapterUpdater 内部提供了一套队列刷新机制，使用 IGListBatchUpdates 记录批量刷新的 block ：@property (nonatomic, strong, readonly) NSMutableArray&amp;lt;void (^)(void)&amp;gt; *itemUpdateBlocks;@property (nonatomic, strong, readonly) NSMutableArray&amp;lt;void (^)(BOOL)&amp;gt; *itemCompletionBlocks;批量与全局IGListAdapterUpdater 提供的方法可以分为两种：1.批量刷新，通过 diff 算法计算出需要进行操作的 Cell 或者 Section 。 IGListCollectionViewBlock 用于提供 UICollectionView ，通过 block 的方式来获取，可以保证在调用 block 时获取到 UICollectionView 是最新设置的。 IGListToObjectBlock 的作用也是一样的，保证获取的到 toObjects 是最新的：- (void)performUpdateWithCollectionViewBlock:(IGListCollectionViewBlock)collectionViewBlock fromObjects:(NSArray *)fromObjects toObjectsBlock:(IGListToObjectBlock)toObjectsBlock animated:(BOOL)animated objectTransitionBlock:(IGListObjectTransitionBlock)objectTransitionBlock completion:(IGListUpdatingCompletion)completion { self.fromObjects = self.fromObjects ?: self.pendingTransitionToObjects ?: fromObjects; self.toObjectsBlock = toObjectsBlock; self.queuedUpdateIsAnimated = self.queuedUpdateIsAnimated &amp;amp;&amp;amp; animated; self.objectTransitionBlock = objectTransitionBlock; IGListUpdatingCompletion localCompletion = completion; if (localCompletion) { [self.completionBlocks addObject:localCompletion]; } [self _queueUpdateWithCollectionViewBlock:collectionViewBlock];}self.fromObjects = self.fromObjects ?: self.pendingTransitionToObjects ?: fromObjects 和 self.queuedUpdateIsAnimated = self.queuedUpdateIsAnimated &amp;amp;&amp;amp; animated 的作用在下文会说到。2.全局刷新，作用类似于 UICollectionView 的 reloadData 方法：- (void)reloadDataWithCollectionViewBlock:(IGListCollectionViewBlock)collectionViewBlock reloadUpdateBlock:(IGListReloadUpdateBlock)reloadUpdateBlock completion:(nullable IGListUpdatingCompletion)completion { IGListUpdatingCompletion localCompletion = completion; if (localCompletion) { [self.completionBlocks addObject:localCompletion]; } self.reloadUpdates = reloadUpdateBlock; self.queuedReloadData = YES; [self _queueUpdateWithCollectionViewBlock:collectionViewBlock];}可以看到批量刷新和全局刷新的实现到最后都会调用 _queueUpdateWithCollectionViewBlock ，而在 _queueUpdateWithCollectionViewBlock 方法中会根据是否为 reloadData 来调用不同的方法：- (void)_queueUpdateWithCollectionViewBlock:(IGListCollectionViewBlock)collectionViewBlock { __weak __typeof__(self) weakSelf = self; // 这里在 `main_queue` 上使用`dispatch_async` 的原因是如果在短时间内多次调用批量刷新的方法， // 可以去掉多余的 `diff` 计算和页面刷新，只需要执行一次。 dispatch_async(dispatch_get_main_queue(), ^{ // 如果 `updater` 不是在 `IGListBatchUpdateStateIdle` 状态或者没有改变，则直接返回。 if (weakSelf.state != IGListBatchUpdateStateIdle || ![weakSelf hasChanges]) { return; } // 判断是否 hasQueuedReloadData 来调用不同的刷新方法 if (weakSelf.hasQueuedReloadData) { [weakSelf performReloadDataWithCollectionViewBlock:collectionViewBlock]; } else { [weakSelf performBatchUpdatesWithCollectionViewBlock:collectionViewBlock]; } });}在进行批量更新操作时，如果 state 是 IGListBatchUpdateStateExecutingBatchUpdateBlock ，执行批量更新 block 的状态，则直接执行 block 即可，不需要添加到 itemUpdateBlocks 中：if (self.state == IGListBatchUpdateStateExecutingBatchUpdateBlock) { itemUpdates();} else { [batchUpdates.itemUpdateBlocks addObject:itemUpdates]; self.queuedUpdateIsAnimated = self.queuedUpdateIsAnimated &amp;amp;&amp;amp; animated; [self _queueUpdateWithCollectionViewBlock:collectionViewBlock];}状态配置在看 perform 方法实现前先看下状态的相关定义，以便更好理解整体流程。typedef NS_ENUM (NSInteger, IGListBatchUpdateState) { IGListBatchUpdateStateIdle, IGListBatchUpdateStateQueuedBatchUpdate, IGListBatchUpdateStateExecutingBatchUpdateBlock, IGListBatchUpdateStateExecutedBatchUpdateBlock,}; IGListBatchUpdateStateIdle ，空闲状态，即当前无 perform 任务； IGListBatchUpdateStateQueuedBatchUpdate ，已加入到批量更新的状态中，防止内部在同一时间内多次调用 performBatchUpdatesWithCollectionViewBlock: 方法； IGListBatchUpdateStateExecutingBatchUpdateBlock 正在执行批量更新操作； IGListBatchUpdateStateExecutedBatchUpdateBlock 已经完成批量更新操作。在整个更新流程中， updater.state 会在这四种状态间切换，在不同状态间执行重复刷新操作时， updater 会因应不同的状态调用不同的方法，这块的处理是为了保证 UI 跟数据源之间的一致性和减少多余的刷新操作。在每次开始进行刷新操作前，都会记录复制一份 updater 的相关属性到本地变量中，同时会调用 cleanStateBeforeUpdates 方法清空属性，这样同时调用刷新方法也不会互相覆盖掉，彼此间的状态也不会互相影响：- (void)cleanStateBeforeUpdates { self.queuedUpdateIsAnimated = YES; self.fromObjects = nil; self.toObjectsBlock = nil; self.reloadUpdates = nil; self.queuedReloadData = NO; self.objectTransitionBlock = nil; [self.completionBlocks removeAllObjects];}updater 提供了 hasChanges 来判断是否有改动，避免多余的操作和一直执行 perform 操作：- (BOOL)hasChanges { return self.hasQueuedReloadData || [self.batchUpdates hasChanges] || self.fromObjects != nil || self.toObjectsBlock != nil;}全局刷新performReloadDataWithCollectionViewBlock 为 reloadData 时调用，不需要进行 diff 的计算，处理起来也简单一点。方法首先初始化相关本地变量，然后调用 cleanStateBeforeUpdates 方法清空属性，防止和其它刷新任务互相影响：- (void)performReloadDataWithCollectionViewBlock:(IGListCollectionViewBlock)collectionViewBlock { id&amp;lt;IGListAdapterUpdaterDelegate&amp;gt; delegate = self.delegate; void (^reloadUpdates)(void) = self.reloadUpdates; IGListBatchUpdates *batchUpdates = self.batchUpdates; NSMutableArray *completionBlocks = [self.completionBlocks mutableCopy]; [self cleanStateBeforeUpdates]; ...}设置 executeCompletionBlocks ，遍历 completionBlocks ，执行完毕后恢复 state 为 IGListBatchUpdateStateIdle ：void (^executeCompletionBlocks)(BOOL) = ^(BOOL finished) { for (IGListUpdatingCompletion block in completionBlocks) { block(finished); } self.state = IGListBatchUpdateStateIdle;};判断 collectionView 是否为 nil ，如果为 nil 则直接返回：UICollectionView *collectionView = collectionViewBlock();if (collectionView == nil) { [self _cleanStateAfterUpdates]; executeCompletionBlocks(NO); [_delegate listAdapterUpdater:self didFinishWithoutUpdatesWithCollectionView:collectionView]; return;}设置 state 为 IGListBatchUpdateStateExecutingBatchUpdateBlock ，进入执行 updateBlock 的流程，如果有设置 reloadUpdates ，则执行 reloadUpdates 。即使是在 reloadData 流程中，也需要调用所有 itemUpdateBlocks ，因为调用方有可能在 itemUpdateBlock 中对数据进行修改，必须要保证数据源和 UI 一致。把 batchUpdates.itemCompletionBlocks 添加到 completionBlocks 中，保证所有的 completionBlocks 都会被执行。最后调用定义好的 executeCompletionBlocks ：self.state = IGListBatchUpdateStateExecutingBatchUpdateBlock;if (reloadUpdates) { reloadUpdates();}for (IGListItemUpdateBlock itemUpdateBlock in batchUpdates.itemUpdateBlocks) { itemUpdateBlock();}[completionBlocks addObjectsFromArray:batchUpdates.itemCompletionBlocks];self.state = IGListBatchUpdateStateExecutedBatchUpdateBlock;[self _cleanStateAfterUpdates];[delegate listAdapterUpdater:self willReloadDataWithCollectionView:collectionView isFallbackReload:NO];[collectionView reloadData];[collectionView.collectionViewLayout invalidateLayout];[collectionView layoutIfNeeded];[delegate listAdapterUpdater:self didReloadDataWithCollectionView:collectionView isFallbackReload:NO];executeCompletionBlocks(YES);批量刷新performBatchUpdatesWithCollectionViewBlock 进行批量更新时，需要处理各个状态的边界逻辑，所以比 performReloadDataWithCollectionViewBlock 更加复杂，在代码中是个 204 行的函数，下面拆开来说下具体的实现：1.首先创建本地变量来记录所有的相关的属性，防止在执行批量更新过程中，又再次调用了 performBatchUpdatesWithCollectionViewBlock 接口，导致原有的属性被覆盖， cleanStateBeforeUpdates 会将相关属性复原，确保对更新过程中的其它 performBatchUpdatesWithCollectionViewBlock 调用没影响：- (void)performBatchUpdatesWithCollectionViewBlock:(IGListCollectionViewBlock)collectionViewBlock { id&amp;lt;IGListAdapterUpdaterDelegate&amp;gt; delegate = self.delegate; NSArray *fromObjects = [self.fromObjects copy]; IGListToObjectBlock toObjectsBlock = [self.toObjectsBlock copy]; NSMutableArray *completionBlocks = [self.completionBlocks mutableCopy]; void (^objectTransitionBlock)(NSArray *) = [self.objectTransitionBlock copy]; const BOOL animated = self.queuedUpdateIsAnimated; const BOOL allowsReloadingOnTooManyUpdates = self.allowsReloadingOnTooManyUpdates; const IGListExperiment experiments = self.experiments; IGListBatchUpdates *batchUpdates = self.batchUpdates; [self cleanStateBeforeUpdates]; }2.如果 collectionView 为 nil 就直接返回，这块的处理和 performReloadDataWithCollectionViewBlock 是一致的，通过 toObjectsBlock 来获取 toObjects ，这里使用 block 的原因是可以保证在获取 toObjects 时对应的数据源是最新的：UICollectionView *collectionView = collectionViewBlock();if (collectionView == nil) { [self _cleanStateAfterUpdates]; executeCompletionBlocks(NO); [_delegate listAdapterUpdater:self didFinishWithoutUpdatesWithCollectionView:collectionView]; return;}NSArray *toObjects = nil;if (toObjectsBlock != nil) { toObjects = objectsWithDuplicateIdentifiersRemoved(toObjectsBlock());}3.定义 executeUpdateBlocks ，首先设置 state 为 IGListBatchUpdateStateExecutingBatchUpdateBlock ，防止多次执行。然后在执行 itemUpdateBlock 前先调用 objectTransitionBlock ，使得数据源更新到最新的 toObjects ，以保证数据源跟 UI 一致。执行 itemUpdateBlock ，在 itemUpdateBlock 中处理 NSIndexPath 对应的插入，删除和刷新操作。最后把 batchUpdates.itemCompletionBlocks 添加到 completionBlocks 中：void (^executeUpdateBlocks)(void) = ^{ self.state = IGListBatchUpdateStateExecutingBatchUpdateBlock; if (objectTransitionBlock != nil) { objectTransitionBlock(toObjects); } for (IGListItemUpdateBlock itemUpdateBlock in batchUpdates.itemUpdateBlocks) { itemUpdateBlock(); } [completionBlocks addObjectsFromArray:batchUpdates.itemCompletionBlocks]; self.state = IGListBatchUpdateStateExecutedBatchUpdateBlock;};4.定义 reloadDataFallback ，如果 collectionView 所在的 window 不可见，则直接 reloadData ，跳过 diff 操作。在 reloadDataFallback 的最后，调用 _queueUpdateWithCollectionViewBlock: ，防止丢失一些批量更新过程中进行的更新操作，如果在下一个 Runloop 过程中没有更新操作， _queueUpdateWithCollectionViewBlock 会直接退出。设置 pendingTransitionToObjects 为 toObjects ，在后续的更新中 pendingTransitionToObjects 作为 fromObjects 使用：void (^reloadDataFallback)(void) = ^{ [delegate listAdapterUpdater:self willReloadDataWithCollectionView:collectionView isFallbackReload:YES]; executeUpdateBlocks(); [self _cleanStateAfterUpdates]; [self _performBatchUpdatesItemBlockApplied]; [collectionView reloadData]; [collectionView layoutIfNeeded]; executeCompletionBlocks(YES); [delegate listAdapterUpdater:self didReloadDataWithCollectionView:collectionView isFallbackReload:YES]; [self _queueUpdateWithCollectionViewBlock:collectionViewBlock];};[self _beginPerformBatchUpdatesToObjects:toObjects];if (self.allowsBackgroundReloading &amp;amp;&amp;amp; collectionView.window == nil) { reloadDataFallback(); return;}5.定义 batchUpdatesBlock ，放到 -[UICollectionView performBatchUpdates:completion:] 第一个 block 参数中，如果 singleItemSectionUpdates 为 YES ，即每个 section 中只有 1 个 item ，那么可以在 section 层面进行处理，直接调用 UICollectionView 的操作 section 的相关方法即可：void (^batchUpdatesBlock)(IGListIndexSetResult *result) = ^(IGListIndexSetResult *result){ executeUpdateBlocks(); if (self.singleItemSectionUpdates) { [collectionView deleteSections:result.deletes]; [collectionView insertSections:result.inserts]; for (IGListMoveIndex *move in result.moves) { [collectionView moveSection:move.from toSection:move.to]; } self.applyingUpdateData = [[IGListBatchUpdateData alloc] initWithInsertSections:result.inserts deleteSections:result.deletes moveSections:[NSSet setWithArray:result.moves] insertIndexPaths:@[] deleteIndexPaths:@[] updateIndexPaths:@[] moveIndexPaths:@[]]; } else { self.applyingUpdateData = IGListApplyUpdatesToCollectionView(collectionView, result, self.batchUpdates, fromObjects, experiments, self.sectionMovesAsDeletesInserts, self.preferItemReloadsForSectionReloads); } [self _cleanStateAfterUpdates]; [self _performBatchUpdatesItemBlockApplied];};6.在 IGListApplyUpdatesToCollectionView 中针对 reload 操作进行特殊处理。sectionReloads 在手动调用 reload 方法时会记录对应的 section ，合并 diff 和手动 reloads 的 section 到 reloads 中，同时如果有需要的话使用 delete + insert 代替 move ：NSMutableIndexSet *reloads = [diffResult.updates mutableCopy];[reloads addIndexes:batchUpdates.sectionReloads];NSMutableIndexSet *inserts = [diffResult.inserts mutableCopy];NSMutableIndexSet *deletes = [diffResult.deletes mutableCopy];NSMutableArray&amp;lt;NSIndexPath *&amp;gt; *itemUpdates = [NSMutableArray new];if (sectionMovesAsDeletesInserts) { for (IGListMoveIndex *move in moves) { [deletes addIndex:move.from]; [inserts addIndex:move.to]; } moves = [NSSet new];}如之前提到的在 performBatchUpdates 中 reload 是不安全的，所以只有在 moves/inserts/deletes 都为 0 时才执行 reload 操作，否则使用 delete + insert 代替：if (preferItemReloadsForSectionReloads &amp;amp;&amp;amp; moves.count == 0 &amp;amp;&amp;amp; inserts.count == 0 &amp;amp;&amp;amp; deletes.count == 0 &amp;amp;&amp;amp; reloads.count &amp;gt; 0) { [reloads enumerateIndexesUsingBlock:^(NSUInteger sectionIndex, BOOL * _Nonnull stop) { NSMutableIndexSet *localIndexSet = [NSMutableIndexSet indexSetWithIndex:sectionIndex]; if (sectionIndex &amp;lt; [collectionView numberOfSections] &amp;amp;&amp;amp; sectionIndex &amp;lt; [collectionView.dataSource numberOfSectionsInCollectionView:collectionView] &amp;amp;&amp;amp; [collectionView numberOfItemsInSection:sectionIndex] == [collectionView.dataSource collectionView:collectionView numberOfItemsInSection:sectionIndex]) { [itemUpdates addObjectsFromArray:convertSectionReloadToItemUpdates(localIndexSet, collectionView)]; } else { IGListConvertReloadToDeleteInsert(localIndexSet, deletes, inserts, diffResult, fromObjects); } }];} else { IGListConvertReloadToDeleteInsert(reloads, deletes, inserts, diffResult, fromObjects);}将 itemReloads 转换为 itemDeletes + itemInserts ，生成最后的 updateData ，collectionView 根据 updateData 对 item 进行操作， ig_applyBatchUpdateData: 内部调用对应的 delete/insert/move/reload 方法：NSMutableArray&amp;lt;NSIndexPath *&amp;gt; *itemInserts = batchUpdates.itemInserts;NSMutableArray&amp;lt;NSIndexPath *&amp;gt; *itemDeletes = batchUpdates.itemDeletes;NSMutableArray&amp;lt;IGListMoveIndexPath *&amp;gt; *itemMoves = batchUpdates.itemMoves;NSSet&amp;lt;NSIndexPath *&amp;gt; *uniqueDeletes = [NSSet setWithArray:itemDeletes];NSMutableSet&amp;lt;NSIndexPath *&amp;gt; *reloadDeletePaths = [NSMutableSet new];NSMutableSet&amp;lt;NSIndexPath *&amp;gt; *reloadInsertPaths = [NSMutableSet new];for (IGListReloadIndexPath *reload in batchUpdates.itemReloads) { if (![uniqueDeletes containsObject:reload.fromIndexPath]) { [reloadDeletePaths addObject:reload.fromIndexPath]; [reloadInsertPaths addObject:reload.toIndexPath]; }}[itemDeletes addObjectsFromArray:[reloadDeletePaths allObjects]];[itemInserts addObjectsFromArray:[reloadInsertPaths allObjects]];IGListBatchUpdateData *updateData = [[IGListBatchUpdateData alloc] initWithInsertSections:inserts deleteSections:deletes moveSections:moves insertIndexPaths:itemInserts deleteIndexPaths:itemDeletes updateIndexPaths:itemUpdates moveIndexPaths:itemMoves];[collectionView ig_applyBatchUpdateData:updateData];return updateData;7.设置 fallbackWithoutUpdates ，在 collectionView.dataSource 为 nil 时调用：void (^fallbackWithoutUpdates)(void) = ^(void) { executeCompletionBlocks(NO); [delegate listAdapterUpdater:self didFinishWithoutUpdatesWithCollectionView:collectionView]; [self _queueUpdateWithCollectionViewBlock:collectionViewBlock];};8.设置 batchUpdatesCompletionBlock ，放到 -[UICollectionView performBatchUpdates:completion:] 第二个 block 参数中：void (^batchUpdatesCompletionBlock)(BOOL) = ^(BOOL finished) { IGListBatchUpdateData *oldApplyingUpdateData = self.applyingUpdateData; executeCompletionBlocks(finished); [delegate listAdapterUpdater:self didPerformBatchUpdates:oldApplyingUpdateData collectionView:collectionView]; [self _queueUpdateWithCollectionViewBlock:collectionViewBlock];};9.把 [UICollectionView performBatchUpdates 封装起来，如果在 batchUpdatesBlock 处理时崩溃的了，显示出来的第一行 App 符号就不是 block 了。 block 生成的名字会包含行数，如果行数调整了，就会被标记为不同的崩溃，这会对崩溃记录造成影响：void (^performUpdate)(IGListIndexSetResult *) = ^(IGListIndexSetResult *result){ [delegate listAdapterUpdater:selfwillPerformBatchUpdatesWithCollectionView:collectionView fromObjects:fromObjects toObjects:toObjects listIndexSetResult:result animated:animated]; IGListAdapterUpdaterPerformBatchUpdate(collectionView, animated, ^{ batchUpdatesBlock(result); }, batchUpdatesCompletionBlock);};10.初始化 tryToPerformUpdate ， tryToPerformUpdate 会把之前设置好的 block ，设置一个 try-catch ，防止崩溃，根据边界情况判断是否需要 fallback ：void (^tryToPerformUpdate)(IGListIndexSetResult *) = ^(IGListIndexSetResult *result){ if (!IGListExperimentEnabled(experiments, IGListExperimentSkipLayoutBeforeUpdate)) { [collectionView layoutIfNeeded]; } @try { if (collectionView.dataSource == nil) { fallbackWithoutUpdates(); } else if (result.changeCount &amp;gt; 100 &amp;amp;&amp;amp; allowsReloadingOnTooManyUpdates) { reloadDataFallback(); } else { performUpdate(result); } } @catch (NSException *exception) { [delegate listAdapterUpdater:self collectionView:collectionView willCrashWithException:exception fromObjects:fromObjects toObjects:toObjects diffResult:result updates:(id)self.applyingUpdateData]; @throw exception; }};11.最后通过 diff 算法计算出 IGListIndexSetResult ，调用 tryToPerformUpdate(result) ：const BOOL onBackgroundThread = IGListExperimentEnabled(experiments, IGListExperimentBackgroundDiffing);[delegate listAdapterUpdater:self willDiffFromObjects:fromObjects toObjects:toObjects];IGListAdapterUpdaterPerformDiffing(fromObjects, toObjects, IGListDiffEquality, experiments, onBackgroundThread, ^(IGListIndexSetResult *result){ [delegate listAdapterUpdater:self didDiffWithResults:result onBackgroundThread:onBackgroundThread]; tryToPerformUpdate(result);});调用顺序如下：// 使用 fromObjects 和 toObjects 计算出 diffIGListAdapterUpdaterPerformDiffing -&amp;gt; // 判断是否需要执行更新，tryToPerformUpdate -&amp;gt;// 执行更新performUpdate -&amp;gt; // 调用 `UICollectionView` 的 `performBatchUpdates` 方法IGListAdapterUpdaterPerformBatchUpdate -&amp;gt; // batchUpdatesBlock 中执行 executeUpdateBlocksbatchUpdatesBlock -&amp;gt; // 执行 UICollectionView section 和 items 的相关操作[UICollectionView section 和 items 操作]完成刷新后调用相关的 block ：batchUpdatesCompletionBlock -&amp;gt; executeCompletionBlocks IGListReloadDataUpdater除了支持批量刷新的 IGListAdapterUpdater ，IGListKit 还提供了仅支持全局刷新的 IGListReloadDataUpdater ，实现非常简单，且执行的是 [UICollectionView reloadData] 。其所有 IGListUpdatingDelegate 的相关方法都会调用 _synchronousReloadDataWithCollectionView: 方法进行更新：- (void)performUpdateWithCollectionViewBlock:(IGListCollectionViewBlock)collectionViewBlock fromObjects:(NSArray *)fromObjects toObjectsBlock:(IGListToObjectBlock)toObjectsBlock animated:(BOOL)animated objectTransitionBlock:(IGListObjectTransitionBlock)objectTransitionBlock completion:(IGListUpdatingCompletion)completion { if (toObjectsBlock != nil) { NSArray *toObjects = toObjectsBlock() ?: @[]; objectTransitionBlock(toObjects); } [self _synchronousReloadDataWithCollectionView:collectionViewBlock()]; if (completion) { completion(YES); }}- (void)_synchronousReloadDataWithCollectionView:(UICollectionView *)collectionView { [collectionView reloadData]; [collectionView layoutIfNeeded];}可以看到实现非常简单，如果只需要进行 reloadData ，可以使用 IGListReloadDataUpdater 替换掉 IGListAdapterUpdater 。Diff在 iOS 还没有系统级地支持 Diff 特性的年代，在使用 UITableView/UICollectionView 时，当数据源发生变化，我们就需要手动根据数据源计算出变化的 NSIndexPaths 并进行更新，这个方法的时间复杂度一般是 O(n^2) ，在遍历旧数据内对新数据进行遍历，或者说直接 reloadData ，在 UITableView/UICollectionView 的复用机制下，只需要重新生成显示在屏幕的 Cell ，所带来的影响只是丢失了动画。而 IGListKit 的 IGListDiff 可以在时间复杂度 O(n) 的前提下为我们计算出对应的 NSIndexPaths 简单易易用，再也不需要直接 reloadData 。下面来说说 IGListDiff 的核心实现。/// 记录 Diff 所需要的状态struct IGListEntry { /// 记录旧数组中具有相同 hash 值的对象出现次数 NSInteger oldCounter = 0; /// 记录新数组中具有相同 hash 值的对象出现次数 NSInteger newCounter = 0; /// The indexes of the data in the old array /// 记录旧数组中当前 hash 对应的对象出现的位置 stack&amp;lt;NSInteger&amp;gt; oldIndexes; /// 数据是否有更新 BOOL updated = NO;};/// 记录 IGListEntry 和位置（ index ）， index 默认为 NSNotFoundstruct IGListRecord { IGListEntry *entry; mutable NSInteger index; IGListRecord() { entry = NULL; index = NSNotFound; }};1.首先先获取新旧数据所对应的数量： newCount 和 oldCount ，然后创建新旧数据所对应的 NSMapTable ：static id IGListDiffing(BOOL returnIndexPaths, NSInteger fromSection, NSInteger toSection, NSArray&amp;lt;id&amp;lt;IGListDiffable&amp;gt;&amp;gt; *oldArray, NSArray&amp;lt;id&amp;lt;IGListDiffable&amp;gt;&amp;gt; *newArray, IGListDiffOption option) { const NSInteger newCount = newArray.count; const NSInteger oldCount = oldArray.count; NSMapTable *oldMap = [NSMapTable strongToStrongObjectsMapTable]; NSMapTable *newMap = [NSMapTable strongToStrongObjectsMapTable];2.如果 newCount 为 0 ，那么就是说 oldArray 的所有数据都需要进行删除，那么我们可以尽早返回，生成一个删除所有数据的 IGListIndexPathResult/IGListIndexSetResult ：if (newCount == 0) { if (returnIndexPaths) { return [[IGListIndexPathResult alloc] initWithInserts:[NSArray new] deletes:indexPathsAndPopulateMap(oldArray, fromSection, oldMap) updates:[NSArray new] moves:[NSArray new] oldIndexPathMap:oldMap newIndexPathMap:newMap]; } else { [oldArray enumerateObjectsUsingBlock:^(id&amp;lt;IGListDiffable&amp;gt; obj, NSUInteger idx, BOOL *stop) { addIndexToMap(returnIndexPaths, fromSection, idx, obj, oldMap); }]; return [[IGListIndexSetResult alloc] initWithInserts:[NSIndexSet new] deletes:[NSIndexSet indexSetWithIndexesInRange:NSMakeRange(0, oldCount)] updates:[NSIndexSet new] moves:[NSArray new] oldIndexMap:oldMap newIndexMap:newMap]; }}3.如果 oldCount 为 0 ，那么就是说 newArray 的所有数据都需要进行插入，那么我们可以尽早返回，生成一个插入所有数据的 IGListIndexPathResult/IGListIndexSetResult ：if (oldCount == 0) { if (returnIndexPaths) { return [[IGListIndexPathResult alloc] initWithInserts:indexPathsAndPopulateMap(newArray, toSection, newMap) deletes:[NSArray new] updates:[NSArray new] moves:[NSArray new] oldIndexPathMap:oldMap newIndexPathMap:newMap]; } else { [newArray enumerateObjectsUsingBlock:^(id&amp;lt;IGListDiffable&amp;gt; obj, NSUInteger idx, BOOL *stop) { addIndexToMap(returnIndexPaths, toSection, idx, obj, newMap); }]; return [[IGListIndexSetResult alloc] initWithInserts:[NSIndexSet indexSetWithIndexesInRange:NSMakeRange(0, newCount)] deletes:[NSIndexSet new] updates:[NSIndexSet new] moves:[NSArray new] oldIndexMap:oldMap newIndexMap:newMap]; }}4.如果 newCount 和 oldCount 都不为 0 ，那么就可以进行 Diff 计算，首先需要创建一个 table ，使用 diffIdentifier 为 key ， IGListEntry 为 value ，这里使用 unordered_map ，因为会比 NSDictionary 快很多。unordered_map&amp;lt;id&amp;lt;NSObject&amp;gt;, IGListEntry, IGListHashID, IGListEqualID&amp;gt; table;5.遍历 newArray 的数据，获取对应的 entry ， entry 的 oldIndexes 插入 NSNotFound ，且设置到 newResultsArray 中：vector&amp;lt;IGListRecord&amp;gt; newResultsArray(newCount);for (NSInteger i = 0; i &amp;lt; newCount; i++) { id&amp;lt;NSObject&amp;gt; key = IGListTableKey(newArray[i]); IGListEntry &amp;amp;entry = table[key]; entry.newCounter++; entry.oldIndexes.push(NSNotFound); newResultsArray[i].entry = &amp;amp;entry;}6.遍历 oldArray 的数据，获取对应的 entry ， entry 的 oldIndexes 插入对应的位置 i ，且设置到 oldResultsArray 中：vector&amp;lt;IGListRecord&amp;gt; oldResultsArray(oldCount);for (NSInteger i = oldCount - 1; i &amp;gt;= 0; i--) { id&amp;lt;NSObject&amp;gt; key = IGListTableKey(oldArray[i]); IGListEntry &amp;amp;entry = table[key]; entry.oldCounter++; entry.oldIndexes.push(i); oldResultsArray[i].entry = &amp;amp;entry;}7.处理那些在 oldArray 和 newArray 中都有出现的数据，遍历 newResultsArray ，根据 entry 的数据进行对比：for (NSInteger i = 0; i &amp;lt; newCount; i++) { IGListEntry *entry = newResultsArray[i].entry; // 1. 获取原始位置 originalIndex , 如果 item 是插入的数据，那么 originalIndex 就为 NSNotFound const NSInteger originalIndex = entry-&amp;gt;oldIndexes.top(); entry-&amp;gt;oldIndexes.pop(); if (originalIndex &amp;lt; oldCount) { // 获取新旧数据的对象 const id&amp;lt;IGListDiffable&amp;gt; n = newArray[i]; const id&amp;lt;IGListDiffable&amp;gt; o = oldArray[originalIndex]; switch (option) { case IGListDiffPointerPersonality: // 只通过指针进行比较 if (n != o) { entry-&amp;gt;updated = YES; } break; case IGListDiffEquality: // 使用 `-[IGListDiffable isEqualToDiffableObject:]` 进行比较，以 n 和 o 指向的对象不同为前提 if (n != o &amp;amp;&amp;amp; ![n isEqualToDiffableObject:o]) { entry-&amp;gt;updated = YES; } break; } } if (originalIndex != NSNotFound &amp;amp;&amp;amp; entry-&amp;gt;newCounter &amp;gt; 0 &amp;amp;&amp;amp; entry-&amp;gt;oldCounter &amp;gt; 0) { // 如果在 `newArray` 和 `oldArray` 中都出现，则进行位置的双向绑定 newResultsArray[i].index = originalIndex; oldResultsArray[originalIndex].index = i; }}8.创建需要记录数据：// 存储最后的 NSIndexPaths 或者 indexesid mInserts, mMoves, mUpdates, mDeletes;if (returnIndexPaths) { mInserts = [NSMutableArray&amp;lt;NSIndexPath *&amp;gt; new]; mMoves = [NSMutableArray&amp;lt;IGListMoveIndexPath *&amp;gt; new]; mUpdates = [NSMutableArray&amp;lt;NSIndexPath *&amp;gt; new]; mDeletes = [NSMutableArray&amp;lt;NSIndexPath *&amp;gt; new];} else { mInserts = [NSMutableIndexSet new]; mMoves = [NSMutableArray&amp;lt;IGListMoveIndex *&amp;gt; new]; mUpdates = [NSMutableIndexSet new]; mDeletes = [NSMutableIndexSet new];}// 追踪删除的 items 的偏移量来计算 items 的移动位置vector&amp;lt;NSInteger&amp;gt; deleteOffsets(oldCount), insertOffsets(newCount);NSInteger runningOffset = 0;9.计算删除的数据：for (NSInteger i = 0; i &amp;lt; oldCount; i++) { deleteOffsets[i] = runningOffset; const IGListRecord record = oldResultsArray[i]; // 如果 `record.index` 为 `NSNotFound` ，则表示其没有在 `newArray` 中出现，已被删除 if (record.index == NSNotFound) { addIndexToCollection(returnIndexPaths, mDeletes, fromSection, i); runningOffset++; } addIndexToMap(returnIndexPaths, fromSection, i, oldArray[i], oldMap);}11.最后的计算for (NSInteger i = 0; i &amp;lt; newCount; i++) { insertOffsets[i] = runningOffset; const IGListRecord record = newResultsArray[i]; const NSInteger oldIndex = record.index; // 如果 `record.index` 为 `NSNotFound` ，则表示其没有在 `oldArray` 中出现，是新插入的 if (record.index == NSNotFound) { addIndexToCollection(returnIndexPaths, mInserts, toSection, i); runningOffset++; } else { // 如果 record.entry-&amp;gt; updated 为 YES ，则表示 if (record.entry-&amp;gt;updated) { addIndexToCollection(returnIndexPaths, mUpdates, fromSection, oldIndex); } // 计算 indexes 是否匹配，据此来判断是否需要移动 // oldIndex - deleteOffset + insertOffset != i ，则位置发生变化，需要移动。 const NSInteger insertOffset = insertOffsets[i]; const NSInteger deleteOffset = deleteOffsets[oldIndex]; if ((oldIndex - deleteOffset + insertOffset) != i) { id move; if (returnIndexPaths) { NSIndexPath *from = [NSIndexPath indexPathForItem:oldIndex inSection:fromSection]; NSIndexPath *to = [NSIndexPath indexPathForItem:i inSection:toSection]; move = [[IGListMoveIndexPath alloc] initWithFrom:from to:to]; } else { move = [[IGListMoveIndex alloc] initWithFrom:oldIndex to:i]; } [mMoves addObject:move]; } } addIndexToMap(returnIndexPaths, toSection, i, newArray[i], newMap);}12.完成计算，返回结果：if (returnIndexPaths) { return [[IGListIndexPathResult alloc] initWithInserts:mInserts deletes:mDeletes updates:mUpdates moves:mMoves oldIndexPathMap:oldMap newIndexPathMap:newMap];} else { return [[IGListIndexSetResult alloc] initWithInserts:mInserts deletes:mDeletes updates:mUpdates moves:mMoves oldIndexMap:oldMap newIndexMap:newMap];}从上面的计算可以看出需要 5 次 for 循环进行遍历，也就是时间复杂度为 O(5n) ，在 n 足够大的情况下可以忽略，时间复杂度可视作 O(n) 。这篇文章有使用两个数组作为例子进行说明 IGListDiff 是如何进行计算的： IGListKit diff 实现简析 。" }, { "title": "IGListKit 的管理者 - IGListAdapter", "url": "/posts/iglistkit-third/", "categories": "", "tags": "源码解析", "date": "2020-12-27 13:53:00 +0800", "snippet": "初始化IGListAdapter 负责处理 UICollectionView 的 DataSource 和 Delegate ，所有 DataSource/Delegate 的相关方法都会在 IGListAdapter 内部消化完毕，调用方只需要设置 IGListAdapter 的 dataSource 和 collectionView 即可， IGListAdapterDataSource 则负责给 IGListAdapter 提供数据源：@protocol IGListAdapterDataSource &amp;lt;NSObject&amp;gt;/// 根据不同的 adapter 返回需要展示在列表中的数据，一般情况下每个 UIViewController 只有一个 adapter- (NSArray&amp;lt;id &amp;lt;IGListDiffable&amp;gt;&amp;gt; *)objectsForListAdapter:(IGListAdapter *)listAdapter;/// 根据数据来返回新生成的对应的 IGListSectionController/// IGListSectionController 应该在这里进行初始化，你也可以在这里传递其它数据给 IGListSectionController 。/// 当 IGListAdapter 被创建，更新或者重新加载（ reloaded ）时，会初始化所有数据对应的 IGListSectionController 。 /// IGListSectionController 会进行复用，可以通过 `-[IGListDiffable diffIdentifier]` 来阻止。- (IGListSectionController *)listAdapter:(IGListAdapter *)listAdapter sectionControllerForObject:(id)object;/// 当 UICollectionView 数据为空时就会显示这个方法返回的 UIView ，如果不想显示，可以直接返回 `nil` 。- (nullable UIView *)emptyViewForListAdapter:(IGListAdapter *)listAdapter;@endIGListAdapterDataSource 作用和 UICollectionViewDataSource 类似，只不过设置对象变成了 IGListAdapterDataSource ，而且只需要提供数据源和 IGListSectionController 即可，不需要进行其它配置。下面来看下 IGListAdapter 的初始化方法：- (instancetype)initWithUpdater:(id &amp;lt;IGListUpdatingDelegate&amp;gt;)updater viewController:(UIViewController *)viewController workingRangeSize:(NSInteger)workingRangeSize { IGAssertMainThread(); IGParameterAssert(updater); if (self = [super init]) { // 1. 使用了 `NSMapTable` 而不是 `NSDictionary` ，因为这里的 `key` 是 `id&amp;lt;IGListDiffable&amp;gt;` 对象，不支持 `NSCopying` 协议， // 所以使用 `NSMapTable` ，通过 `id &amp;lt;IGListUpdatingDelegate&amp;gt;` 的 `objectLookupPointerFunctions` 方法来自定义 `hashFunction` 和 `isEqualFunction` ： NSPointerFunctions *keyFunctions = [updater objectLookupPointerFunctions]; NSPointerFunctions *valueFunctions = [NSPointerFunctions pointerFunctionsWithOptions:NSPointerFunctionsStrongMemory]; NSMapTable *table = [[NSMapTable alloc] initWithKeyPointerFunctions:keyFunctions valuePointerFunctions:valueFunctions capacity:0]; _sectionMap = [[IGListSectionMap alloc] initWithMapTable:table]; // 2. `IGListDisplayHandler` ，提供 `UICollectionViewCell` 和 `UICollectionReusableView` 显示/隐藏相关的生命周期方法，内部调用 `IGListSectionController` 对应的方法 _displayHandler = [IGListDisplayHandler new]; // 3. `IGListWorkingRangeHandler` ，通过设置 `workingRangeSize` ，可以在 `UICollectionView` 滑动时做一些预处理工作 _workingRangeHandler = [[IGListWorkingRangeHandler alloc] initWithWorkingRangeSize:workingRangeSize]; // 4. `NSHashTable&amp;lt;id&amp;lt;IGListAdapterUpdateListener&amp;gt;&amp;gt; *_updateListeners` ，在 `UICollectionView` 完成更新操作后调用 _updateListeners = [NSHashTable weakObjectsHashTable]; // 5. `NSMapTable&amp;lt;UICollectionReusableView *, IGListSectionController *&amp;gt; *_viewSectionControllerMap` ， // 维护 `sectionController` 和 `UICollectionReusableView` 映射关系。 _viewSectionControllerMap = [NSMapTable mapTableWithKeyOptions:NSMapTableObjectPointerPersonality | NSMapTableStrongMemory valueOptions:NSMapTableStrongMemory]; _updater = updater; _viewController = viewController; [IGListDebugger trackAdapter:self]; } return self;}objectLookupPointerFunctions 的自定义 hashFunction 和 isEqualFunction ，由于 object 已经有了 -diffIdentifier ，所以可以基于这个方法进行判断：static BOOL IGListIsEqual(const void *a, const void *b, NSUInteger (*size)(const void *item)) { const id&amp;lt;IGListDiffable, NSObject&amp;gt; left = (__bridge id&amp;lt;IGListDiffable, NSObject&amp;gt;)a; const id&amp;lt;IGListDiffable, NSObject&amp;gt; right = (__bridge id&amp;lt;IGListDiffable, NSObject&amp;gt;)b; return [left class] == [right class] &amp;amp;&amp;amp; [[left diffIdentifier] isEqual:[right diffIdentifier]];}// 因为 diff 算法是基于 `-diffIdentifier` 进行计算，所以我们的映射表需要精确匹配这种行为static NSUInteger IGListIdentifierHash(const void *item, NSUInteger (*size)(const void *item)) { return [[(__bridge id&amp;lt;IGListDiffable&amp;gt;)item diffIdentifier] hash];}- (NSPointerFunctions *)objectLookupPointerFunctions { NSPointerFunctions *functions = [NSPointerFunctions pointerFunctionsWithOptions:NSPointerFunctionsStrongMemory]; functions.hashFunction = IGListIdentifierHash; functions.isEqualFunction = IGListIsEqual; return functions;}IGListAdapter 作为 IGListKit 的中心调度器，负责串联起 IGListSectionController ， Model ， UICollectionView 和 UICollectionReusableView 之间的关系，在设置 UICollectionView 时， IGListAdapter 就会进行对应的处理：- (void)setCollectionView:(UICollectionView *)collectionView { IGAssertMainThread(); // 1. 如果在 `Cell` 中设置 `UICollectionView` 时有可能会多次设置 `IGListAdapter` 的 `colleciontView` ，这里做一下判断，防止重复设置； if (_collectionView != collectionView || _collectionView.dataSource != self) { // 2. 每次关联 `UICollectionView` 和 `IGListAdapter` ，都需要清空之前的关联， // 防止旧的 `IGListAdapter` 对 `UICollectionView` 进行更新， // 相关的 PR 在这里 [Prevent stale adapter:collectionView corruptions](https://github.com/Instagram/IGListKit/pull/517) // 当在 `Cell` 中进行设置时： `adapter.collectionView = cell.collectionView` ， // 有可能会有多个 `adapter` 链接到同一个 `collectionView` ， // 那么就可能会发生旧的 `adapter` 对当前 `UICollectionView` 进行修改的 bug ， // 所以这里需要对之前的 `adapter` 设置 `collectionView` 为 `nil` ； static NSMapTable&amp;lt;UICollectionView *, IGListAdapter *&amp;gt; *globalCollectionViewAdapterMap = nil; if (globalCollectionViewAdapterMap == nil) { globalCollectionViewAdapterMap = [NSMapTable weakToWeakObjectsMapTable]; } [globalCollectionViewAdapterMap removeObjectForKey:_collectionView]; [[globalCollectionViewAdapterMap objectForKey:collectionView] setCollectionView:nil]; [globalCollectionViewAdapterMap setObject:self forKey:collectionView]; // 3. 清空已注册的 `Cell` ， `Nib` 等； _registeredCellIdentifiers = [NSMutableSet new]; _registeredNibNames = [NSMutableSet new]; _registeredSupplementaryViewIdentifiers = [NSMutableSet new]; _registeredSupplementaryViewNibNames = [NSMutableSet new]; const BOOL settingFirstCollectionView = _collectionView == nil; _collectionView = collectionView; _collectionView.dataSource = self; if (@available(iOS 10.0, tvOS 10, *)) { _collectionView.prefetchingEnabled = NO; } [_collectionView.collectionViewLayout ig_hijackLayoutInteractiveReorderingMethodForAdapter:self]; [_collectionView.collectionViewLayout invalidateLayout]; // 4. 设置 `collectionView` 的 `delegate` ； [self _updateCollectionViewDelegate]; // 5. 如果是第一次设置 `collectionView` 则需要进行一些设置。 if (settingFirstCollectionView) { [self _updateAfterPublicSettingsChange]; } }}_updateAfterPublicSettingsChange 首先调用 NSArray *objectsWithDuplicateIdentifiersRemoved(NSArray&amp;lt;id&amp;lt;IGListDiffable&amp;gt;&amp;gt; *objects) 去除重复的 Objects ：- (void)_updateAfterPublicSettingsChange { id&amp;lt;IGListAdapterDataSource&amp;gt; dataSource = _dataSource; if (_collectionView != nil &amp;amp;&amp;amp; dataSource != nil) { NSArray *uniqueObjects = objectsWithDuplicateIdentifiersRemoved([dataSource objectsForListAdapter:self]); [self _updateObjects:uniqueObjects dataSource:dataSource]; }}IGListKit 不支持 Object 间有相同的 diffIdentifier ，所以需要进行过滤，使用 NSMapTable 来进行记录，以 diffIdentifier 为 key 进行记录，如果 identifierMap 有记录，则不添加到 uniqueObjects 中：static NSArray *objectsWithDuplicateIdentifiersRemoved(NSArray&amp;lt;id&amp;lt;IGListDiffable&amp;gt;&amp;gt; *objects) { if (objects == nil) { return nil; } NSMapTable *identifierMap = [NSMapTable strongToStrongObjectsMapTable]; NSMutableArray *uniqueObjects = [NSMutableArray new]; for (id&amp;lt;IGListDiffable&amp;gt; object in objects) { id diffIdentifier = [object diffIdentifier]; id previousObject = [identifierMap objectForKey:diffIdentifier]; if (diffIdentifier != nil &amp;amp;&amp;amp; previousObject == nil) { [identifierMap setObject:object forKey:diffIdentifier]; [uniqueObjects addObject:object]; } else { IGLKLog(@&quot;Duplicate identifier %@ for object %@ with object %@&quot;, diffIdentifier, object, previousObject); } } return uniqueObjects;}去除重复的 Model 后，再调用 _updateObjects: dataSource: 获取对应的 IGListSectionController ，并将 IGListSectionController 和 Object 串联起来：- (void)_updateObjects:(NSArray *)objects dataSource:(id&amp;lt;IGListAdapterDataSource&amp;gt;)dataSource { // 1. 状态标记，防止在更新数据源过程中刷新 `collectionView` _isInObjectUpdateTransaction = YES; // 2. 更新数据源过程中所需要用到的数据组合 NSMutableArray&amp;lt;IGListSectionController *&amp;gt; *sectionControllers = [NSMutableArray new]; NSMutableArray *validObjects = [NSMutableArray new]; IGListSectionMap *map = self.sectionMap; NSMutableSet *updatedObjects = [NSMutableSet new]; // 3. 把当前的 `viewController` 和 `adapter` 存储到 `local thread dictionary` 中，以便在初始化 `IGListSectionController` 时使用 IGListSectionControllerPushThread(self.viewController, self); for (id object in objects) { // 4. 从 `map` 中获取对应的 `IGListSectionController` ，如果没有，则从 `dataSource` 生成的新的 IGListSectionController *sectionController = [map sectionControllerForObject:object]; if (sectionController == nil) { sectionController = [dataSource listAdapter:self sectionControllerForObject:object]; } if (sectionController == nil) { IGLKLog(@&quot;WARNING: Ignoring nil section controller returned by data source %@ for object %@.&quot;, dataSource, object); continue; } // 5. 设置 `sectionController` 的 `collectionContext` 和 `viewController` ， // 防止 `sectioncontroller` 不是在 `-listAdapter:sectionControllerForObject:` 方法中创建的， // 导致 `collectionContext` 和 `viewController` 没有更新 sectionController.collectionContext = self; sectionController.viewController = self.viewController; // 6. 如果找不到 `oldSection` ，则表示 `object` 是新增加的。如果新旧 `object` 不相等，则说明 `object` 有更新 const NSInteger oldSection = [map sectionForObject:object]; if (oldSection == NSNotFound || [map objectForSection:oldSection] != object) { [updatedObjects addObject:object]; } [sectionControllers addObject:sectionController]; [validObjects addObject:object]; } // 7. 清除 `local thread dictionary` 的数据 IGListSectionControllerPopThread(); // 9. 更新 `validObjects` 和 `sectionControllers` 的绑定关系 [map updateWithObjects:validObjects sectionControllers:sectionControllers]; // 10. 所有 `sectionControllers` 都已经加载完成，进行 `object` 更新工作 for (id object in updatedObjects) { [[map sectionControllerForObject:object] didUpdateToObject:object]; } [self _updateBackgroundViewShouldHide:![self _itemCountIsZero]]; _isInObjectUpdateTransaction = NO;}至此，使用 IGListKit 的初始化流程已完成。更新数据IGListKit 在数据更新时刷新界面的流程和普通的 UICollectionView 使用方式类似，首先是根据用户操作/网络请求等对数据进行调整，然后调用 reloadData/performUpdates 刷新 UICollectionView ，但是与系统的 UICollectionView 不同，我们不再需要手动去计算哪些 Cell 进行了刷新/删除/插入/移动和进行相关操作， IGListKit 会自动帮我们完成这件事，我们所需要做的只是更新数据，然后调用 IGListAdapter 的对应方法即可。而 IGListAdapter 提供了三种刷新方式，下面具体展开说说。performUpdatesAnimated:completion:performUpdatesAnimated:completion: ，等价于 UICollectionView 的 performBatchUpdates:completion: 方法，当数据源更新后，可以调用这个方法来进行局部刷新， IGListAdapter 内部会计算出新增/删除/更新的 Object 所对应的 Section 和位置，调用 UICollectionView 对应的方法。- (void)performUpdatesAnimated:(BOOL)animated completion:(IGListUpdaterCompletion)completion { id&amp;lt;IGListAdapterDataSource&amp;gt; dataSource = self.dataSource; UICollectionView *collectionView = self.collectionView; // 1. 如果 `dataSource` 或者 `collectionView` 为 `nil` ，直接返回，调用 `completion(NO)` if (dataSource == nil || collectionView == nil) { if (completion) { completion(NO); } return; } // 2. 获取旧的 `objects` ，定义如何获取新的 `objects` 的 `block` ， // 延迟执行 `dataSource` 的 `objectsForListAdapter:` 方法，等到需要时再执行，保证获取到的 `objects` 是最新的 NSArray *fromObjects = self.sectionMap.objects; __weak __typeof__(self) weakSelf = self; IGListToObjectBlock toObjectsBlock = ^NSArray *{ __typeof__(self) strongSelf = weakSelf; if (strongSelf == nil) { return nil; } return [dataSource objectsForListAdapter:strongSelf]; }; // 3. 这里在局部刷新布局信息时会用到，标记一下进入局部刷新流程 [self _enterBatchUpdates]; // 4. 调用 `id &amp;lt;IGListUpdatingDelegate&amp;gt; updater` 对应的方法更新 `collectionView` ， // 通过 `_collectionViewBlock ` 来获取 `collectionView` 延迟到真正更新时才执行 block，确保获取到的 `collectionView` 是正确的 [self.updater performUpdateWithCollectionViewBlock:[self _collectionViewBlock] fromObjects:fromObjects toObjectsBlock:toObjectsBlock animated:animated objectTransitionBlock:^(NSArray *toObjects) { // 5. 这里的 `toObjects` 是由 `update` 进行计算后得出的新的数据源，设置 `previousSectionMap` ，更新数据源 weakSelf.previousSectionMap = [weakSelf.sectionMap copy]; [weakSelf _updateObjects:toObjects dataSource:dataSource]; } completion:^(BOOL finished) { // 6. 完成刷新，复原标记 weakSelf.previousSectionMap = nil; [weakSelf _notifyDidUpdate:IGListAdapterUpdateTypePerformUpdates animated:animated]; if (completion) { completion(finished); } [weakSelf _exitBatchUpdates]; }];}reloadDataWithCompletion:reloadDataWithCompletion: 全局刷新，作用跟 UICollectionView 的 reloadData 方法类似，会移除掉所有旧的 objects 和 IGListSectionController ，需要注意的是会重新生成所有 IGListSectionController ，所以是个有可能非常耗时的操作，在调用这个方法前必须清楚知道这一前提，一般情况下推荐使用 performUpdatesAnimated:completion: 来进行刷新。reloadData 的实现比 performUpdates 的要简单很多，只需要调用 update 对应的方法，清空 sectionMap ，更新 objects 即可。- (void)reloadDataWithCompletion:(nullable IGListUpdaterCompletion)completion { id&amp;lt;IGListAdapterDataSource&amp;gt; dataSource = self.dataSource; UICollectionView *collectionView = self.collectionView; if (dataSource == nil || collectionView == nil) { if (completion) { completion(NO); } return; } NSArray *uniqueObjects = objectsWithDuplicateIdentifiersRemoved([dataSource objectsForListAdapter:self]); __weak __typeof__(self) weakSelf = self; [self.updater reloadDataWithCollectionViewBlock:[self _collectionViewBlock] reloadUpdateBlock:^{ [weakSelf.sectionMap reset]; [weakSelf _updateObjects:uniqueObjects dataSource:dataSource]; } completion:^(BOOL finished) { [weakSelf _notifyDidUpdate:IGListAdapterUpdateTypeReloadData animated:NO]; if (completion) { completion(finished); } }];}reloadObjects:reloadObjects: 刷新 objects 所对应的 section ，在 object 有更新时进行调用，可以直接更新所对应的 sections ：- (void)reloadObjects:(NSArray *)objects { NSMutableIndexSet *sections = [NSMutableIndexSet new]; // 1. 使用 `_sectionMapUsingPreviousIfInUpdateBlock` 获取 `sectionMap` ， // 因为 `reloadObjects` 是有可能在 `batch update` 过程中调用，如果是在 `batch update` 则使用旧的 `sectionMap` IGListSectionMap *map = [self _sectionMapUsingPreviousIfInUpdateBlock:YES]; for (id object in objects) { // 2. 根据 `object` 找到 `section` ，如果找不到则直接跳过 const NSInteger section = [map sectionForObject:object]; const BOOL notFound = section == NSNotFound; if (notFound) { continue; } [sections addIndex:section]; // 3. 根据 `section` 找一下 `object` ，如果新旧 `object` 不相等，`map` 则更新 `object` ， // 同时更新 `sectionController` 的 `object` if (object != [map objectForSection:section]) { [map updateObject:object]; [[map sectionControllerForSection:section] didUpdateToObject:object]; } } UICollectionView *collectionView = self.collectionView; [self.updater reloadCollectionView:collectionView sections:sections];}协议IGListKit 围绕 IGListAdapter 定义了了大量协议，提供了良好的扩展性和接口封装。下面逐一来进行分析。IGListAdapterDelegate当 object 在屏幕上出现/消失，会调用 IGListKit 的 id &amp;lt;IGListAdapterDelegate&amp;gt; delegate 的相关方法，但是由于是基于 object 的，所以粒度没有办法精确到每个 Cell ，所以需要 Cell 级别的粒度，可以使用 IGListSectionController 的 id &amp;lt;IGListDisplayDelegate&amp;gt; displayDelegate 。NS_SWIFT_NAME(ListAdapterDelegate)@protocol IGListAdapterDelegate &amp;lt;NSObject&amp;gt;- (void)listAdapter:(IGListAdapter *)listAdapter willDisplayObject:(id)object atIndex:(NSInteger)index;- (void)listAdapter:(IGListAdapter *)listAdapter didEndDisplayingObject:(id)object atIndex:(NSInteger)index;@endUICollectionViewDelegate &amp;amp; UIScrollViewDelegate这两个需要放在一起说说，因为 IGListKit 对 IGListAdapter 的这两个 delegate 做了处理：// 只接收 `UICollectionViewDelegate` 的回调，不接收 `UIScrollViewDelegate` 的回调@property (nonatomic, nullable, weak) id &amp;lt;UICollectionViewDelegate&amp;gt; collectionViewDelegate;// 只接收 `UIScrollViewDelegate ` 的回调@property (nonatomic, nullable, weak) id &amp;lt;UIScrollViewDelegate&amp;gt; scrollViewDelegate;因为 UICollectionViewDelegate 是继承自 UIScrollViewDelegate ，所以 id &amp;lt;UICollectionViewDelegate&amp;gt; collectionViewDelegate 也会接收到 UIScrollViewDelegate 的回调，所以 IGListKit 使用一个 NSProxy 子类 IGListAdapterProxy 来对不同 delegate 的回调进行区分：- (void)_createProxyAndUpdateCollectionViewDelegate { _collectionView.delegate = nil; self.delegateProxy = [[IGListAdapterProxy alloc] initWithCollectionViewTarget:_collectionViewDelegate scrollViewTarget:_scrollViewDelegate interceptor:self]; [self _updateCollectionViewDelegate];}- (void)_updateCollectionViewDelegate { _collectionView.delegate = (id&amp;lt;UICollectionViewDelegate&amp;gt;)self.delegateProxy ?: self;}- (instancetype)initWithCollectionViewTarget:(nullable id&amp;lt;UICollectionViewDelegate&amp;gt;)collectionViewTarget scrollViewTarget:(nullable id&amp;lt;UIScrollViewDelegate&amp;gt;)scrollViewTarget interceptor:(IGListAdapter *)interceptor { IGParameterAssert(interceptor != nil); if (self) { _collectionViewTarget = collectionViewTarget; _scrollViewTarget = scrollViewTarget; _interceptor = interceptor; } return self;}- (BOOL)respondsToSelector:(SEL)aSelector { // 先判断是否经过 `IGListAdapter` 进行处理，然后再判断 `_collectionViewTarget` 或者 `_scrollViewTarget` 是否可以响应 return isInterceptedSelector(aSelector) || [_collectionViewTarget respondsToSelector:aSelector] || [_scrollViewTarget respondsToSelector:aSelector];}- (id)forwardingTargetForSelector:(SEL)aSelector { // 先判断 _interceptor 是否可以处理，如果可以，就转发给 _interceptor if (isInterceptedSelector(aSelector)) { return _interceptor; } // 因为 `UICollectionViewDelegate` 是 `UIScrollViewDelegate` 的子类，所以先检查 `_scrollViewTarget` 是否可以响应， // 否则使用 _collectionViewTarget return [_scrollViewTarget respondsToSelector:aSelector] ? _scrollViewTarget : _collectionViewTarget;}IGListAdapterPerformanceDelegateid &amp;lt;IGListAdapterPerformanceDelegate&amp;gt; performanceDelegate 是为调用方提供了 UICollectionView 在滑动时会调用的方法耗时的回调，比如说监听获取 Cell 的耗时。// 性能相关的 delegate ，@property (nonatomic, nullable, weak) id &amp;lt;IGListAdapterPerformanceDelegate&amp;gt; performanceDelegate;- (UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath { id&amp;lt;IGListAdapterPerformanceDelegate&amp;gt; performanceDelegate = self.performanceDelegate; [performanceDelegate listAdapterWillCallDequeueCell:self]; IGListSectionController *sectionController = [self sectionControllerForSection:indexPath.section]; UICollectionViewCell *cell = [sectionController cellForItemAtIndex:indexPath.item]; /// .... [performanceDelegate listAdapter:self didCallDequeueCell:cell onSectionController:sectionController atIndex:indexPath.item]; return cell;}这里去除其它代码，只保留 performanceDelegate 部分，可以看到在 cellForItemAtIndexPath 的开头和结尾调用了 performanceDelegate 的方法。IGListBatchContext支持 IGListBatchContext 协议的对象为 IGListSectionController 提供了 reload/insert/delete/move 等方法，在 IGListKit 中，这个对象是 IGListAdapter ，只是 IGListSectionController 不知道这个对象的具体类型，只知道是 id &amp;lt;IGListBatchContext&amp;gt; 。-reloadInSectionController:atIndexes: 方法负责重新加载 IGListSectionController 中 indexes 所对应的 Cell 。 UICollectionView 并不支持在 batch updates 中 -reloadSections 或者 -reloadItemsAtIndexPaths: ，内部实现为通过 delete 和 insert 操作实现，这块的实现在某些操作下可能会导致异常。假设有个 object ， 对应的 section 为 2 ，items 数量为 4 ，如果需要对 index 为 1 的 item 进行 reload ，先要创建一个 NSIndexPath ，item 为 1， section 为 2 ，当执行 -performBatchUpdates: 时， UICollectionView 会删除和插入这个 NSIndexPath 。如果这时我们在 position 为 2 中插入了一个 section ，原有的 seciton 2 就会变成 section 3 。然而，插入的 indexPath 的 section 还是 2 。那么 UICollectionView 就会在 section: 2 item: 1 执行一个插入动画，这时候就会抛出一个异常。为了避免这个问题， IGListAdapter 会根据 sectionController 的新旧来获取不同的 NSIndexPath ：- (void)reloadInSectionController:(IGListSectionController *)sectionController atIndexes:(NSIndexSet *)indexes { UICollectionView *collectionView = self.collectionView; if (indexes.count == 0) { return; } [indexes enumerateIndexesUsingBlock:^(NSUInteger index, BOOL *stop) { NSIndexPath *fromIndexPath = [self indexPathForSectionController:sectionController index:index usePreviousIfInUpdateBlock:YES]; NSIndexPath *toIndexPath = [self indexPathForSectionController:sectionController index:index usePreviousIfInUpdateBlock:NO]; if (fromIndexPath != nil &amp;amp;&amp;amp; toIndexPath != nil) { [self.updater reloadItemInCollectionView:collectionView fromIndexPath:fromIndexPath toIndexPath:toIndexPath]; } }];}可以看到 fromIndexPath 是根据旧的数据源获取， toIndexPath 是新的数据源，同时还需要进行是否为 nil 的检查，因为 sectionController 有可能在批量更新中被删除了。-invalidateLayoutInSectionController:atIndexes: 让 IGListSectionController 指定 Cell 布局信息失效：- (void)invalidateLayoutInSectionController:(IGListSectionController *)sectionController atIndexes:(NSIndexSet *)indexes { UICollectionView *collectionView = self.collectionView; if (indexes.count == 0) { return; } NSArray *indexPaths = [self indexPathsFromSectionController:sectionController indexes:indexes usePreviousIfInUpdateBlock:NO]; UICollectionViewLayout *layout = collectionView.collectionViewLayout; UICollectionViewLayoutInvalidationContext *context = [[[layout.class invalidationContextClass] alloc] init]; [context invalidateItemsAtIndexPaths:indexPaths]; [layout invalidateLayoutWithContext:context];}获取到 indexPaths 为新的 objects 所对应的 indexPaths ，这里是通过 [layout.class invalidationContextClass] ，因为 layout 有可能使用的是自定义的 UICollectionViewLayoutInvalidationContext 子类。IGListCollectionContextIGListCollectionContext 为 IGListSectionController 提供了 UICollectionView 的相关信息，如大小，复用，插入，删除，重新加载等。通过协议的方式可以把接口统一起来， IGListSectionController只能使用 IGListCollectionContext 提供的接口，它不知道也不需要知道 IGListAdapter 的存在。- (__kindof UICollectionViewCell *)dequeueReusableCellOfClass:(Class)cellClass withReuseIdentifier:(NSString *)reuseIdentifier forSectionController:(IGListSectionController *)sectionController atIndex:(NSInteger)index { UICollectionView *collectionView = self.collectionView; NSString *identifier = IGListReusableViewIdentifier(cellClass, nil, reuseIdentifier); NSIndexPath *indexPath = [self indexPathForSectionController:sectionController index:index usePreviousIfInUpdateBlock:NO]; if (![self.registeredCellIdentifiers containsObject:identifier]) { [self.registeredCellIdentifiers addObject:identifier]; [collectionView registerClass:cellClass forCellWithReuseIdentifier:identifier]; } return [collectionView dequeueReusableCellWithReuseIdentifier:identifier forIndexPath:indexPath];}在复用 Cell 时， IGListKit 不需要先调用 register 方法来注册 Cell ， IGListAdapter 内部记录了已经注册过的 Cell ，如果没有注册过，就先调用 UICollectionView 的 register 方法来进行注册，然后再调用 dequeueReusableCell 方法来从复用池中获取 Cell 。这是一个非常舒服的特性，如果每次使用都需要注册 Cell ，那么当业务变得非常复杂时，可能需要注册大量的 Cell ，会出现一个屏幕都无法完全显示注册 Cell 的方法。同时 UICollectionView 或者 UIViewController 也不需要和 Cell 进行交互，当 Cell 需要调整时，我们只需要在 IGListSectionController 中进行处理，或者直接替换对应的 IGListSectionController 。上面说到在获取 Cell 时， IGListKit 会自动帮我们判断是否需要注册对应的 Cell ，下面来看下具体是如何实现的：NS_INLINE NSString *IGListReusableViewIdentifier(Class viewClass, NSString * _Nullable kind, NSString * _Nullable givenReuseIdentifier) { return [NSString stringWithFormat:@&quot;%@%@%@&quot;, kind ?: @&quot;&quot;, givenReuseIdentifier ?: @&quot;&quot;, NSStringFromClass(viewClass)];}- (__kindof UICollectionViewCell *)dequeueReusableCellOfClass:(Class)cellClass withReuseIdentifier:(NSString *)reuseIdentifier forSectionController:(IGListSectionController *)sectionController atIndex:(NSInteger)index { UICollectionView *collectionView = self.collectionView; NSString *identifier = IGListReusableViewIdentifier(cellClass, nil, reuseIdentifier); NSIndexPath *indexPath = [self indexPathForSectionController:sectionController index:index usePreviousIfInUpdateBlock:NO]; if (![self.registeredCellIdentifiers containsObject:identifier]) { [self.registeredCellIdentifiers addObject:identifier]; [collectionView registerClass:cellClass forCellWithReuseIdentifier:identifier]; } return [collectionView dequeueReusableCellWithReuseIdentifier:identifier forIndexPath:indexPath];}这个方法是在 IGListAdapter 内， IGListAdapter 会使用 NSMutableSet 来记录所有注册过的 Cell 对应的 reuseIdentifier ，在调用 dequeueReusableCellWithReuseIdentifier:forIndexPath: 前会先判断 registeredCellIdentifiers 是否有包含这个 identifier ，如果没有则进行注册，而 IGListReusableViewIdentifier 会采用 kind ， givenReuseIdentifier 和 viewClass 进行拼接的方式，生成新的 identifier ，也就不可能存在相同的 identifier 。如果需要在 IGListSectionController 内部对数据源进行修改和刷新视图， IGListCollectionContext 也提供了如下方法：- (void)performBatchAnimated:(BOOL)animated updates:(void (^)(id&amp;lt;IGListBatchContext&amp;gt;))updates completion:(void (^)(BOOL))completion { [self _enterBatchUpdates]; __weak __typeof__(self) weakSelf = self; [self.updater performUpdateWithCollectionViewBlock:[self _collectionViewBlock] animated:animated itemUpdates:^{ // 更新 `isInUpdateBlock` ，执行 `block` weakSelf.isInUpdateBlock = YES; updates(weakSelf); weakSelf.isInUpdateBlock = NO; } completion: ^(BOOL finished) { // 判断是否需要显示 emptyView [weakSelf _updateBackgroundViewShouldHide:![weakSelf _itemCountIsZero]]; [weakSelf _notifyDidUpdate:IGListAdapterUpdateTypeItemUpdates animated:animated]; if (completion) { completion(finished); } [weakSelf _exitBatchUpdates]; }];}-performBatchAnimated:updates:completion: 支持在执行多个 Cell 的相关操作。在 updates block 中更新 sectionController 的 dataSource ，然后调用 IGListBatchContext 的方法来插入/删除 items ：// self 为 IGListSectionController[self.collectionContext performBatchItemUpdates:^ (id&amp;lt;IGListBatchContext&amp;gt; batchContext&amp;gt;){ [self.items addObject:newItem]; [self.items removeObjectAtIndex:0]; NSIndexSet *inserts = [NSIndexSet indexSetWithIndex:[self.items count] - 1]; [batchContext insertInSectionController:self atIndexes:inserts]; NSIndexSet *deletes = [NSIndexSet indexSetWithIndex:0]; [batchContext deleteInSectionController:self atIndexes:deletes]; } completion:nil];IGListAdapterUpdateListenerIGListKit 支持上面提到的几种刷新方式， IGListAdapterUpdateListener 则提供了相关回调：typedef NS_ENUM(NSInteger, IGListAdapterUpdateType) { // 调用 `-[IGListAdapter performUpdatesAnimated:completion:]` IGListAdapterUpdateTypePerformUpdates, // 调用 `-[IGListAdapter reloadDataWithCompletion:]` IGListAdapterUpdateTypeReloadData, // 在 `IGListSectionController` 中调用 `-[IGListCollectionContext performBatchAnimated:updates:completion:]` IGListAdapterUpdateTypeItemUpdates,};@protocol IGListAdapterUpdateListener &amp;lt;NSObject&amp;gt;- (void)listAdapter:(IGListAdapter *)listAdapter didFinishUpdate:(IGListAdapterUpdateType)update animated:(BOOL)animated;@end这个方法会在以下几种情况下调用： 执行 -[IGListAdapter performUpdatesAnimated:completion:] 的 completion block 前调用； 执行 -[IGListAdapter reloadDataWithCompletion:] 后调用； IGListSectionController 执行 -[IGListCollectionContext performBatchAnimated:updates:completion:] 方法后。IGListAdapter 支持设置多个 Listener ，对外提供了两个方法来添加和移除 Listener :- (void)addUpdateListener:(id&amp;lt;IGListAdapterUpdateListener&amp;gt;)updateListener;- (void)removeUpdateListener:(id&amp;lt;IGListAdapterUpdateListener&amp;gt;)updateListener;总结IGListAdapter 作为 IGListKit 的适配器，对外提供相关的刷新接口和一些通用方法，对内负责管理 IGListSectionController 和 UICollectionView ，调用 dataSource 和 delegate 。" }, { "title": "IGListKit 的基石 - IGListSectionController", "url": "/posts/iglistkit-second/", "categories": "", "tags": "源码解析", "date": "2020-12-20 09:43:00 +0800", "snippet": "IGListSectionController 跟 Object 是一一对应的关系，在 IGListAdapterDataSource 的 listAdapter:sectionControllerForObject: 方法中，会根据不同的 Object 返回不同的 IGListSectionController 。它跟我们日常理解的 UICollectinoView 的 Section 不同，你无法将 Object 的数组和 IGListSectionController 绑定，如果要将数组绑定到一个 IGListSectionController 中，需要将 Object 的数组用一个 Wrapper 封装起来，再将其和 IGListSectionController 绑定。一般情况下需要对 IGListSectionController 进行自定义，通过 IGListSectionController 的 didUpdateToObject: 方法更新自身的Object 。同时 IGListSectionController 也提供了与 Cell 进行交互的相关方法：- (void)didSelectItemAtIndex:(NSInteger)index;- (void)didDeselectItemAtIndex:(NSInteger)index;- (void)didHighlightItemAtIndex:(NSInteger)index;- (void)didUnhighlightItemAtIndex:(NSInteger)index;由于 IGListSectionController 自己包含了 Cell 的配置（如 size ，类型等）和交互，所以 IGListSectionController 可以作为一个模块来复用，对于相同的 Object ，如果交互和界面都一致，则可以返回相同的 IGListSectionController 。同时 IGListSectionController 也提供了一些 Delegate 和 DataSource ，在对应的时机会进行调用。id &amp;lt;IGListSupplementaryViewSource&amp;gt; supplementaryViewSource ，用于配置 UICollectionView 每个 section 的 supplementary views ：- (NSArray&amp;lt;NSString *&amp;gt; *)supportedElementKinds;- (__kindof UICollectionReusableView *)viewForSupplementaryElementOfKind:(NSString *)elementKind atIndex:(NSInteger)index;- (CGSize)sizeForSupplementaryViewOfKind:(NSString *)elementKind atIndex:(NSInteger)index;也可以设置 supplementaryViewSource 为 IGListSectionController 它自己，这样在 IGListSectionController 就内部就可以完成 supplementary views 的配置，复用时更加方便。IGListSectionControllerThreadContextIGListSectionController 在初始化时需要获取到当前的 UIViewController *viewController 和 id &amp;lt;IGListCollectionContext&amp;gt; collectionContext 。 viewController 可用于 push ， pop ， present 或者其它自定义转场，对于 IGListSectionController 来说，它只知道这是一个 UIViewController ，不知道它的具体类型，因为 IGListSectionController 是可复用的，我们有可能将其和不同的 UIViewController 连接起来，所以其 viewController 的类型是不确定的； collectionContext 为了对接口进行收敛，限制可以调用的接口，使用了 protocol 对其进行抽象， collectionContext 本质上是一个 IGListAdapter ，但是 IGListAdapter 可能有一些我们不需要也不想提供给外界访问的接口，所以借由 protocol 来进行抽象。IGListKit 定义了 IGListSectionControllerThreadContext ，在 IGListSectionController 初始化时对 viewController 和 collectionContext 进行设置：- (instancetype)init { if (self = [super init]) { IGListSectionControllerThreadContext *context = [threadContextStack() lastObject]; _viewController = context.viewController; _collectionContext = context.collectionContext; if (_collectionContext == nil) { IGLKLog(@&quot;Warning: Creating %@ outside of -[IGListAdapterDataSource listAdapter:sectionControllerForObject:]. Collection context and view controller will be set later.&quot;, NSStringFromClass([self class])); } /// ... } return self;}由于 IGListSectionController 的初始化方法是交给调用方来定义的， IGListKit 无法确定 IGListSectionController 的初始化参数，同时也为了使得初始化方法尽量简洁，不包含太多参数，使用了 Thread Dictionary 来存储所对应的对象，从上面的方法可以看到是通过 threadContextStack() 来获取最新的 IGListSectionControllerThreadContext ：static NSString * const kIGListSectionControllerThreadKey = @&quot;kIGListSectionControllerThreadKey&quot;;static NSMutableArray&amp;lt;IGListSectionControllerThreadContext *&amp;gt; *threadContextStack(void) { IGAssertMainThread(); NSMutableDictionary *threadDictionary = [[NSThread currentThread] threadDictionary]; NSMutableArray *stack = threadDictionary[kIGListSectionControllerThreadKey]; if (stack == nil) { stack = [NSMutableArray new]; threadDictionary[kIGListSectionControllerThreadKey] = stack; } return stack;}threadContextStack() 通过 [[NSThread currentThread] threadDictionary] 来获取对应的 stack ，而 push 和 pop 方法则是在 IGListAdapter 初始化 IGListSectionController 前后调用：void IGListSectionControllerPushThread(UIViewController *viewController, id&amp;lt;IGListCollectionContext&amp;gt; collectionContext) { IGListSectionControllerThreadContext *context = [IGListSectionControllerThreadContext new]; context.viewController = viewController; context.collectionContext = collectionContext; [threadContextStack() addObject:context];}void IGListSectionControllerPopThread(void) { NSMutableArray *stack = threadContextStack(); IGAssert(stack.count &amp;gt; 0, @&quot;IGListSectionController thread stack is empty&quot;); [stack removeLastObject];}子类GenericSection为了更好地和 Swift 进行交互， Objective-C 在 WWDC2015 后也支持了轻量级的范型。基础的使用方法是指定容器类中对象的类型：NSArray &amp;lt;NSString *&amp;gt; strings;NSDictionary &amp;lt;NSString *, NSNumber *&amp;gt; *dictionary;如果往上面两个指定了类型的容器类对象中添加别的类型的对象，编译器就会显示警告，这更有利于我们写出更加安全和可读的代码。同时，也支持我们自定义自己的范型类， IGListGenericSectionController 提供了特定类型的 IGListSectionController :@interface IGListGenericSectionController&amp;lt;__covariant ObjectType&amp;gt; : IGListSectionController@property (nonatomic, strong, nullable, readonly) ObjectType object;- (void)didUpdateToObject:(ObjectType)object NS_REQUIRES_SUPER;@end作用相当于一个强类型的 IGListSectionController ，相关 issue ：Assert generic type in IGListGenericSectionControllerSingleSection对于只有单个 Cell 的 Section ， IGListKit 提供了 IGListSingleSectionController ，它通过 block 配置 Cell 和通过 Delegate 来获取点击事件的回调。@protocol IGListSingleSectionControllerDelegate &amp;lt;NSObject&amp;gt;- (void)didSelectSectionController:(IGListSingleSectionController *)sectionController withObject:(id)object;@optional- (void)didDeselectSectionController:(IGListSingleSectionController *)sectionController withObject:(id)object;@end@interface IGListSingleSectionController : IGListSectionController- (instancetype)initWithCellClass:(Class)cellClass configureBlock:(IGListSingleSectionCellConfigureBlock)configureBlock sizeBlock:(IGListSingleSectionCellSizeBlock)sizeBlock;- (instancetype)initWithNibName:(NSString *)nibName bundle:(nullable NSBundle *)bundle configureBlock:(IGListSingleSectionCellConfigureBlock)configureBlock sizeBlock:(IGListSingleSectionCellSizeBlock)sizeBlock;- (instancetype)initWithStoryboardCellIdentifier:(NSString *)identifier configureBlock:(IGListSingleSectionCellConfigureBlock)configureBlock sizeBlock:(IGListSingleSectionCellSizeBlock)sizeBlock;@property (nonatomic, weak, nullable) id&amp;lt;IGListSingleSectionControllerDelegate&amp;gt; selectionDelegate;BindingSection对于 Section 的数据流绑定， IGListKit 则提供了 IGListBindingSectionController 。 IGListBindingSectionController 通过 id&amp;lt;IGListBindingSectionControllerDataSource&amp;gt; dataSource 的方式把顶层的 Object 转换为 NSArray&amp;lt;id&amp;lt;IGListDiffable&amp;gt;&amp;gt; viewModels ，然后调用支持 IGListBindable 协议的 Cell 中的 bindViewModel: 方法来刷新 Cell 。如果 Object 是跟 IGListBindingSectionController 匹配，那么在处理 IGListDiffable 协议的方法时需要非常小心。 IGListDiffable 通过 -diffIdentifier 来判断两个 Object 是否为同一个，再通过 -isEqualToDiffableObject: 方法来判断 Object 是否有更新。由于 IGListBindingSectionController 已经在内部消化了 Object 的更新逻辑，所以如果是跟 IGListBindingSectionController 绑定的 Object ，其对应的 -isEqualToDiffableObject: 方法应该一直返回 YES ：- (BOOL)isEqualToDiffableObject:(id)object { return YES;} func isEqual(toDiffableObject object: IGListDiffable?) -&amp;gt; Bool { return true }IGListBindingSectionController 内部重写了一些方法，通过 IGListBindingSectionControllerDataSource 和 IGListBindingSectionControllerSelectionDelegate 来和外部进行交互。- (void)didUpdateToObject:(id)object { id oldObject = self.object; self.object = object; if (oldObject == nil) { NSArray *viewModels = [self.dataSource sectionController:self viewModelsForObject:object]; self.viewModels = objectsWithDuplicateIdentifiersRemoved(viewModels); } else {#if defined(IGLK_LOGGING_ENABLED) &amp;amp;&amp;amp; IGLK_LOGGING_ENABLED if (![oldObject isEqualToDiffableObject:object]) { IGLKLog(@&quot;Warning: Unequal objects %@ and %@ will cause IGListBindingSectionController to reload the entire section&quot;, oldObject, object); }#endif [self updateAnimated:YES completion:nil]; }}在 didUpdateToObject: 方法中，通过 dataSource 返回 viewModels ，移除重复部分后设置为 self.viewModels 。由于 IGListBindingSectionController 在内部处理了 Object 的更新逻辑，所以 didUpdateToObject: 只会调用一次，如果多次调用且新旧 Object 不相等，则表示设置错误，打印一个 warning ，但是同时也调用 updateAnimated:completion: 更新 Cell 。当对 Object 进行修改后，如果需要更新 Cell ，调用 IGListBindingSectionController 的 updateAnimated:completion: 方法：- (void)updateAnimated:(BOOL)animated completion:(void (^)(BOOL))completion { // 1. 如果不是空闲状态，则直接返回，调用 `completion(NO)` ； if (self.state != IGListDiffingSectionStateIdle) { if (completion != nil) { completion(NO); } return; } self.state = IGListDiffingSectionStateUpdateQueued; __block IGListIndexSetResult *result = nil; __block NSArray&amp;lt;id&amp;lt;IGListDiffable&amp;gt;&amp;gt; *oldViewModels = nil; id&amp;lt;IGListCollectionContext&amp;gt; collectionContext = self.collectionContext; [self.collectionContext performBatchAnimated:animated updates:^(id&amp;lt;IGListBatchContext&amp;gt; batchContext) { if (self.state != IGListDiffingSectionStateUpdateQueued) { return; } oldViewModels = self.viewModels; id&amp;lt;IGListDiffable&amp;gt; object = self.object; NSArray *newViewModels = [self.dataSource sectionController:self viewModelsForObject:object]; self.viewModels = objectsWithDuplicateIdentifiersRemoved(newViewModels); // 2. 通过 IGListDiff 的算法计算出需要操作的位置 result = IGListDiff(oldViewModels, self.viewModels, IGListDiffEquality); // 3. 遍历 `updates` ，首先获取 `Cell` 所对应的 `index` ， // 也就是旧的 `viewModels` 中的 `index` ，通过 `index` 获取到 `Cell` ， // 然后使用新的 `index` 获取到新的 `viewModel` ，`Cell` 通过新的 `viewModel` 进行更新 [result.updates enumerateIndexesUsingBlock:^(NSUInteger oldUpdatedIndex, BOOL *stop) { id identifier = [oldViewModels[oldUpdatedIndex] diffIdentifier]; const NSInteger indexAfterUpdate = [result newIndexForIdentifier:identifier]; if (indexAfterUpdate != NSNotFound) { UICollectionViewCell&amp;lt;IGListBindable&amp;gt; *cell = [collectionContext cellForItemAtIndex:oldUpdatedIndex sectionController:self]; [cell bindViewModel:self.viewModels[indexAfterUpdate]]; } }]; if (IGListExperimentEnabled(self.collectionContext.experiments, IGListExperimentInvalidateLayoutForUpdates)) { [batchContext invalidateLayoutInSectionController:self atIndexes:result.updates]; } // 4. 通过 result 进行 `Cell` 的删除/插入 [batchContext deleteInSectionController:self atIndexes:result.deletes]; [batchContext insertInSectionController:self atIndexes:result.inserts]; for (IGListMoveIndex *move in result.moves) { [batchContext moveInSectionController:self fromIndex:move.from toIndex:move.to]; } self.state = IGListDiffingSectionStateUpdateApplied; } completion:^(BOOL finished) { self.state = IGListDiffingSectionStateIdle; if (completion != nil) { completion(YES); } }];}在获取 Cell 时， IGListBindingSectionController 也会自行进行 Cell 和 Object 的绑定， Cell 需要遵循 IGListBindable 协议：// protocol IGListBindable@protocol IGListBindable &amp;lt;NSObject&amp;gt;- (void)bindViewModel:(id)viewModel;@end- (UICollectionViewCell *)cellForItemAtIndex:(NSInteger)index { id&amp;lt;IGListDiffable&amp;gt; viewModel = self.viewModels[index]; UICollectionViewCell&amp;lt;IGListBindable&amp;gt; *cell = [self.dataSource sectionController:self cellForViewModel:viewModel atIndex:index]; [cell bindViewModel:viewModel]; return cell;}从上面的代码可以看到 IGListBindingSectionController 也提供了基于 Cell 进行局部刷新的能力。IGListSectionMapIGListSectionMap 提供了一种在常数时间内对 Object 和 SectionController 进行互相映射的方式。主要方法有以下几种： 根据 section 返回对应的 IGListSectionController ：/// 根据 section 返回对应的 IGListSectionController- (nullable IGListSectionController *)sectionControllerForSection:(NSInteger)section;/// 根据 section 返回对应的 Object- (nullable id)objectForSection:(NSInteger)section;/// 根据 object 返回对应的 IGListSectionController- (nullable id)sectionControllerForObject:(id)object;/// 根据 sectionController 返回对应的 Section Index- (NSInteger)sectionForSectionController:(id)sectionController;/// 根据 object 返回对应的 Section Index- (NSInteger)sectionForObject:(id)object;IGListSectionMap 内部实现：@interface IGListSectionMap ()@property (nonatomic, strong, readonly, nonnull) NSMapTable&amp;lt;id, IGListSectionController *&amp;gt; *objectToSectionControllerMap;@property (nonatomic, strong, readonly, nonnull) NSMapTable&amp;lt;IGListSectionController *, NSNumber *&amp;gt; *sectionControllerToSectionMap;@property (nonatomic, strong, nonnull) NSMutableArray *mObjects;@endobjectToSectionControllerMap 提供了 Object 到 sectionController 的映射， sectionControllerToSectionMap 提供了 sectionController 到 section 的映射， mObjects 提供了根据 section 返回 index 的方法。IGListSectionMap 也提供了接口对属性进行批量更新：- (void)updateWithObjects:(NSArray *)objects sectionControllers:(NSArray *)sectionControllers { [self reset]; self.mObjects = [objects mutableCopy]; id firstObject = objects.firstObject; id lastObject = objects.lastObject; [objects enumerateObjectsUsingBlock:^(id object, NSUInteger idx, BOOL *stop) { IGListSectionController *sectionController = sectionControllers[idx]; [self.sectionControllerToSectionMap setObject:@(idx) forKey:sectionController]; [self.objectToSectionControllerMap setObject:sectionController forKey:object]; sectionController.isFirstSection = (object == firstObject); sectionController.isLastSection = (object == lastObject); sectionController.section = (NSInteger)idx; }];}清空现有数据主要是对 IGListSectionController 相关属性的清理：- (void)reset { [self enumerateUsingBlock:^(id _Nonnull object, IGListSectionController * _Nonnull sectionController, NSInteger section, BOOL * _Nonnull stop) { sectionController.section = NSNotFound; sectionController.isFirstSection = NO; sectionController.isLastSection = NO; }]; [self.sectionControllerToSectionMap removeAllObjects]; [self.objectToSectionControllerMap removeAllObjects];}WorkingRangeWorking range 表示还没出现在屏幕上，但是已经在附近的 IGListSectionController ， IGListSectionController 可以在进入或者退出 Working range 时获取对应的通知，借此可以进行一些准备工作，比如说预先下载图片。 IGListAdapter 可以在初始化时指定 Working range 的大小：let adapter = ListAdapter(updater: ListAdapterUpdater(), viewController: self, workingRangeSize: 1) // 1 before/after visible objects你可以给 IGListSectionController 设置 workingRangeDelegate 来获取对应的回调。下面来看看对应的实现， IGListKit 内部提供了一个 IGListWorkingRangeHandler ，在 UICollectionViewDelegate 的 willDisplay/didEndDisplaying 方法中调用 IGListWorkingRangeHandler 对应的方法：- (void)willDisplayItemAtIndexPath:(NSIndexPath *)indexPath forListAdapter:(IGListAdapter *)listAdapter;- (void)didEndDisplayingItemAtIndexPath:(NSIndexPath *)indexPath forListAdapter:(IGListAdapter *)listAdapter;为了效率更高， IGListWorkingRangeHandler 内部是基于 C++ 实现的，内部定义了 _visibleSectionIndices 和 _workingRangeSectionControllers 两个 std::unordered_set 的变量。- (void)willDisplayItemAtIndexPath:(NSIndexPath *)indexPath forListAdapter:(IGListAdapter *)listAdapter { _visibleSectionIndices.insert({ .section = indexPath.section, .row = indexPath.row, .hash = indexPath.hash }); [self _updateWorkingRangesWithListAdapter:listAdapter];}- (void)didEndDisplayingItemAtIndexPath:(NSIndexPath *)indexPath forListAdapter:(IGListAdapter *)listAdapter { _visibleSectionIndices.erase({ .section = indexPath.section, .row = indexPath.row, .hash = indexPath.hash }); [self _updateWorkingRangesWithListAdapter:listAdapter];}每次更新 Cell 的显示隐藏状态时都会更新 _visibleSectionIndices ，然后再调用 _updateWorkingRangesWithListAdapter: 方法：- (void)_updateWorkingRangesWithListAdapter:(IGListAdapter *)listAdapter { // 1. 由于需要顺序的 `set` ，所以这里使用了 `std::set` ； std::set&amp;lt;NSInteger&amp;gt; visibleSectionSet = std::set&amp;lt;NSInteger&amp;gt;(); // 2. 插入所有可见的 `section` ； for (const _IGListWorkingRangeHandlerIndexPath &amp;amp;indexPath : _visibleSectionIndices) { visibleSectionSet.insert(indexPath.section); } NSInteger start; NSInteger end; // 3. 计算出开始和结束位置； if (visibleSectionSet.size() == 0) { start = 0; end = 0; } else { start = MAX(*visibleSectionSet.begin() - _workingRangeSize, 0); end = MIN(*visibleSectionSet.rbegin() + 1 + _workingRangeSize, (NSInteger)listAdapter.objects.count); } // 4. 创建新的 `workingRangeSectionControllers` ； _IGListWorkingRangeSectionControllerSet workingRangeSectionControllers (visibleSectionSet.size()); for (NSInteger idx = start; idx &amp;lt; end; idx++) { id item = [listAdapter objectAtSection:idx]; IGListSectionController *sectionController = [listAdapter sectionControllerForObject:item]; workingRangeSectionControllers.insert({sectionController}); } // 5. 遍历新的 `workingRangeSectionControllers` ，如果不在旧的 `_workingRangeSectionControllers` 中， // 则表示这个 `sectionController` 是新加入的，调用 `sectionControllerWillEnterWorkingRange` ； for (const _IGListWorkingRangeHandlerSectionControllerWrapper &amp;amp;wrapper : workingRangeSectionControllers) { auto it = _workingRangeSectionControllers.find(wrapper); if (it == _workingRangeSectionControllers.end()) { id &amp;lt;IGListWorkingRangeDelegate&amp;gt; workingRangeDelegate = wrapper.sectionController.workingRangeDelegate; [workingRangeDelegate listAdapter:listAdapter sectionControllerWillEnterWorkingRange:wrapper.sectionController]; } } // 6. 遍历旧的 `_workingRangeSectionControllers` ，如果不在新的 `workingRangeSectionControllers` 中， // 则表示这个 `sectionController` 是已退出的，调用 `sectionControllerDidExitWorkingRange` ； for (const _IGListWorkingRangeHandlerSectionControllerWrapper &amp;amp;wrapper : _workingRangeSectionControllers) { auto it = workingRangeSectionControllers.find(wrapper); if (it == workingRangeSectionControllers.end()) { id &amp;lt;IGListWorkingRangeDelegate&amp;gt; workingRangeDelegate = wrapper.sectionController.workingRangeDelegate; [workingRangeDelegate listAdapter:listAdapter sectionControllerDidExitWorkingRange:wrapper.sectionController]; } } _workingRangeSectionControllers = workingRangeSectionControllers;}可以看到由于 workingRange 是以 Section 为单位，所以无法提供精细到 Cell 级别的预处理。这也是基于 SectionController 进行处理的缺点。DisplayHandlerIGListDisplayHandler 是 IGListKit 内部用于处理 Cell 显示/消失在屏幕上的相关事件。 IGListAdapter 在 UICollectionViewDelegate 的 willDisplay/didEndDisplaying 方法中调用 IGListDisplayHandler 对应的方法：- (void)willDisplayCell:(UICollectionViewCell *)cell forListAdapter:(IGListAdapter *)listAdapter sectionController:(IGListSectionController *)sectionController object:(id)object indexPath:(NSIndexPath *)indexPath;- (void)didEndDisplayingCell:(UICollectionViewCell *)cell forListAdapter:(IGListAdapter *)listAdapter sectionController:(IGListSectionController *)sectionController indexPath:(NSIndexPath *)indexPath;- (void)willDisplaySupplementaryView:(UICollectionReusableView *)view forListAdapter:(IGListAdapter *)listAdapter sectionController:(IGListSectionController *)sectionController object:(id)object indexPath:(NSIndexPath *)indexPath;- (void)didEndDisplayingSupplementaryView:(UICollectionReusableView *)view forListAdapter:(IGListAdapter *)listAdapter sectionController:(IGListSectionController *)sectionController indexPath:(NSIndexPath *)indexPath;IGListDisplayHandler 内部使用了 NSCountedSet&amp;lt;IGListSectionController *&amp;gt; *visibleListSections 来记录可见的 IGListSectionController ，跟 NSMutableSet 的不同之处在于， NSCountedSet 会记录每个 Object 添加的次数。 IGListDisplayHandler 还定义了一个 NSMapTable *visibleViewObjectMap 属性，用于处理 UICollectionReusableView 跟 Object 的对应关系。_pluckObjectForView: 移除并返回 UICollectionReusableView 对应的 Object ：- (id)_pluckObjectForView:(UICollectionReusableView *)view { NSMapTable *viewObjectMap = self.visibleViewObjectMap; id object = [viewObjectMap objectForKey:view]; [viewObjectMap removeObjectForKey:view]; return object;}IGListDisplayHandler 内部的 willDisplay 代码如下：- (void)_willDisplayReusableView:(UICollectionReusableView *)view forListAdapter:(IGListAdapter *)listAdapter sectionController:(IGListSectionController *)sectionController object:(id)object indexPath:(NSIndexPath *)indexPath { [self.visibleViewObjectMap setObject:object forKey:view]; NSCountedSet *visibleListSections = self.visibleListSections; if ([visibleListSections countForObject:sectionController] == 0) { [sectionController willDisplaySectionControllerWithListAdapter:listAdapter]; [listAdapter.delegate listAdapter:listAdapter willDisplayObject:object atIndex:indexPath.section]; } [visibleListSections addObject:sectionController];}在 willDisplay 的处理中，如果 countForObject 为 0 则表示该 sectionController 即将要进入屏幕，随后调用 sectionController 和 listAdapter.delegate 的方法。然后可以看到调用 [visibleListSections addObject:] 添加对应的 sectionController ，由于 visibleListSections 是 NSCountedSet ，所以会记录 sectionController 的次数，可以配合后续的 didEndingDisplay 操作。- (void)_didEndDisplayingReusableView:(UICollectionReusableView *)view forListAdapter:(IGListAdapter *)listAdapter sectionController:(IGListSectionController *)sectionController object:(id)object indexPath:(NSIndexPath *)indexPath { if (object == nil || sectionController == nil) { return; } const NSInteger section = indexPath.section; NSCountedSet *visibleSections = self.visibleListSections; [visibleSections removeObject:sectionController]; if ([visibleSections countForObject:sectionController] == 0) { [sectionController didEndDisplayingSectionControllerWithListAdapter:listAdapter]; [listAdapter.delegate listAdapter:listAdapter didEndDisplayingObject:object atIndex:section]; }}可以看到在 didEndDisplaying 时， visibleSections 每次 removeObject:sectionController 都会使得 sectionController 的计数减一，只有当计数为 0 时才调用 sectionController 和 listAdapter.delegate 对应的方法。IGListDisplayHandler 的内部实现为 willDisplay/didEndDisplaying 提供了两个层级的入口： IGListAdapter 级别，通过设置 adapter 的 id &amp;lt;IGListAdapterDelegate&amp;gt; delegate ，可以获取整个 UICollectionView 的回调； IGListSectionController ，通过设置 id &amp;lt;IGListDisplayDelegate&amp;gt; displayDelegate ，可以获取具体到某个 sectionController 的回调。也支持设置 displayDelegate 为 IGListSectionController 它自己，由于 IGListSectionController 跟 Object 是绑定的，所以在处理不同的 ViewController 中相同的 Object 时，我们不仅可以复用 IGListSectionController ，也可以复用 displayDelegate 的配置，进行一些曝光时长的统一配置。总结可以看到 IGListSectionController 作为 IGListKit 的基石，直接和数据层进行绑定，而且 IGListKit 还通过 IGListSectionController 进行各种扩展，支持以下特性： 支持范型特性，设置指定的数据类型； 支持快捷只显示单个 Cell 的 Section ； 支持数据流绑定， Section 内根据不同的数据刷新不同的 Cell ； 支持预处理，预处理的范围也可以进行设置； 支持设置显示时的相关回调，且可以基于 IGListSectionController 的层级进行操作。" }, { "title": "IGListKit - 开篇", "url": "/posts/iglistkit-first/", "categories": "", "tags": "源码解析", "date": "2020-11-30 16:02:00 +0800", "snippet": "UICollectionView/UITableView作为一个 iOS 开发者，在日常开发中少不了与 UITableView/UICollectionView 打交道。因为复用池的存在，即使在处理大量数据的情况下，它们仍能保持较低的内存占用，而简单的 DataSource/Delegate 设计方式，可以让我们只需要几行代码就可以完成对 UITableView/UICollectionView 数据和交互的相关配置。由于 UITableView 对界面布局的限制，你无法在 UITableView 中自定义布局，比如瀑布流之类的样式。于是苹果在 iOS6.0 中推出了 UICollectionView ， Steipete 为了支持更老旧的系统，自己写了个 PSTCollectionView ，通过这个框架可以大致了解 UICollectionView 的内部实现。虽然 UICollectionView 通过把 Layout 抽出来的方式以提供自定义布局，但是在处理数据时本质上和 UITableView 还是相同的。日常使用 UICollectionView/UITableView 时都会遇到下面几个问题： 复用流程。如果想在 UITableView/UICollectionView 中复用 Cell ，那么你需要先调用register(_:forCellReuseIdentifier:) 注册对应的 Cell 类型，然后在对应的方法中调用 dequeueReusableCell(withIdentifier:) 从复用池中取出或者生成一个新的 Cell 来使用。如果在获取 Cell 前忘记调用 register 进行注册，那么你就会收获一个应用崩溃，至于为什么需要先进行注册， register(_:forCellReuseIdentifier:) 有简单说明； 不支持 diff 。在数据源变化时我们需要更新对应的界面，而苹果本身并没提供一套相关的 API 给我们计算相关的删除，插入或者更新的位置（ indexPath ），我们需要自己去计算，找出更新的数据源，然后删除，插入或者更新对应的 Cell 。在大多数情况下，由于有复用机制的存在，我们直接使用 reloadData 也不会有什么问题，复用机制使得在 reloadData 时只会对显示在屏幕上的 Cell 进行处理，需要处理视图数量并不多，但是应该有更好的办法来支持 diff ，不是么？（ PS ：苹果在 WWDC19 上推出 Diffable Data Source 功能，支持局部刷新）； 模块的隔离。在界面变得复杂时，我们需要处理数据的获取，处理 Cell 的配置，处理埋点统计之类的功能，对于这些模块的隔离，系统本身的框架并没有提供这么一套东西给我们，所以很多时候会写在 ViewController 里，于是变成了 Massive View Controller 。如果自行设计一套方案，很容易弄出一套不但使用起来非常难受，而且还难以迁移的框架。IGListKitIGListKit 是 Instagram 推出的一套数据驱动的 UICollectionView 框架，以此来创建快速灵活的列表界面，为什么选择 UICollectionView 而不是 UITableView ，因为 UICollectionView 支持自定义布局，比 UITableView 更加灵活。 IGListKit 的主要特性如下： 不再需要调用 performBatchUpdates(_:, completion:) 或者 reloadData() ； 更好的架构以复用 Cell 和组件； 支持多种数据类型； 与 diff 算法解耦； 全面的单元测试； 支持对自己的数据模型进行自定义 diff 操作； 使用 UICollectionView 更加简单； 可扩展的 API ； 使用 Objective-C 编写，同时完全支持 Swift 。IGListKit 的数据处理流程如下：数据经由 Adapter 进行处理后转给对应的 SectionController ，而 SectionController 则会根据不同的数据类型来返回不同的 Cell 。整个过程中， UIViewController 只和 Adapter 和 Updater 进行交互，并根据不同的数据类型返回不同的 SectionController 。而对于 Cell 的处理则完全交给 SectionController 来进行，这一步的好处是使得 SectionController 可以进行复用，扩大复用粒度，同时 SectionController 的复用粒度也是比较合适的。因为我们可能需要对不同的 UIViewController 进行配置，但是有很大可能它们的 Cell 显示方式都是相同，只是其它一些逻辑或者 UI 不同。我们也可以经由 SectionController 进行组装，合成不同的界面。使用 IGListKit 时，创建一个列表界面就会变得非常容易。首先我们需要创建一个 IGListSectionController 的子类，需要重写的方法有两个： cellForItemAtIndex: ； sizeForItemAtIndex: 。下面以 LabelSectionController 为例子进行说明：class LabelSectionController: ListSectionController { override func sizeForItem(at index: Int) -&amp;gt; CGSize { return CGSize(width: collectionContext!.containerSize.width, height: 55) } override func cellForItem(at index: Int) -&amp;gt; UICollectionViewCell { return collectionContext!.dequeueReusableCell(of: MyCell.self, for: self, at: index) }}可以看到 Cell 的配置和数据的处理都交给了 SectionController 来进行。完成 LabelSectionController 的配置后，需要在 UIViewController 或者其它什么地方把各个模块串联起来：let layout = UICollectionViewFlowLayout()let collectionView = UICollectionView(frame: .zero, collectionViewLayout: layout)let updater = ListAdapterUpdater()let adapter = ListAdapter(updater: updater, viewController: self)adapter.collectionView = collectionView可以看到 UICollectionView 设置布局 Layout 部分没有变动，但是使用了 IGListAdapter 和 IGListAdapterUpdater 将 UIViewController 和 UICollectionView 串起来。这里使用了默认的 UICollectionViewFlowLayout 和 IGListAdapterUpdater ，你也可以配置自定义的类来使用一些高级特性。跟 UICollectionView 类似，需要给 adapter 设置 dataSource ：adapter.dataSource = self// IGListAdapterDataSource 相关方法func objects(for listAdapter: ListAdapter) -&amp;gt; [ListDiffable] { // this can be anything! return [ &quot;Foo&quot;, &quot;Bar&quot;, 42, &quot;Biz&quot; ]}func listAdapter(_ listAdapter: ListAdapter, sectionControllerFor object: Any) -&amp;gt; ListSectionController { if object is String { return LabelSectionController() } else { return NumberSectionController() }}func emptyView(for listAdapter: ListAdapter) -&amp;gt; UIView? { return nil}你可以返回任何数据类型，只要它们支持 IGListDiffable 协议就可以了。不可变返回的数据应该是不可变的。如果你返回可变的对象且你会对它们进行编辑， IGListKit 就无法正确地计算出它们之间的差异。这是因为对象已经发生了改变。因此，该对象的改动就会丢失掉。你可以返回一个新的，不可变的对象，而且支持了 IGListDiffable 协议。IGListKit 的基本用法和大概架构已经介绍完毕，更详细的介绍可以看官方文档： IGListKit Reference ，后续会对源码进行解析。" }, { "title": "《 Web 性能权威指南》阅读笔记 - 无线网络性能", "url": "/posts/high-performance-browser-networking-third/", "categories": "", "tags": "阅读笔记, Network", "date": "2020-11-02 17:56:00 +0800", "snippet": "无线网络概览无线网络的性能基础所有无线技术都有自身的约束和局限。然而，无论使用哪种无线技术，所有通信方法都有一个最大的信道容量，这个容量是由相同的底层原理决定的。香农公式： C 是信道容量，单位是 bit/s ； BW 是可用带宽，单位是 Hz ； S 是信号， N 是噪声，单位是 W 。在所有这些因素中，与数据传输速度最直接相关的就是接收端与发送端之间的可用带宽和信号强度。带宽有线网络通过线缆将网络中的各个节点连接起来，而无线电通信本质上则是一个共享媒体，它靠的是无线电波，或者专业一点讲，叫做电磁辐射。为实现通信，发送端与接收端必须事先就通信使用的频率范围达成共识，在这个频率范围内双方可以顺畅地交换信息。除了以共有频段作为信息交互的基础外，影响性能的最主要因素就是频率范围的大小（带宽）。根据香农的模型，信道的总体比特率与分配的带宽呈正比。换句话说，在其他条件等同的情况下，频率范围加倍，传输速度加倍。信号强度除了带宽之外，无线通信的第二个限制因素就是收发两端之间的信号强度，也叫信噪比（ SNR ， Signal Noise Ratio ）。本质上，信噪比衡量的是预期信号强度与背景噪声及干扰之间的比值。背景噪声越大，携带信息的信号就必须越强。任何无线网络，无论它叫什么名字，缩写是什么或者修订版本是多少，其性能归根结底都受限于几个众所周知的因素。特别是分配给它的带宽大小和收发两端的信噪比。另外，所有利用无线电的通信都：通过共享的通信媒体（无线电波）实现；在管制下使用特定频率范围；在管制下使用特定的发射功率；受限于不断变化的背景噪声和干扰；受限于所选无线技术的技术约束；受限于设备本身的限制，比如形状、电源，等等。测量现实中的无线性能任何无线网络，无论它叫什么名字，缩写是什么或者修订版本是多少，其性能归根结底都受限于几个众所周知的因素。特别是分配给它的带宽大小和收发两端的信噪比。另外，所有利用无线电的通信都： 通过共享的通信媒体（无线电波）实现； 在管制下使用特定频率范围； 在管制下使用特定的发射功率； 受限于不断变化的背景噪声和干扰； 受限于所选无线技术的技术约束； 受限于设备本身的限制，比如形状、电源，等等。Wi-FiWi-Fi 工作于免许可的ISM频段，任何人在任何地方都可以轻易部署，必要的硬件也很便宜很简单。从以太网到无线局域网802.11 无线标准主要是作为既有以太网标准（ 802.3 ）的扩展来设计的。事实上，以太网通常被称作局域网（ LAN ）标准，而802.11 标准族则相应地被称作无线局域网（ WLAN，Wireless LAN ）标准。802.3 （以太网）和 802.11 (Wi-Fi) 的数据和物理层。Wi-Fi 采用了冲突避免机制 （CSMA/CA ， Collision Avoidance ）机制，每个发送方都会在自己认为信道空闲时发送数据，以避免冲突。为此，每个Wi-Fi数据帧必须明确得到接收方的确认，以确保不发生冲突。Wi-Fi 性能与测量Wi-Fi 标准没有规定任何中央调度机制，因而对任何客户端的吞吐量和延迟都不提供保证。新的 WMM (Wi-Fi Multimedia ， Wi-Fi 多媒体）扩展支持在无线电接口中对需要的低延迟应用（语音，视频等）启用基本的 QoS (Quality of Service ，服务质量)，但是能识别的路由器和客户端都比较少，而且会和附近的 Wi-Fi 网络争用共享的无线资源，这是无法避免的。 Wi-Fi 网络之所以无处不在，主要原因就是它部署简单，而正因为部署简单，才会带来当前的性能问题。事实上，在城市繁华地段或者写字楼中，数十个 Wi-Fi 网络重叠的现象并不罕见：2.4 GHz 和 5 GHz 的 Wi-Fi 重叠。 多个 Wi-Fi 路由器共享带宽导致性能问题； 从客户端到 Wi-Fi 接入点的第一跳需要多长时间没有保证；如果你积极地采用新技术，那很可能显著提升 Wi-Fi 网络的性能。新的 802.11n 和 802.11ac 标准使用 5 GHz 频段，不仅拓宽了频率范围，而且能保证在多数环境下不发生冲突。 换句话说，至少在目前，如果你附近没有什么（像你一样的）技术大牛，那么一台双频路由器（支持 2.4GHz 和 5 GHz ）既能兼容 2.4 GHz 的老客户端，也能为支持 5 GHz 的客户端提供更好的性能。Wi-Fi 性能的重要因素： 不保证用户的带宽和延迟时间； 信噪比不同，带宽也随之不同； 发射功率被限制在200 mW以内； i在2.4 GHz和较新的5 GHz频段中的频谱有限； 信道分配决定了接入点信号会重叠； 接入点与客户端争用同一个无线信道。所有 Wi-Fi 协议的数据和物理层实现都有自己的重发和纠错机制，这些机制向上层隐藏了重发操作。事实上，在 802.11n 之前， Wi-Fi 协议只允许同一时刻传输一个数据帧，这一帧必须得到链路层的确认才能继续发送下一帧。 802.11n 则引入了新的“帧聚合”功能，从而支持同时发送和确认多个 Wi-Fi 数据帧。除了直观的丢包问题， Wi-Fi 网络更突出的问题则是分组到达时间差异极大，这一切都要归咎于数据链路层和物理层的冲突及重发。针对 Wi-Fi 的优化建议多使用不计流量的宽带网络，而不是 3G/4G 根据变化的带宽调整资源，如视频清晰度适应可变的延迟时间，有时候使用提供不可靠UDP传输的WebRTC倒不失为一个明智的选择。当然，传输方式的切换不能挽救无线网络，但却有助于降低协议和应用导致的延迟时间移动网络G字号移动网络简介每一代无线技术都以其峰值频谱效率（ bps/Hz ）为标志，为了让用户更直观地理解，这个效率会转换成数据传输速率，比如 4G 网络的传输速率以 Gbit/s 来衡量。无论什么标准，每种网络真实的性能都会因提供商以及他们对网络的配置、每个小区内活跃用户的数量、特定位置的无线环境、使用的设备，以及影响无线性能的其他因素而异。最早提供数据服务的 2G1991年，芬兰基于新兴的 GSM （ Global System for Mobile communications ，全球移动通信系统）标准建设了第一个2G网络，最早在无线电网络中引入了数字信令。直到1990年代中期，GPRS （ General Packet Radio Service ，通用无线分组业务）被引入 GSM 标准，无线互联网才真正走向实用。3GPP 与 3GPP23GPP （ 3rd Generation Partnership Project ，第三代合作伙伴项目）负责制定 UMTS （ Universal Mobile TelecommunicationSystem ，通用移动通信系统），这是 3G 技术与 GSM 技术结合的产物。这个项目后来也负责维护 GSM 标准和制定新的LTE标准。3GPP2 （ 3rd Generation Partnership Project 2 ）负责基于 CDMA2000 ，也就是高通制定的 IS-95 标准的后续技术制定 3G 规范3G 网络存在两个主导且互不兼容的标准： UMTS 和 CDMA ，分别由 3GPP 和 3GPP2 制定。这两种标准同时也有自己的过渡性版本，通常被称为 3.5G， 3.75G 和 3.9G 。由于制定一个新标准需要很长时间，更重要的是，建设新网络需要巨额投资， 4G 的无线电接口及基础设备完全不同于 3G ，也为了很多购买了 3G 设备的用户的利益。因此 3GPP 和 3GPP2 一直在既有的 3G 标准基础上改进。3G 技术演进网络运营商和网络提供商一致认可 3GPP LTE 是各种网络共同的下一代4G标准。因此，很多 CDMA 网络运营商也率先投资建设了早期的 LTE 基础设施，以便在某种程度上保持对演进中的 HSPA+ 的竞争力。换句话说，世界上的大多数移动运营商将把 HSPA+ 和 LTE 作为未来的移动无线标准。不用紧张，这应该是件好事。现有的 2G 和 3～3.75G 技术仍然是当前移动无线网络的主体，更重要的，它们至少还会继续为我们服务10年。《Web 性能权威指南》写于 2013 年，现在是 2020 年，就中国地区来说 2G/3G 已经基本上被 4G 替代了， 5G 也在大力推广中。苹果也出了自己的第一代 5G手机— iPhone 12 。但是个人来说目前来说还看不到 5G 对于普通用户来说有多大的提升，或许等到 7 年以后又是另外一番景象吧。IMT-Advanced 的 4G 要求4G 背后是一组具体要求（ IMT-Advanced ），这组要求是 ITU 在 2008 年就制定和公布了的。任何达到这些要求的技术，都可以看作是 4G 技术。 IMT-Advanced 的部分要求举例如下： 以 IP 分组交换网络为基础； 与之前的无线标准（ 3G 和 2G ）兼容； 移动客户端的速率达到 100 Mbit/s ，静止时的速率达到 Gbit/s 以上； 100 ms 控制面延迟， 10 ms 用户面延迟； 资源在用户间动态分配和共享； 可变带宽分配， 5～20 Mhz 。长期演进（ LTE ）LTE （ Long Term Evolution ）标准： 核心网络全部为 IP 分组交换网； 简化了网络架构，降低建设成本； 用户面和控制面的低延迟时间（分别为 &amp;lt;10 ms 和 &amp;lt;100 ms ）； 新无线接口及调制算法实现了高吞吐量（ 100Mbit/s ）； 可用于较大的带宽配置及运营商集群；要求所有设备支持 MIMO 。由于其无线及核心网络的实现的差异， LTE 网络不是对已有 3G 基础设备的简单升级。相反， LTE 网络必须与现有 3G 基础设备并行部署，并采用不同的频率范围。不过，由于LTE是 UMTS 和 CDMA 的共同后继版本，因此它也提供了一种兼容二者的机制。由此， LTE 用户可以无缝切换到 3G 网络，并在 LTE 基础设施就绪后再迁移过来。为多代并存的未来规划首先，无线标准发展很快，但这些网络的物理设施建设则既要花钱又得花时间。将来，如果这些网络部署完成，那势必还要投入很多时间维护以收回成本，保证服务品质。换句话说，尽管市场上对 4G 的宣传炒作沸沸扬扬，老一代网络至少还得服务社会十年以上。所以，在创建移动 Web 应用时，应该考虑这一点。在面向移动网络构建应用时，不能只考虑一种网络，更不能寄希望于特定的吞吐量或延迟时间。前面已经介绍过，任何网络的实际性能都具有高度可变性，取决于部署的版本、基础设施、无线条件，以及其他众多的因素。我们的应用要能适应不断变化的条件，吞吐量、延迟时间，甚至无线连接的有无，都可能变化。设备特性及能力经常被人忘记的一个事实，就是现有无线网络只是问题的一半。另一半当然是来自不同厂商的设备，以及它们的上市时间，这些设备各有各的特点。比如，CPU速度和核心数量、内存大小、存储能力、有无 GPU 等。这些因素中的任何一个都会影响设备以及运行于其上的应用的整体性能。无线电资源控制器 （ RRC ）3G和4G网络都有一个独特的装置，这个装置在有线网甚至Wi-Fi中都是不存在的。这个装置就是无线电资源控制器（RRC，Radio ResourceController ）。RRC负责调度协调移动设备与无线电基站之间所有的通信连接。 RRC 直接影响延迟、吞吐量和设备电池的使用时间。移动网络的优化建议节约用电移动网络的性能与电池使用时间天生联系在一起。而且，为了节约用电，无线接口的物理层还专门针对如下限制（或事实）做出了优化： 全功率打开无线电模块只消几小时就可耗尽电量； 对无线电功率的需求随着无线标准演进与代俱增； 无线电模块的耗电量仅次于设备的屏幕； 数据传输时无线电通信的耗电过程是非线性的。 消除周期性及无效的数据 轮询在移动网络中代价极高，少用； 尽可能使用推送和通知； 出站和入站请求应该合并和汇总； 非关键性请求应该推迟到无线模块活动时进行； 消除不必要的长链接。一般来说，推送比轮询效果更好。但频率过高的推送与轮询也不相上下。如果碰到实时更新的需求，应该考虑下列问题： 最佳更新间隔多长，是否符合用户预期？ 除了固定的更新间隔，能否因地因时制宜？ 入站或出站请求能否集合为更少的网络调用？ 入站或出站请求能否推迟到以后发送？ 预测网络延迟上限 在移动网络中，一个 HTTP 请求很可能会导致一连串长达几百甚至上几千毫秒的网络延迟。这一方面是因为有往返延迟，另一方面也不能忘记 DNS 、 TCP 、 TLS 及控制面的延迟。一个 HTTP 请求的构成： 一个 HTTP 请求的延迟：解耦用户交互与网络通信：设计得好的应用，即便底层连接慢或者请求时间长，通过在UI中提供即时反馈也能让人觉得速度快。不要把用户交互与网络通信联系得太过紧密。为给用户最佳体验，应用必须在几百毫秒内响应输入。面对多网络接口并存的现实用户不喜欢速度慢的应用，但由于短暂网络错误导致的应用崩溃才是体验最差的。我们的移动应用必须足以应对各种常见的网络错误：无法访问的主机、吞吐量突然下降或延迟突然上升，甚至连接彻底断开。与有线网络不同，你不能假定一次连接成功就能持续保持连接状态。用户可能正在移动，可能进入了高冲突、用户多，或者信号差的区域。 不要缓存或试图猜测网络状态； 调度请求、监听并诊断错误； 瞬态错误总会发生，不可忽视，可以采取重试策略； 监听连接状态，以便采用最佳请求方式； 对重试请求采用补偿算法，不要永远循环；　 离线时，尽可能记录并在将来发送请求； 利用 HTML5 的 AppCache 和 localStorage 实现离线应用。尽量使用 Wi-Fi 网络。遵循协议和应用最佳实践。网络基础设施的分层架构有一个最大的优点，那就是把物理交付接口从传输层中抽象了出来，而传输层又把路由和数据交付从应用协议中抽象了出来。这种分离的结果就是API具有独立性，但为了取得端到端的最佳性能，我们仍然要考虑整个架构。通过重用持久连接、将服务器和数据部署到离客户端更近的地方、优化TLS部署，以及其他所有优化措施，对移动网络而言只会更加重要，因为移动网络的往返时间长，而带宽永远都很昂贵。" }, { "title": "《 Web 性能权威指南》阅读笔记-HTTP", "url": "/posts/high-performance-browser-networking-second/", "categories": "", "tags": "阅读笔记, Network", "date": "2020-10-26 20:07:00 +0800", "snippet": "HTTP 简史HTTP （ HyperText Transfer Protocol ，超文本传输协议）是互联网上最普遍采用的一种应用协议，也是客户端与服务器之间的共用语言，是现代 Web 的基础。从最初的一个关键字和文档路径开始， HTTP 最终不仅成为了浏览器的协议，而且也几乎成为了所有互联网软件和硬件应用的协议。HTTP 0.9 ：只有一行的协议Tim Berners-Lee 最初的 HTTP 建议是以简洁为出发点设计的，目的是推动他的另一个刚刚萌芽的思想——万维网的应用。事实证明，这个策略非常有效。这个经验也非常值得有抱负的协议设计者汲取。Tim Berners-Lee 概述了这个新协议的动机，并罗列了几条宏观的设计目标：支持文件传输、能够请求对超文本文档的索引搜索、格式化协商机制，以及能够把客户端引导至不同的服务器。为了实际验证这个理论，他构建了一个简单的原型，实现了建议的部分功能： 客户端请求是一个 ASCII 字符串； 客户端请求由一个回车符（ CRLF ）结尾； 服务器响应是一个 ASCII 字符流； 服务器响应的是一种超文本标记语言（ HTML ）； 连接在文档传输完毕后断开。HTTP 1.0 ：迅速发展及参考性 RFCHTTP 1.0的变化： 请求可以由于多行首部字段构成； 响应对象前面添加了一个响应状态行； 响应对象也有自己的由换行符分隔的首部字段； 响应对象不局限于超文本； 服务器与客户端之间的连接在每次请求之后都会关闭。请求和响应首部都使用ASCII编码，但响应对象本身可以是任何类型：HTML文件、纯文本文件、图片，或其他内容类型。除了媒体类型协商， RFC 还解释了很多已经被实现的其他功能：内容编码、字符集支持、多部分类型、认证、缓存、代理行为、日期格式，等等。HTTP 1.1 ：互联网标准HTTP 1.1 标准厘清了之前版本中很多有歧义的地方，而且还加入了很多重要的性能优化：持久连接、分块编码传输、字节范围请求、增强的缓存机制、传输编码及请求管道。此外， HTTP 1.1 协议添加了内容、编码、字符集，甚至语言的协商机制，还添加了传输编码、缓存指令、客户端 cookie 等十几个可以每次请求都协商的字段。HTTP 2.0 ：改进传输性能曾经以简单的理念开始，只有一行的用于取得超文本的协议，迅速发展为通用的超媒体传输机制。十几年后的今天，HTTP已经成为可以在任何领域使用的核心协议。无所不在的支持这个协议的服务器，以及随处可见的访问这些服务器的客户端，都意味着在 HTTP 之上，人们正在设计和部署更多的应用。Web 性能要点宏观上的 Web 性能优化： 延迟和带宽对 Web 性能的影响； 传输协议（ TCP ）对 HTTP 的限制； HTTP 协议自身的功能和缺陷； Web 应用的发展趋势及性能需求； 浏览器局限性和优化思路。HTTP 0.9 会话由一个文档请求构成，这对于取得超文本内容完全够用了：一个文档、一个 TCP 连接，然后关闭连接。因此，提升性能就是围绕短期 TCP 连接优化一次 HTTP 请求。富媒体网页的出现改变了这个局面，因为一个简单的文档，变成了文档加依赖资源。因此， HTTP 1.0 引入了 HTTP 元数据的表示法（首部）， HTTP 1.1 又加入了各种旨在提升性能的机制，如缓存、持久连接，等等。事实上，多 TCP 连接目前仍然存在，性能的关键指标已经从文档加载时间，变成了页面加载时间，常简写为 PLT （ Page Load Time ）。 PLT 的简单定义就是：“浏览器中的加载旋转图标停止旋转的时间。”更技术的定义则是浏览器中的 onload 事件，这个事件由浏览器在文档及其所有依赖资源（ JavaScript 、图片，等等）下载完毕时触发。小资源受限于延迟，大资源（如视频）受限于带宽。大多数 HTTP 数据流都是小型突发性数据流，而TCP则是为持久连接和大块数据传输而进行过优化的。网络往返时间在大多数情况下都是 TCP 吞吐量和性能的限制因素。HTTP 1.x改进 HTTP 的性能是 HTTP 1.1 工作组的一个重要目标，后来这个版本也引入了大量增强性能的重要特性，其中一些大家比较熟知的有： 持久化连接以支持连接重用； 分块传输编码以支持流式响应； 请求管道以支持并行请求处理； 字节服务以支持基于范围的资源请求； 改进的更好的缓存机制。优化规则： 减少 DNS 查询每次域名解析都需要一次网络往返，增加请求的延迟，在查询期间会阻塞请求。减少 HTTP 请求任何请求都不如没有请求更快，因此要去掉页面上没有必要的资源。 使用 CDN 从地理上把数据放到接近客户端的地方，可以显著减少每次 TCP 连接的网络延迟，增加吞吐量。 添加 Expires 首部并配置 ETag 标签相关资源应该缓存，以避免重复请求每个页面中相同的资源。 Expires 首部可用于指定缓存时间，在这个时间内可以直接从缓存取得资源，完全避免 HTTP 请求。 ETag 及 Last-Modified 首部提供了一个与缓存相关的机制，相当于最后一次更新的指纹或时间戳。 Gzip 资源，所有文本资源都应该使用 Gzip 压缩，然后再在客户端与服务器间传输。一般来说， Gzip 可以减少 60%～80% 的文件大小，也是一个相对简单（只要在服务器上配置一个选项），但优化效果较好的举措。 避免 HTTP 重定向， HTTP重定向极其耗时，特别是把客户端定向到一个完全不同的域名的情况下，还会导致额外的 DNS 查询、 TCP 连接延迟，等等。两个根本的方面： 消除和减少不必要的网络延迟； 把传输的字节数降到最少。 持久链接的优点HTTP 1.1 的一个主要改进就是引入了持久 HTTP 连接。由一个新 TCP 连接发送的 HTTP 请求所花的总时间，最少等于两次网络往返的时间：一次用于握手，一次用于请求和响应。这是所有非持久 HTTP 会话都要付出的固定时间成本。添加对 HTTP 持久连接的支持，就可以避免第二次 TCP 连接时的三次握手、消除另一次 TCP 慢启动的往返，节约整整一次网络延迟。TCP 连接要发送 N 次 HTTP 请求，这时：没有持久连接，每次请求都会导致两次往返延迟；有持久连接，只有第一次请求会导致两次往返延迟，后续请求只会导致一次往返延迟。在启用持久连接的情况下， N 次请求节省的总延迟时间就是（ N-1 ） × RTT 。HTTP 管道持久 HTTP 可以让我们重用已有的连接来完成多次应用请求，但多次请求必须严格满足先进先出（ FIFO ）的队列顺序：发送请求，等待响应完成，再发送客户端队列中的下一个请求。 HTTP 管道是一个很小但对上述工作流却非常重要的一次优化。管道可以让我们把 FIFO 队列从客户端（请求队列）迁移到服务器（响应队列）。通过尽早分派请求，不被每次响应阻塞，可以再次消除额外的网络往返。这样，就从非持久连接状态下的每个请求两次往返，变成了整个请求队列只需要两次网络往返。回顾一下上面提到的优化： 复用 TCP 链接，减少握手往返； 使用 HTTP 管道，减少两次请求间的一次往返。当延迟更高，请求更多时，上面的优化会带来更多的性能提升，节省的时间更多。因为延迟越高，往返时间更长，减少往返时间带来的收益就更高了。即使客户端同时发送了两个请求，而且 CSS 资源先准备就绪，服务器也会先发送 HTML 响应，然后再交付 CSS 。这种情况通常被称作队首阻塞，并经常导致次优化交付：不能充分利用网络连接，造成服务器缓冲开销，最终导致无法预测的客户端延迟。假如第一个请求无限期挂起，或者要花很长时间才能处理完，在 HTTP1.1 中，所有后续的请求都将被阻塞，等待它完成。由于不可能实现多路复用， HTTP 管道会导致 HTTP 服务器、代理和客户端出现很多微妙的，不见文档记载的问题： 一个慢响应就会阻塞所有后续请求； 并行处理请求时，服务器必须缓冲管道中的响应，从而占用服务器资源，如果有个响应非常大，则很容易形成服务器的受攻击面； 响应失败可能终止 TCP 连接，从而强迫客户端重新发送对所有后续资源的请求，导致重复处理； 由于可能存在中间代理，因此检测管道兼容性，确保可靠性很重要； 如果中间代理不支持管道，那它可能会中断连接，也可能会把所有请求串联起来。因为浏览器无法对客户端和服务器有完整的权限，所以支持管道的浏览器通常都将其作为一个高级配置选项，但大多数浏览器都会禁用它。换句话说，如果浏览器是 Web 应用的主要交付工具，那还是很难指望通过 HTTP 管道来提升性能。如果说对客户端和服务器拥有完全控制的权限，那么还是可以使用它的， iTunes 就曾经通过启用持久 HTTP 连接，以及在服务器和 iTunes 客户端内启用 HTTP 管道来达到 3 倍以上的性能提升。要在你自己的应用中启用管道，要注意如下事项： 确保 HTTP 客户端支持管道； 确保 HTTP 服务器支持管道； 应用必须处理中断的连接并恢复；应用必须处理中断请求的幂等问题； 应用必须保护自身不受出问题的代理的影响。实践中部署 HTTP 管道的最佳途径，就是在客户端和服务器间使用安全通道（ HTTPS ）。这样，就能可靠地避免那些不理解或不支持管道的中间代理的干扰。使用多个 TCP 连接由于 HTTP 1.x 不支持多路复用，浏览器只能在客户端排队所有 HTTP 请求，然后通过一个持久连接，一个接一个地发送这些请求。然而，这种方式在实践中太慢。使用多个 TCP 连接有优点也有缺点，假设每个主机最多可以打开 6 个连接： 客户端可以并行分派最多 6 个请求； 服务器可以并行处理最多 6 个请求； 第一次往返可以发送的累计分组数量（ TCP cwnd ）增长为原来的 6 倍。在没有管道的情况下，最大的请求数与打开的连接数相同。相应地， TCP 拥塞窗口也要乘以打开的连接数量，从而允许客户端绕开由 TCP 慢启动规定的分组限制。这好像是一个方便的解决方案。我们再看看这样做的代价： 更多的套接字会占用客户端、服务器以及代理的资源，包括内存缓冲区和 CPU 时钟周期； 并行 TCP 流之间竞争共享的带宽； 由于处理多个套接字，实现复杂性更高； 即使并行 TCP 流，应用的并行能力也受限制。实践中， CPU 和内存占用并非微不足道，由此会导致客户端和服务器端的资源占用量上升，运维成本提高。类似地，由于客户端实现的复杂性提高，开发成本也会提高。最后，说到应用的并行性，这种方式提供的好处还是非常有限的。这不是一个长期的方案。这不是一个完美的解决方案，今天之所以使用它，主要有三个原因： 作为绕过应用协议（ HTTP ）限制的一个权宜之计； 作为绕过 TCP 中低起始拥塞窗口的一个权宜之计； 作为让客户端绕过不能使用 TCP 窗口缩放的一个权宜之计。后面两个针对 TCP 问题可以通过升级服务器的 OS 内核来解决，但是我们没有别的办法来绕开 HTTP 1.x 的多路复用问题。所以只能采取多 TCP 流的方法。用足客户端连接的限制似乎是一个可以接受的安全问题，但对于需要实时交付数据的应用而言，这样做越来越容易造成部署上的问题。比如 WebSocket 、 Server Sent Event 和挂起 XHR ，这些会话都会占用整整一个 TCP 流，而不管有无数据传输——记住，没有多路复用一说。实际上，如果你不注意，那很可能自己对自己的应用施加 DoS 攻击。 域名分区通过手工将所有资源分散到多个子域名，就可以突破浏览器的连接限制，实现更高的并行能力，域名分区使用得越多，并行能力就越强。但是每个新主机名都要求有一次额外的 DNS 查询，每多一个套接字都会多消耗两端的一些资源，而更糟糕的是，站点作者必须手工分离这些资源，并分别把它们托管到多个主机上。如果说多出来的 TCP 流得不到充分利用，那么有可能会降低性能。域名分区是一种合理但又不完美的优化手段。请大家一定先从最小分区数目（不分区）开始，然后逐个增加分区并度量分区后对应用的影响。度量和控制协议开销每个 HTTP 请求都会携带额外 500～800 字节的 HTTP 元数据：用户代理字符串、很少改变的接收和传输首部、缓存指令，等等。这里面还没有包含 HTTP cookie 。现代应用经常通过 cookie 进行会话管理、记录个性选项或者完成分析。综合到一起，所有这些未经压缩的 HTTP 元数据经常会给每个 HTTP 请求增加几千字节的协议开销。减少要传输的首部数据（高度重复且未压缩），可以节省相当于一次往返的延迟时间，显著提升很多 Web 应用的性能。连接与拼合最快的请求是不用请求。不管使用什么协议，也不管是什么类型的应用，减少请求次数总是最好的性能优化手段。 减少协议开销。通过把文件组合成一个资源，可以消除与文件相关的协议开销。如前所述，每个文件很容易招致 KB 级未压缩数据的开销。 应用层管道，说到传输的字节，这两种技术的效果都好像是启用了 HTTP 管道：来自多个响应的数据前后相继地连接在一起，消除了额外的网络延迟。实际上，就是把管道提高了一层，置入了应用中。连接和拼合技术都属于以内容为中心的应用层优化，它们通过减少网络往返开销，可以获得明显的性能提升。可是，实现这些技术也要求额外的处理、部署和编码。连接和拼合是在 HTTP 1.x 协议限制（管道没有得到普遍支持，多请求开销大）的现实之下可行的应用层优化。使用得当的话，这两种技术可以带来明显的性能提升，代价则是增加应用的复杂度，以及导致缓存、更新、执行速度，甚至渲染页面的问题。应用这两种优化时，要注意度量结果，根据实际情况考虑如下问题。HTTP 2.0HTTP 2.0 的目的就是通过支持请求与响应的多路复用来减少延迟，通过压缩 HTTP 首部字段将协议开销降至最低，同时增加对请求优先级和服务器端推送的支持。为达成这些目标， HTTP 2.0 还会给我们带来大量其他协议层面的辅助实现，比如新的流量控制、错误处理和更新机制。 HTTP 2.0 不会改动 HTTP 的语义。 HTTP 方法、状态码、 URI 及首部字段，等等这些核心概念一如往常。但是， HTTP 2.0 修改了格式化数据（分帧）的方式，以及客户端与服务器间传输这些数据的方式。历史及其与 SPDY 的渊源SPDY 是谷歌开发的一个实验性协议，于 2009 年年中发布，其主要目标是通过解决 HTTP 1.1 中广为人知的一些性能限制，来减少网页的加载延迟。 HTTP-WG （ HTTP Working Group ）在 2012 年初把 HTTP 2.0 提到了议事日程，吸取 SPDY 的经验教训，并在此基础上制定官方标准。走向 HTTP 2.0SPDY 是 HTTP 2.0 的催化剂，它是 HTTP 2.0 的基础。之所以递增一个大版本到 2.0 ，主要是因为它改变了客户端与服务器之间交换的方式。增加了新的二进制分帧数据层，这一层不兼容之前的 HTTP 1.x 服务器及客户端——是谓 2.0 。 SPDY 其实可以算作是 HTTP 2.0 的实验室，为 HTTP 2.0 制定标准提供了事前的测试和评估手段。设计和技术目标HTTP 是应用最广泛、采用最多的一个互联网应用协议。但是简单是以牺牲应用性能为代价的， HTTP 2.0 致力于提高应用性能。HTTP/2.0 通过支持首部字段压缩和在同一连接上发送多个并发消息，让应用更有效地利用网络资源，减少感知的延迟时间。而且，它还支持服务器到客户端的主动推送机制。二进制分帧层HTTP 2.0 性能增强的核心，全在于新增的二进制分帧层，它定义了如何封装 HTTP 消息并在客户端与服务器之间传输。这里所谓的“层”，指的是位于套接字接口与应用可见的高层 HTTP API 之间的一个新机制： HTTP 的语义，包括各种动词、方法、首部，都不受影响，不同的是传输期间对它们的编码方式变了。 HTTP 1.x 以换行符作为纯文本的分隔符，而 HTTP 2.0 将所有传输的信息分割为更小的消息和帧，并对它们采用二进制格式的编码。流，消息和帧 流，已建立的连接上的双向字节流。 消息，与逻辑消息对应的完整的一系列数据帧。 帧， HTTP 2.0 通信的最小单位，每个帧包含帧首部，至少也会标识出当前帧所属的流。要理解 HTTP 2.0 ，就必须理解流、消息和帧这几个基本概念。所有通信都在一个 TCP 连接上完成。流是连接中的一个虚拟信道，可以承载双向的消息；每个流都有一个唯一的整数标识符（ 1、2…N ）。消息是指逻辑上的 HTTP 消息，比如请求、响应等，由一或多个帧组成。帧是最小的通信单位，承载着特定类型的数据，如 HTTP 首部、负荷，等等。简言之， HTTP 2.0 把 HTTP 协议通信的基本单位缩小为一个一个的帧，这些帧对应着逻辑流中的消息。相应地，很多流可以并行地在同一个 TCP 连接上交换消息。多向请求与响应在。HTTP 1.x 中，如果客户端想发送多个并行的请求以及改进性能，那么必须使用多个 TCP 连接。这是 HTTP1.x 交付模型的直接结果，该模型会保证每个连接每次只交付一个响应（多个响应必须排队）。更糟糕的是，这种模型也会导致队首阻塞，从而造成底层 TCP 连接的效率低下。 HTTP 2.0 中新的二进制分帧层突破了这些限制，实现了多向请求和响应：客户端和服务器可以把 HTTP 消息分解为互不依赖的帧，然后乱序发送，最后再在另一端把它们重新组合起来。图中包含了同一个连接上多个传输中的数据流：客户端正在向服务器传输一个 DATA 帧（ stream 5 ），与此同时，服务器正向客户端乱序发送 stream 1 和 stream 3 的一系列帧。此时，一个连接上有 3 个请求/响应并行交换。把 HTTP 消息分解为独立的帧，交错发送，然后在另一端重新组装是 HTTP 2.0 最重要的一项增强。分帧机制会在整个 Web 技术栈中引起 一系列连锁反应，从而带来巨大的性能提升： 可以并行交错地发送请求，请求之间互不影响； 可以并行交错地发送响应，响应之间互不干扰； 只使用一个连接即可并行发送多个请求和响应； 消除不必要的延迟，从而减少页面加载的时间； 不必再为绕过 HTTP 1.x 限制而多做很多工作。 ……总之， HTTP 2.0 的二进制分帧机制解决了 HTTP1.x 中存在的队首阻塞问题，也消除了并行处理和发送请求及响应时对多个连接的依赖。结果，就是应用速度更快、开发更简单、部署成本更低。请求优先级把 HTTP 消息分解为很多独立的帧之后，就可以通过优化这些帧的交错和传输顺序，进一步提升性能。为了做到这一点，每个流都可以带有一个 31 比特的优先值：0 表示最高优先级。2^31-1 表示最低优先级。服务器可以而且应该交错发送不同优先级别的帧。只要可能，高优先级流都应该优先，包括分配处理资源和客户端与服务器间的带宽。不过，为了最高效地利用底层连接，不同优先级的混合也是必需的。每个来源一个连接有了新的分帧机制后， HTTP 2.0 不再依赖多个 TCP 连接去实现多流并行了。现在，每个数据流都拆分成很多帧，而这些帧可以交错，还可以分别优先级。于是，所有 HTTP 2.0 连接都是持久化的，而且客户端与服务器之间也只需要一个连接即可。流量控制在同一个 TCP 连接上传输多个数据流，就意味着要共享带宽。标定数据流的优先级有助于按序交付，但只有优先级还不足以确定多个数据流或多个连接间的资源分配。为解决这个问题， HTTP2.0 为数据流和连接的流量控制提供了一个简单的机制：流量控制基于每一跳进行，而非端到端的控制；流量控制基于窗口更新帧进行，即接收方广播自己准备接收某个数据流的多少字节，以及对整个连接要接收多少字节；流量控制窗口大小通过 WINDOW_UPDATE 帧更新，这个字段指定了流 ID 和窗口大小递增值；流量控制有方向性，即接收方可能根据自己的情况为每个流乃至整个连接设置任意窗口大小；流量控制可以由接收方禁用，包括针对个别的流和针对整个连接。服务器推送HTTP 2.0 新增的一个强大的新功能，就是服务器可以对一个客户端请求发送多个响应。换句话说，除了对最初请求的响应外，服务器还可以额外向客户端推送资源，而无需客户端明确地请求。 客户端可以缓存推送过来的资源； 客户端可以拒绝推送过来的资源； 推送资源可以由不同的页面共享； 服务器可以按照优先级推送资源。首先，服务器必须遵循请求-响应的循环，只能借着对请求的响应推送资源。也就是说，服务器不能随意发起推送流。其次， PUSH_PROMISE 帧必须在返回响应之前发送，以免客户端出现竞态条件。否则，就可能出现比如这种情况：客户端请求的恰好是服务器打算推送的资源。首部压缩HTTP的每一次通信都会携带一组首部，用于描述传输的资源及其属性。在 HTTP 1.x 中，这些元数据都是以纯文本形式发送的，通常会给每个请求增加 500～800 字节的负荷。如果算上 HTTP cookie ，增加的负荷通常会达到上千字节。为减少这些开销并提升性能， HTTP 2.0 会压缩首部元数据： HTTP 2.0 在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键－值对，对于相同的数据，不再通过每次请求和响应发送； 首部表在 HTTP 2.0 的连接存续期内始终存在，由客户端和服务器共同渐进地更新; 每个新的首部键－值对要么被追加到当前表的末尾，要么替换表中之前的值。在前面的例子中，第二个请求只需要发送变化了的路径首部（ :path ），其他首部没有变化，不用再发送了。这样就可以避免传输冗余的首部，从而显著减少每个请求的开销。有效的 HTTP 2.0 升级与发现支持 HTTP 2.0 的客户端在发起新请求之前，必须能发现服务器及所有中间设备是否支持 HTTP 2.0 协议。有三种可能的情况： 通过 TLS 和 ALPN 发起新的 HTTPS 连接； 根据之前的信息发起新的 HTTP 连接； 没有之前的信息而发起新的 HTTP 连接。GET /page HTTP/1.1Host: server.example.comConnection: Upgrade, HTTP2-SettingsUpgrade: h2c // 1HTTP2-Settings: (SETTINGS payload) // 2HTTP/1.1 200 OK // 3Content-length: 243Content-type: text/html(... HTTP/1.1 response ...) (or)HTTP/1.1 101 Switching Protocols // 4Connection: UpgradeUpgrade: h2c(... HTTP/2 response ...)➊ 发起带有 HTTP 2.0 Upgrade 首部的HTTP 1.1请求➋ HTTP/2.0 SETTINGS 净荷的 Base64 URL 编码➌ 服务器拒绝升级，通过 HTTP 1.1 返回响应➍ 服务器接受 HTTP 2.0 升级，切换到新分帧使用这种 Upgrade 流，如果服务器不支持HTTP2.0，就立即返回 HTTP 1.1 响应。否则，服务器就会以 HTTP 1.1 格式返回 101 SwitchingProtocols 响应，然后立即切换到HTTP 2.0并使用新的二进制分帧协议返回响应。如果客户端因为自己保存有或通过其他手段（如 DNS 记录、手工配置等）获得了关于 HTTP 2.0 的支持信息，它也可以直接发送 HTTP2.0 分帧，而不必依赖 Upgrade 机制。有了这些信息，客户端可以一上来就通过非加密信道发送 HTTP 2.0 分帧，其他就不管了。最坏的情况，就是无法建立连接，客户端再回退一步，重新使用 Upgrade 首部，或者切换到带 ALPN 协商的 TLS 信道。二进制分帧简介HTTP 2.0 的根本改进还是新增的长度前置的二进制分帧层。与 HTTP 1.x 使用换行符分隔纯文本不同，二进制分帧层更加简洁，通过代码处理起来更简单也更有效。所有帧都共享一个 8 字节的首部，其中包含帧的长度、类型、标志，还有一个保留位和一个 31 位的流标识符。16 位的长度前缀意味着一帧大约可以携带 64 KB 数据，不包括 8 字节首部。8 位的类型字段决定如何解释帧其余部分的内容。8 位的标志字段允许不同的帧类型定义特定于帧的消息标志。1 位的保留字段始终置为 0 。31 位的流标识符唯一标识 HTTP 2.0 的流。HTTP 2.0 规定了如下帧类型：DATA ：用于传输 HTTP 消息体。HEADERS ：用于传输关于流的额外的首部字段。PRIORITY ：用于指定或重新指定引用资源的优先级。RST_STREAM ：用于通知流的非正常终止。SETTINGS ：用于通知两端通信方式的配置数据。PUSH_PROMISE ：用于发出创建流和服务器引用资源的要约。PING ：用于计算往返时间，执行“活性”检查。GOAWAY ：用于通知对端停止在当前连接中创建流。WINDOW_UPDATE ：用于针对个别流或个别连接实现流量控制。CONTINUATION ：用于继续一系列首部块片段。发起新流在发送应用数据之前，必须创建一个新流并随之发送相应的元数据，比如流优先级、 HTTP 首部等。 HTTP 2.0 协议规定客户端和服务器都可以发起新流，因此有两种可能：客户端通过发送 HEADERS 帧来发起新流，这个帧里包含带有新流 ID 的公用首部、可选的 31 位优先值，以及一组 HTTP 键－值对首部；服务器通过发送 PUSH_PROMISE 帧来发起推送流，这个帧与 HEADERS 帧等效，但它包含“要约流 ID ”，没有优先值。由于两端都可以发起新流，流计数器偏置：客户端发起的流具有偶数 ID ，服务器发起的流具有奇数 ID 。这样，两端的流 ID 不会冲突，而且各自持有一个简单的计数器，每次发起新流时递增 ID 即可。发送应用数据分为多个 DATA 帧，最后一帧翻转帧首部的 END_STREAM 字段。HTTP 2.0 帧数据流分析 有 3 个活动的流： stream 1 、 stream 3 和 stream5 。 3个流的ID都是奇数，说明都是客户端发起的。这里没有服务器发起的流。 服务器发送的 stream 1 包含多个 DATA 帧，这是对客户端之前请求的响应数据。这也说明在此之前已经发送过 HEADERS 帧了。 服务器在交错发送 stream 1 的 DATA 帧和 stream 3 的HEADERS 帧，这就是响应的多路复用。 客户端正在发送 stream 5 的DATA帧，表明 HEADERS 帧之前已经发送过了。优化应用的交付我们无法控制客户端与服务器之间的网络环境，也不能控制客户的硬件或者其手持设备的配置，但除此之外的一切就掌握在我们手里了，包括服务器上的 TCP 和 TLS 优化，以及针对不同物理层特性、不同 HTTP 协议版本和通用最佳实践的数十项应用优化。事实上，影响绝大多数Web应用性能的并非带宽，而是延迟。网速虽然越来越快，但不幸的是，延迟似乎并没有缩短：1.2 延迟的构成；1.7 目标：高宽带和低延迟；10.3.2 延迟是性能瓶颈；既然我们不能让信息跑得更快，那么关键就在于对传输层和应用层采取各种可能的优化手段，消除不必要的往返、请求，把每个分组的传输距离缩到最短——比如把服务器放到离客户更近的地方。只要对何时以及如何下载资源、信标进行简单的优化，就能显著改善用户感觉到的延迟、电池使用时间和应用的整体用户体验：6.4 针对 Wi-Fi 的优化建议；8 移动网络的优化建议；自物理层向上，接下来就是要保证任何一台服务器都要按照最新的 TCP 和 TLS 最佳实践进行配置。针对底层协议的优化能保证每个客户端在与服务器通信时，都可以获取最佳性能——高吞吐量和低延迟：2.5 针对TCP的优化建议；4.7 针对TLS的优化建议；HTTP 需要注意的地方： 我们必须想方设法地绕过 HTTP 1.x 的种种限制； 我们必须掌握利用 HTTP 2.0 性能增强的方法； 我们必须在应用经典的性能最佳实践时保持警惕。性能优化的最佳实践无论什么网络，也不管所用网络协议是什么版本，所有应用都应该致力于消除或减少不必要的网络延迟，将需要传输的数据压缩至最少。 减少 DNS 查找，每一次主机名解析都需要一次网络往返，从而增加请求的延迟时间，同时还会阻塞后续请求。 重用 TCP 连接尽可能使用持久连接，以消除 TCP 握手和慢启动延迟；参见2.2.2 “慢启动”。 减少 HTTP 重定向， HTTP 重定向极费时间，特别是不同域名之间的重定向，更加费时；这里面既有额外的 DNS 查询、 TCP 握手，还有其他延迟。最佳的重定向次数为零。 使用 CDN 把数据放到离用户地理位置更近的地方，可以显著减少每次TCP连接的网络延迟，增大吞吐量。这一条既适用于静态内容，也适用于动态内容；参见4.7.2节中的“不缓存的原始获取”。 去掉不必要的资源，任何请求都不如没有请求快。说到这，所有建议都无需解释。延迟是瓶颈，最快的速度莫过于什么也不传输。然而 HTTP 也提供了很多额外的机制，比如缓存和压缩，还有与其版本对应的一些性能技巧。 在客户端缓存资源应该缓存应用资源，从而避免每次请求都发送相同的内容。 传输压缩过的内容，传输前应该压缩应用资源，把要传输的字节减至最少：确保对每种要传输的资源采用最好的压缩手段。 消除不必要的请求开销减少请求的 HTTP 首部数据（比如 HTTP cookie ），节省的时间相当于几次往返的延迟时间。并行处理请求和响应请求和响应的排队都会导致延迟时间。 并行处理请求和响应，请求和响应的排队都会导致延迟，无论是客户端还是服务器端。这一点经常被忽视，但却会无谓地导致很长延迟。针对协议版本采取优化措施 HTTP 1.x 支持有限的并行机制，要求打包资源、跨域分散资源，等等。相对而言， HTTP 2.0 只要建立一个连接就能实现最优性能，同时无需针对 HTTP 1.x 的那些优化方法。在客户端缓存资源对于通过 HTTP 传输的资源，要保证首部包含适当的缓存字段：Cache-Control 首部用于指定缓存时间；Last-Modified 和 ETag 首部提供验证机制。HTTP Cache 本书的作者也写了篇文章来详细讲述 HTTP Cache 。压缩传输的数据对于必须要传输的资源，为保证传输的字节数最少，需要保证对它们进行最有效的压缩。文本资源经过 gzip 压缩平均可以减少 60%～80% 大小，而图片则有不同的规则： 图片一般会占到一个网页需要传输的总字节数的一半； 通过去掉不必要的元数据可以把图片文件变小； 要调整大小就在服务器上调整，避免传输不必要的字节； 应该根据图像选择最优的图片格式； 尽可能使用有损压缩； 选择正确的格式： JPEG ， WebP ， PNG ； 确定必需的大小，不要让图片超过它需要的大小。消除不必要的请求字节• 浏览器会在每个请求中自动附加关联的 cookie 数据；• 在 HTTP 1.x 中，包括 cookie 在内的所有 HTTP 首部都会在不压缩的状态下传输；• 在 HTTP 2.0 中，这些元数据经过压缩了，但开销依然不小；• 最坏的情况下，过大的 HTTP cookie 会超过初始的 TCP 拥塞窗口，从而导致多余的网络往返。应该认真对待和监控 cookie 的大小，确保只传输最低数量的元数据，比如安全会话令牌。同时，还应该利用服务器上共享的会话缓存，从中查询缓存的元数据。更好的结果，则是完全不用 cookie 。并行处理请求和响应如果不使用持久连接，则每个 HTTP 请求都要建立一个 TCP 连接。由于 TCP 握手和慢启动，多个 TCP 会造成明显的延迟。在使用 HTTP 1.1 的情况下，最好尽可能重用已有连接。如果碰上能使用 HTTP 管道的机会，不要放过。更好的选择，则是升级到 HTTP 2.0 ，从而获得最佳性能。针对 HTTP 1.x 的优化建议针对 HTTP 1.x 的优化次序很重要：首先要配置服务器以最大限度地保证 TCP 和 TLS 的性能最优，然后再谨慎地选择和采用移动及经典的应用最佳实践，之后再度量，迭代。• 利用 HTTP 管道，如果你的应用可以控制客户端和服务器这两端，那么使用管道可以显著减少网络延迟。• 采用域名分区，如果你的应用性能受限于默认的每来源 6 个连接，可以考虑将资源分散到多个来源。• 打包资源以减少 HTTP 请求，拼接和精灵图等技巧有助于降低协议开销，又能达成类似管道的性能提升。• 嵌入小资源，考虑直接在父文档中嵌入小资源，从而减少请求数量。针对 HTTP 2.0 的优化建议• 服务器的初始 cwnd 应该是 10 个分组；• 服务器应该通过 ALPN （针对 SPDY 则为 NPN ）协商支持 TLS ；• 服务器应该支持 TLS 恢复以最小化握手延迟。少发数据、削减请求，根据无线网络情况调整资源供给。不管使用什么版本的协议，减少传输的数据量和消除不必要的网络延迟，对任何应用都是最有效的优化手段。最后，杜绝和忘记域名分区、文件拼接、图片精灵等不良的习惯，这些做法在 HTTP 2.0 之上完全没有必要。事实上，继续使用这些手段反而有害。可以利用 HTTP 2.0 内置的多路分发以及服务器推送等新功能。记得去掉针对 HTTP 1.x 的优化。双协议应用策略如果应用可以同时控制服务器和客户端，那倒简单了，因为它可以决定使用什么协议。但大多数应用不能也无法控制客户端，只有采用一种混合或自动策略，以适应两种协议并存的现实。 相同的应用代码，双协议部署。 分离应用代码，双协议部署。 动态 HTTP 1.x 和 HTTP 2.0 优化。 HTTP 2.0 ，单协议部署。评估服务器质量与性能HTTP 2.0 服务器实现的质量对客户端性能影响很大。 HTTP 服务器的配置当然是一个重要因素，但服务器实现逻辑的质量同样与优先级、服务器推送、多路复用等性能机制的发挥紧密相关。 HTTP 2.0 服务器必须理解流优先级； HTTP 2.0 服务器必须根据优先级处理响应和交付资源； HTTP 2.0 服务器必须支持服务器推送； HTTP 2.0 服务器应该提供不同推送策略的实现。" }, { "title": "《 Web 性能权威指南》阅读笔记-网络技术概览", "url": "/posts/high-performance-browser-networking-first/", "categories": "", "tags": "阅读笔记, Network", "date": "2020-10-18 15:47:28 +0800", "snippet": "延迟与带宽WPO （ Web Performance Optimization ，Web性能优化）产业从无到有，快速增长，充分说明用户越来越重视速度方面的用户体验。速度是关键： 网站越快，用户的黏性越高； 网站越快，用户忠诚度更高； 网站越快，用户转化率越高。不仅限于网站，移动端也是相同的情况。延迟和带宽是影响速度的两个关键因素。延迟是 message 或 packet 从起点到终点经历的时间。这个定义简单明了，但却掩盖了很多有用的信息。事实上，任何系统都有很多因素可能影响传送消息的时间。 传播延迟：消息从发送端到接收端需要的时间，是信号传播距离和速度的函数； 传输延迟：把消息中的所有比特转移到链路中需要的时间，是消息长度和链路速率的函数； 处理延迟：处理分组首部、检查位错误及确定分组目标所需的时间； 排队延迟：到来的分组排队等待处理的时间。我们都不习惯用毫秒来度量身边的事物，但研究表明：在软件交互中，哪怕 100~200 ms 左右的延迟，我们中的大多数人就会感觉到“拖拉”；如果超过了 300ms 的门槛，那就会说“反应迟钝”；而要是延迟达到 1000 ms（ 1s ） 这个界限，很多用户就会在等待响应的时候分神，有人会想入非非，有人恨不得忙点别的什么事儿。要想给用户最佳的体验，而且保证他们全神贯注于手边的任务，我们的应用必须在几百毫秒之内响应。这几乎没有给我们——特别是网络，留出多少出错的余地。若要成功，必须认真对待网络延迟，在每个开发阶段都为它设立明确的标准。 CDN（ Content Delivery Network ，内容分发网络）服务的用途很多，但最重要的就是通过把内容部署在全球各地，让用户从最近的服务器加载内容，大幅降低传播分组的时间。或许我们不能让数据传输得更快，但我们可以缩短服务器与用户之间的距离。把数据托管到CDN能够显著提高性能。延迟中相当大的一部分往往花在了最后几公里，而不是在横跨大洋或大陆时产生的，这就是所谓的“最后一公里”问题。为了让你家或你的办公室接入互联网，本地ISP需要在附近安装多个路由收集信号，然后再将信号转发到本地的路由节点。连接类型、路由技术和部署方法五花八门，分组传输中的这前几跳往往要花数十毫秒时间才能到达ISP的主路由器。由于无法突破物理条件上的限制，也就是说无法让传播速度跑得比光速更快。如果需要针对延迟采取优化措施，就必须从设计和优化协议及应用着手，并且时刻牢记光速的限制。可以减少往返、把数据部署到接近客户端的地方，以及在开发应用时通过各种技术隐藏延迟。TCP 的构成因特网有两个核心协议：IP和TCP。 IP ，即 Internet Protocol ，负责联网主机之间的路由选择和寻址； TCP ，即 Transmission Control Protocol ，负责在不可靠的传输信道之上提供可靠的抽象层。TCP/IP 也常被称为“因特网协议套件”（ Internet Protocol Suite ），是由 Vint Cerf 和 BobKhan 在他们 1974 的论文“ A Protocol for Packet Network Intercommunication ”（一种分组网络互通的协议）中首次提出来的。TCP 负责在不可靠的传输信道之上提供可靠的抽象层，向应用层隐藏了大多数网络通信的复杂细节，比如丢包重发、按序发送、拥塞控制及避免、数据完整，等等。采用 TCP 数据流可以确保发送的所有字节能够完整地被接收到，而且到达客户端的顺序也一样。也就是说， TCP 专门为精确传送做了优化，但并未过多顾及时间。HTTP 标准并未规定 TCP 就是唯一的传输协议。如果你愿意，还可以通过 UDP （用户数据报协议）或者其他可用协议来发送 HTTP 消息。但在现实当中，由于 TCP 提供了很多有用的功能，几乎所有 HTTP 流量都是通过 TCP 传送的。三次握手客户端与服务器在交换应用数据之前，必须就起始分组序列号，以及其他一些连接相关的细节达成一致。出于安全考虑，序列号由两端随机生成。 SYN客户端选择一个随机序列号x，并发送一个SYN分组，其中可能还包括其他TCP标志和选项； SYN ACK服务器给x加1，并选择自己的一个随机序列号y，追加自己的标志和选项，然后返回响应； ACK客户端给x和y加1并发送握手期间的最后一个ACK分组。TCP 为什么需要三次握手可以看这篇文章为什么 TCP 建立连接需要三次握手 - 面向信仰编程 ，讲得非常详细。TCP 快速打开， TCP Fast Open ， Linux 3.7 及之后的内核已经在客户端和服务器中支持TFO，因此成为了客户端和服务器操作系统选型的有力候选方案。即便如此，TFO并不能解决所有问题。它虽然有助于减少三次握手的往返时间，但却只能在某些情况下有效。比如，随同SYN分组一起发送的数据净荷有最大尺寸限制、只能发送某些类型的HTTP请求，以及由于依赖加密cookie，只能应用于重复的连接。流量控制流量控制是一种预防发送端过多向接收端发送数据的机制。否则，接收端可能因为忙碌、负载重或缓冲区容量有限而无法处理。为实现流量控制，TCP连接的每一方都要通告自己的接收窗口（ rwnd ），其中包含能够保存数据的缓冲区空间大小信息。第一次建立连接时，两端都会使用自身系统的默认设置来发送 rwnd 。浏览网页通常主要是从服务器向客户端下载数据，因此客户端窗口更可能成为瓶颈。然而，如果是在上传图片或视频，即客户端向服务器传送大量数据时，服务器的接收窗口又可能成为制约因素。假如窗口为零，则意味着必须由应用层先清空缓冲区，才能再接收剩余数据。这个过程贯穿于每个TCP连接的整个生命周期：每个ACK分组都会携带相应的最新rwnd值，以便两端动态调整数据流速，使之适应发送端和接收端的容量及处理能力。慢启动流量控制确实可以防止发送端向接收端过多发送数据，但却没有机制预防任何一端向潜在网络过多发送数据。换句话说，发送端和接收端在连接建立之初，谁也不知道可用带宽是多少，因此需要一个估算机制，然后还要根据网络中不断变化的条件而动态改变速度。1988年， Van Jacobson 和 Michael J. Karels 撰文描述了解决这个问题的几种算法：慢启动、拥塞预防、快速重发和快速恢复。这4种算法很快被写进了 TCP 规范。事实上，正是由于这几种算法加入 TCP ，才让因特网在20世纪80年代末到90年代初流量暴增时免于大崩溃。根据交换数据来估算客户端与服务器之间的可用带宽是唯一的方法，而且这也是慢启动算法的设计思路。首先，服务器通过 TCP 连接初始化一个新的拥塞窗口（ cwnd ）变量，将其值设置为一个系统设定的保守值（在 Linux 中就是 initcwnd ）。• 拥塞窗口大小（ cwnd ）:  发送端对从客户端接收确认（ ACK ）之前可以发送数据量的限制。新TCP连接传输的最大数据量取 rwnd 和 cwnd 中的最小值，而服务器实际上可以向客户端发送4个 TCP 段，然后就必须停下来等待确认。此后，每收到一个 ACK ，慢启动算法就会告诉服务器可以将它的 cwnd 窗口增加1个 TCP 段。每次收到 ACK 后，都可以多发送两个新的分组。 TCP 连接的这个阶段通常被称为“指数增长”阶段，因为客户端和服务器都在向两者之间网络路径的有效带宽迅速靠拢。包括HTTP在内的很多应用层协议都运行在TCP之上，无论带宽多大，每个TCP连接都必须经过慢启动阶段。换句话说，我们不可能一上来就完全利用连接的最大带宽。相反，我们要从一个相对较小的拥塞窗口开始，每次往返都令其翻倍（指数式增长）。而达到某个目标吞吐量所需的时间，就是客户端与服务器之间的往返时间和初始拥塞窗口大小的函数。下面我们就来看一个例子，假设： 客户端和服务器的接收窗口为 65 535 字节（ 64 KB ）； 初始的拥塞窗口：4 段（ RFC 2581 ）； 往返时间是 56 ms（伦敦到纽约）；先不管 64 KB 的接收窗口，新 TCP 连接的吞吐量一开始是受拥塞窗口初始值限制的。计算可知，要达到 64 KB 的限制，需要把拥塞窗口大小增加到 45 段，而这需要 224 ms ：慢启动导致客户端与服务器之间经过几百毫秒才能达到接近最大速度的问题，对于大型流式下载服务的影响倒不显著，因为慢启动的时间可以分摊到整个传输周期内消化掉。可是，对于很多HTTP连接，特别是一些短暂、突发的连接而言，常常会出现还没有达到最大窗口请求就被终止的情况。换句话说，很多Web应用的性能经常受到服务器与客户端之间往返时间的制约。因为慢启动限制了可用的吞吐量，而这对于小文件传输非常不利。为演示三次握手和慢启动对简单HTTP传输的影响，我们假设纽约的客户端需要通过TCP连接向伦敦的服务器请求一个 20 KB 的文件，下面列出了连接的参数： 往返时间： 56 ms ； 客户端到服务器的带宽： 5 Mbps ； 客户端和服务器接收窗口： 65 535 字节； 初始的拥塞窗口： 4段（ 4×1460 字节 ≈ 5.7 KB ）； 服务器生成响应的处理时间：40 ms ； 没有分组丢失、每个分组都要确认、GET请求只占1段。 0 ms：客户端发送 SYN 分组开始 TCP 握手。 28 ms：服务器响应 SYN-ACK 并指定其 rwnd 大小。 56 ms：客户端确认 SYN-ACK ，指定其 rwnd 大小，并立即发送 HTTP GET 请求。 84 ms：服务器收到HTTP请求。 124 ms：服务器生成20 KB的响应，并发送 4 个TCP段（初始 cwnd 大小为4），然后等待 ACK 。 152 ms：客户端收到 4 个段，并分别发送A CK 确认。 180 ms：服务器针对每个 ACK 递增 cwnd ，然后发送 8 个 TCP 段。 208 ms：客户端接收 8 个段，并分别发送 ACK 确认。 236 ms：服务器针对每个 ACK 递增 cwnd ，然后发送剩余的 TCP 段。 264 ms：客户端收到剩余的 TCP 段，并分别发送 ACK 确认。如果将 cwnd 值设置为 10 个 TCP 段，那么上图所示的过程将减少一次往返，性能可以提升22%。通过新 TCP 连接在往返时间为 56 ms 的客户端与服务器间传输一个20 KB的文件需要 264 ms ，作为对比，现在假设客户端可以重用同一个 TCP 连接，再发送一次相同的请求。 0 ms：客户端发送 HTTP 请求。 28 ms：服务器收到 HTTP 请求。 68 ms：服务器生成 20 KB 响应，但cwnd已经大于发送文件所需的 15 段了，因此一次性发送所有数据段。 96 ms：客户端收到所有 15 个段，分别发送 ACK 确认。同一个连接、同样的请求，但没有三次握手和慢启动，只花了 96 ms ，性能提升幅度达 275% 。以上两种情况下，服务器和客户端之间的 5 Mbps 带宽并不影响 TCP 连接的启动阶段。此时，延迟和拥塞窗口大小才是限制因素。拥塞预防认识到 TCP 调节性能主要依赖丢包反馈机制非常重要。换句话说，这不是一个假设命题，而是一个具体何时发生的命题。慢启动以保守的窗口初始化连接，随后的每次往返都会成倍提高传输的数据量，直到超过接收端的流量控制窗口，即系统配置的拥塞阈值（ ssthresh ）窗口，或者有分组丢失为止，此时拥塞预防算法介入。拥塞预防算法把丢包作为网络拥塞的标志，即路径中某个连接或路由器已经拥堵了，以至于必须采取删包措施。因此，必须调整窗口大小，以避免造成更多的包丢失，从而保证网络畅通。带宽延迟积发送端和接收端理想的窗口大小，一定会因往返时间及目标传输速率而变化。发送端和接收端之间在途未确认的最大数据量，取决于拥塞窗口（ cwnd ）和接收窗口（ rwnd ）的最小值。接收窗口会随每次 ACK 一起发送，而拥塞窗口则由发送端根据拥塞控制和预防算法动态调整。无论发送端发送的数据还是接收端接收的数据超过了未确认的最大数据量，都必须停下来等待另一方ACK确认某些分组才能继续。等待时间取决于往返时间。BDP （ Bandwidth-delay product ，带宽延迟积）数据链路的容量与其端到端延迟的乘积。这个结果就是任意时刻处于在途未确认状态的最大数据量。拥塞窗口和接收窗口会限制吞吐量，不管发送端和接收端的实际带宽为多大。好在窗口大小的协商与调节由网络栈自动控制，应该会自动调整。但尽管如此，窗口大小有时候仍然是TCP性能的限制因素。如果你怎么也想不通在高速连接的客户端与服务器之间，实际传输速度只有可用带宽的几分之一，那窗口大小很可能就是罪魁祸首。要么因为某一饱和端通告的接收窗口很小，要么因为网络拥堵和丢包导致拥塞窗口重置，更可能因为流量增长过快导致对连接吞吐量施加了限制。队首阻塞每个 TCP 分组都会带着一个唯一的序列号被发出，而所有分组必须按顺序传送到接收端。如果中途有一个分组没能到达接收端，那么后续分组必须保存在接收端的 TCP 缓冲区，等待丢失的分组重发并到达接收端。这一切都发生在 TCP 层，应用程序对 TCP 重发和缓冲区中排队的分组一无所知，必须等待分组全部到达才能访问数据。在此之前，应用程序只能在通过套接字读数据时感觉到延迟交付。这种效应称为TCP的队首（ HOL，Head of Line ）阻塞。队首阻塞造成的延迟可以让我们的应用程序不用关心分组重排和重组，从而让代码保持简洁。然而，代码简洁也要付出代价，那就是分组到达时间会存在无法预知的延迟变化。这个时间变化通常被称为抖动，也是影响应用程序性能的一个主要因素。无需按序交付数据或能够处理分组丢失的应用程序，以及对延迟或抖动要求很高的应用程序，最好选择UDP等协议。针对 TCP 的优化建议TCP是一个自适应的、对所有网络节点一视同仁的、最大限制利用底层网络的协议。因此，优化TCP的最佳途径就是调整它感知当前网络状况的方式，根据它之上或之下的抽象层的类型和需求来改变它的行为。优化的核心原理和影响： TCP 三次握手增加了整整一次往返时间； TCP 慢启动将被应用到每个新连接； TCP 流量及拥塞控制会影响所有连接的吞吐量； TCP 的吞吐量由当前拥塞窗口大小控制。服务器配置调优： 增大 TCP 的初始拥塞窗口，加大起始拥塞窗口可以让 TCP 在第一次往返就传输较多数据，而随后的速度提升也会很明显。对于突发性的短暂连接，这也是特别关键的一个优化。 慢启动重启，在连接空闲时禁用慢启动可以改善瞬时发送数据的长 TCP 连接的性能。 窗口缩放，启用窗口缩放可以增大最大接收窗口大小，可以让高延迟的连接达到更好吞吐量。应用程序行为调优：• 再快也快不过什么也不用发送，能少发就少发。• 我们不能让数据传输得更快，但可以让它们传输的距离更短。• 重用TCP连接是提升性能的关键。性能检查清单：• 把服务器内核升级到最新版本（Linux：3.2+）；• 确保cwnd大小为10；• 禁用空闲后的慢启动；• 确保启动窗口缩放；• 减少传输冗余数据；• 压缩要传输的数据；• 把服务器放到离用户近的地方以减少往返时间；• 尽最大可能重用已经建立的TCP连接。UDP 的构成UDP的主要功能和亮点并不在于它引入了什么特性，而在于它忽略的那些特性。UDP经常被称为无（Null）协议，RFC 768描述了其运作机制，全文完全可以写在一张餐巾纸上。数据报（ datagram ）和分组（ packet ）是两个经常被人混用的词，实际上它们还是有区别的。分组可以用来指代任何格式化的数据块，而数据报则通常只用来描述那些通过不可靠的服务传输的分组，既不保证送达，也不发送失败通知。正因为如此，很多场合下人们都把 UDP 中 User （用户）的 U ，改成 Unreliable （不可靠）的 U ，于是 UDP 就成了“不可靠数据报协议”（ Unreliable Datagram Protocol ）。这也是为什么把 UDP 分组称为数据报更为恰当的原因。UDP 最广泛的应用就是 DNS ，至于为什么 DNS 使用 UDP ，具体可以看这篇文章：为什么 DNS 使用 UDP 协议 - 面向信仰编程 。无服务协议IP 层的主要任务就是按照地址从源主机向目标主机发送数据报。为此，消息会被封装在一个 IP 分组内，其中载明了源地址和目标地址，以及其他一些路由参数。注意，数据报这个词暗示了一个重要的信息：IP 层不保证消息可靠的交付，也不发送失败通知，实际上是把底层网络的不可靠性直接暴露给了上一层。如果某个路由节点因为网络拥塞、负载过高或其他原因而删除了 IP 分组，那么在必要的情况下，IP的上一层协议要负责检测、恢复和重发数据。UDP 协议会用自己的分组结构封装用户消息，它只增加了 4 个字段：源端口、目标端口、分组长度和校验和。这样，当IP把分组送达目标主机时，该主机能够拆开 UDP 分组，根据目标端口找到目标应用程序，然后再把消息发送过去。仅此而已。事实上，UDP 数据报中的源端口和校验和字段都是可选的。IP 分组的首部也有校验和，应用程序可以忽略 UDP 校验和。也就是说，所有错误检测和错误纠正工作都可以委托给上层的应用程序。说到底，UDP仅仅是在IP层之上通过嵌入应用程序的源端口和目标端口，提供了一个“应用程序多路复用”机制。UDP 特性总结如下： 不保证消息交互，不确认，不重传，无超时。 不保证交付顺序，不设置包序号，不重排，不会发生队首阻塞。 不跟踪连接状态，不必建立连接或重启状态机。• 不需要拥塞控制 ，不内置客户端或网络反馈机制。TCP 是一个面向字节流的协议，能够以多个分组形式发送应用程序消息，且对分组中的消息范围没有任何明确限制。因此，连接的两端存在一个连接状态，每个分组都有序号，丢失还要重发，并且要按顺序交付。相对来说， UDP 数据报有明确的限制：数据报必须封装在 IP 分组中，应用程序必须读取完整的消息。换句话说，数据报不能分片。 UDP 是一个简单、无状态的协议，适合作为其他上层应用协议的辅助。实际上，这个协议的所有决定都需要由上层的应用程序作出。UDP 与 NATIPv4 地址只有 32 位长，因而最多只能提供 42.9 亿个唯一IP地址。1990 年代初，互联网上的主机数量呈指数级增长，但不可能所有主机都分配一个唯一的 IP 地址。1994 年，作为解决 IPv4 地址即将耗尽的一个临时性方案，IP 网络地址转换器（ NAT ， Network Address Translator ） 规范出台了，这就是 RFC 1631。建议的 IP 重用方案就是在网络边缘加入 NAT 设备，每个 NAT 设备负责维护一个表，表中包含本地 IP 和端口到全球唯一（外网） IP 和端口的映射。这样，NAT设备背后的IP地址空间就可以在各种不同的网络中得到重用，从而解决地址耗尽问题。为了避免路由错误和其它一些问题， IANA 为私有网络保留了三段 IP 地址，这些 IP 地址只能在 NAT 设备后面的内网中看到：连接状态超时NAT 转换的问题（至少对于 UDP 而言）在于必须维护一份精确的路由表才能保证数据转发。 NAT 设备依赖连接状态，而 UDP 没有状态。这种根本上的错配是很多 UDP 数据报传输问题的总根源。发送出站 UDP 不费事，但路由响应却需要转换表中有一个条目能告诉我们本地目标主机的 IP 和端口。因此，转换器必须保存每个 UDP 流的状态，而 UDP 自身却没有状态。NAT 设备还被赋予了删除转换记录的责任，但由于 UDP 没有连接终止确认环节，任何一端随时都可以停止传输数据报，而不必发送通告。为解决这个问题， UDP 路由记录会定时过期。定时多长？没有规定，完全取决于转换器的制造商、型号、版本和配置。因此，对于较长时间的 UDP 通信，有一个事实上的最佳做法，即引入一个双向 keep-alive 分组，周期性地重置传输路径上所有 NAT 设备中转换记录的计时器。对 TCP 的影响：从技术角度讲， NAT 设备不需要额外的 TCP 超时机制。 TCP 协议就遵循一个设计严密的握手与终止过程，通过这个过程就可以确定何时需要添加或删除转换记录。遗憾的是，实际应用中的 NAT 设备给 TCP 和 UDP 会话应用了类似的超时逻辑。这样就导致 TCP 连接有时候也需要双向 keep-alive 分组。如果你的 TCP 连接突然断开，那很有可能就是中间NAT超时造成的。NAT 穿透更为严重的则是很多应用程序根本就不能建立 UDP 连接。尤其是 P2P 应用程序，涉及 VoIP 、游戏和文件共享等，它们客户端与服务器经常需要角色互换，以实现端到端的双向通信。实现 UDP 传输的充分条件： 应用程序想与私有网络外部的主机通信，它就必须要知道自己的外网 IP 地址，否则则传输就会失败； NAT 设备的转换表中也需要有一个条目可以将外网 IP 的分组转换为内部主机的 IP 地址和端口号，否则无法确定将分组发送给哪台内部主机。针对 UDP 的优化建议UDP 是一个简单常用的协议，经常用于引导其他传输协议。事实上， UDP 的特色在于它所省略的那些功能：连接状态、握手、重发、重组、重排、拥塞控制、拥塞预防、流量控制，甚至可选的错误检测，统统没有。这个面向消息的最简单的传输层在提供灵活性的同时，也给实现者带来了麻烦。你的应用程序很可能需要从头实现上述几个或者大部分功能，而且每项功能都必须保证与网络中的其他主机和协议和谐共存。与内置流量和拥塞控制以及拥塞预防的 TCP 不同， UDP 应用程序必须自己实现这些机制。拥塞处理做得不到位的 UDP 应用程序很容易堵塞网络，造成网络性能下降，严重时还会导致网络拥塞崩溃。如果你想在自己的应用程序中使用 UDP ，务必要认真研究和学习当下的最佳实践和建议。 RFC 5405 就是这么一份文档，它对设计单播 UDP 应用程序给出了很多设计建议，简述如下： 应用程序必须容忍各种因特网路径条件； 应用程序应该控制传输速度； 应用程序应该对所有流量进行拥塞控制； 应用程序应该使用与 TCP 相近的带宽； 应用程序应该准备基于丢包的重发计数器； 应用程序应该不发送大于路径 MTU 的数据报； 应用程序应该处理数据报丢失、重复和重排； 应用程序应该足够稳定以支持 2 分钟以上的交付延迟； 应用程序应该支持 IPv4 UDP 校验和，必须支持 IPv6 校验和； 应用程序可以在需要时使用 keep-alive （最小间隔 15 秒）。设计新传输协议必须经过周密的考虑、规划和研究，否则就是不负责任。 WebRTC 符合上述要求。TLSSSL 协议在直接位于TCP上一层的应用层被实现。SSL 不会影响上层协议（如 HTTP 、电子邮件、即时通讯），但能够保证上层协议的网络通信安全。在正确使用 SSL 的情况下，第三方监听者只能推断出连接的端点、加密类型，以及发送数据的频率和大致数量，不能实际读取或修改任何数据。IETF 后来在标准化 SSL 协议时，将其改名为 Transport LayerSecurity （ TLS ，传输层安全）。很多人会混用 TLS 和 SSL ，但严格来讲它们并不相同，因为它们指代的协议版本不同。加密，身份验证与完整性TLS 协议的目标是为在它之上运行的应用提供三个基本服务：加密、身份验证和数据完整性。从技术角度讲，并不是所有情况下都要同时使用这三个服务。比如，可以接受证书但不验证其真实性，而前提是你非常清楚这样做有什么安全风险且有防范措施。实践中，安全的 Web 应用都会利用这三个服务： 加密，混淆数据的机制； 身份验证，验证身份标识有效性的机制； 完整性，检测消息是否被篡改或伪造的机制；TLS 握手协商内容包括 TLS 版本、加密套件， 必要时还会验证证书。 然而， 协商过程的每一步都需要一个 分组在客户端和服务器之间往返一次，因而所有 TLS 连接启动时都要经历 一定的延迟。握手过程：• 0 ms：TLS 在可靠的传输层（ TCP ）之上运行，这意味着首先必须完成 TCP 的“三次握手”，即一次完整的往返；• 56 ms：TCP 连接建立之后，客户端再以纯文本形式发送一些规格说明，比如它所运行的 TLS 协议的版本、它所支持的加密套件列表，以及它支持或希望使用的另外一些 TLS 选项；• 84 ms：然后， 服务器取得 TLS 协议版本以备将来通信使用，从客户端提供的加密套件列表中选择一个，再附上自己的证书，将响应发送回客户端。作为可选项，服务器也可以发送一个请求，要求客户端提供证书以及其他 TLS 扩展参数；• 112 ms：假设两端经过协商确定了共同的版本和加密套件， 客户端把自己的证书提供给了服务器。 然后， 客户端会生成一个新的对称密钥， 用服务器的公钥来加密， 加密后发送给服务器， 告诉服务器可以开始加密通信了。 到目前为止， 除了用服务器公钥加密的新对称密钥之外， 所有数据都以明文形式发送；• 140 ms：最后， 服务器解密出客户端发来的对称密钥， 通过验证消息的 MAC 检测消息完整性，再返回给客户端一个加密的“ Finished ”消息；• 168 ms：客户端用它之前生成的对称密钥解密这条消息， 验证 MAC ， 如果一切 顺利，则建立信道并开始发送应用数据；公钥加密系统只在建立 TLS 信道的会话中使用。在此期间，服务器向客户端提供它的公钥，客户端生成对称密钥并使用服务器的公钥对其加密，然后再将加密的对称密钥返回服务器。服务器继而用自己的私钥解密出客户端发来的对称密钥。接下来，客户端与服务器间的通信就全都使用客户端生成的共享密钥加密，这就是对称密钥加密。之所以这样设计，很大程度上是出于性能考虑，因为公钥加密需要很大的计算量。ALPN两端在传输数据时需要提前确定使用什么协议，指定端口号 （ HTTP 是 80 ， TLS 是 443 ）。 HTTP 规范为了协商协议规定了一个 Upgrade 首部，但是如果使用 Upgrade 需要一次额外的往返时间。于是可以在 TLS 握手阶段同时协商确定协议，应用层协议协商（ ALPN， Application LayerProtocol Negotiation ）作为 TLS 扩展，让我们能在 TLS 握手的同时协商应用协议，从而省掉了 HTTP 的 Upgrade 机制所需的额外往返时间。具体来说，整个过程分如下几步：客户端在 ClientHello 消息中追加一个新的 ProtocolNameList 字段，包含自己支持的应用协议；服务器检查 ProtocolNameList 字段，并在 ServerHello 消息中以 ProtocolName 字段返回选中的协议。服务器可以从中选择一个协议名，否则如果不支持其中的任何协议，则断开连接。只要 TLS 握手完成、建立了加密信道并就应用协议达成一致，客户端与服务器就可以立即通信。服务器名称指示 （ SNI ）如果服务器想在一个 IP 地址为多个站点提供服务，而每个站点都拥有自己的 TLS 证书。为了解决这个问题， SNI （ Server Name Indication ，服务器名称指示）扩展被引入 TLS 协议，该扩展允许客户端在握手之初就指明要连接的主机名。 Web 服务器可以检查 SNI 主机名，选择适当的证书，继续完成握手。TLS 会话恢复完整 TLS 握手会带来额外的延迟和计算量，从而给所有依赖安全通信的应用造成严重的性能损失。为了挽回某些损失， TLS 提供了恢复功能，即在多个连接间共享协商后的安全密钥。会话标识符最早的“会话标识符”（ Session Identifier ， RFC 5246 ）机制是在 SSL 2.0 中引入的，支持服务器创建 32 字节的会话标识符，并在完整的TLS协商期间作为其“ ServerHello ”消息的一部分发送。在内部，服务器会为每个客户端保存一个会话 ID 和协商后的会话参数。相应地，客户端也可以保存会话 ID 信息，并将该 ID 包含在后续会话的“ ClientHello ”消息中，从而告诉服务器自己还记着上次握手协商后的加密套件和密钥呢，这些都可以重用。假设客户端和服务器都可以在自己的缓存中找到共享的会话 ID 参数，那么就可以进行简短握手。否则，就要重新启动一次全新的会话协商，生成新的会话 ID 。借助会话标识符可以节省一次往返，还可以省掉用于协商共享加密密钥的公钥加密计算。由于重用了之前协商过的会话数据，就可以迅速建立一个加密连接，而且同样安全。由于每个打开的TLS连接都要占用内存，因此需要一套会话 ID 缓存和清除策略，对于拥有很多服务器而且为获得最佳性能必须使用共享TLS会话缓存的热门站点而言，部署这些策略绝非易事。会话记录单为了解决上述服务器端部署TLS会话缓存的问题，“会话记录单”（ Session Ticket，RFC 5077 ）机制出台了，该机制不用服务器保存每个客户端的会话状态。相反，如果客户端表明其支持会话记录单，则服务器可以在完整 TLS 握手的最后一次交换中添加一条“新会话记录单”（ New Session Ticket ）记录，包含只有服务器知道的安全密钥加密过的所有会话数据。然后，客户端将这个会话记录单保存起来，在后续会话的 ClientHello 消息中，可以将其包含在 SessionTicket 扩展中。这样，所有会话数据只保存在客户端，而由于数据被加密过，且密钥只有服务器知道，因此仍然是安全的。无状态恢复机制的优点主要是消除了服务器端的缓存负担，通过要求客户端在与服务器建立新连接时提供会话记录单简化了部署（除非记录单过期）。信任链与证书颁发机构身份验证是建立每个TLS连接必不可少的部分。毕竟，加密信道两端可以是任何机器，包括攻击者的机器。为此，必须确保我们与之交谈的计算机是可信任的，否则之前的工作都是徒劳。Web以及浏览器中的身份验证与上述过程相同，这就意味着此时此刻你应该问自己：我的浏览器信任谁？我在使用浏览器的时候信任谁？这个问题至少有三个答案。 手工指定证书，所有浏览器和操作系统都提供了一种手工导入信任证书的机制。至于如何获得证书和验证完整性则完全由你自己来定。 证书颁发机构 CA（ Certificate Authority ，证书颁发机构）是被证书接受者（拥有者）和依赖证书的一方共同信任的第三方。 浏览器和操作系统，每个操作系统和大多数浏览器都会内置一个知名证书颁发机构的名单。因此，你也会信任操作系统及浏览器提供商提供和维护的可信任机构。证书撤销有时候，出于种种原因，证书颁发者需要撤销或作废证书，比如证书的私钥不再安全、证书颁发机构本身被冒名顶替，或者其他各种正常的原因，像以旧换新或所属关系更替等。为确保信任链不被破坏，通信的任何一端都可以根据嵌入的指令和签名检查链条中每个证书的状态。CRL （ Certificate Revocation List ，证书撤销名单）是 RFC 5280 规定的一种检查所有证书状态的简单机制：每个证书颁发机构维护并定期发布已撤销证书的序列号名单。这样，任何想验证证书的人都可以下载撤销名单，检查相应证书是否榜上有名。如果有，说明证书已经被撤销了。CRL 文件本身可以定期发布、每次更新时发布，或通过 HTTP 或其他文件传输协议来提供访问。这个名单同样由证书颁发机构签名，通常允许被缓存一定时间。实践中，这种机制效果很好，但也存在一些问题：• CRL 名单会随着要撤销的证书增多而变长，每个客户端都必须取得包含所有序列号的完整名单；• 没有办法立即更新刚刚被撤销的证书序列号，比如客户端先缓存了 CRL ，之后某证书被撤销，那到缓存过期之前，该证书将一直被视为有效。为解决 CRL 机制的上述问题， RFC 2560 定义了 OCSP （ Online Certificate Status Protocol ，在线证书状态协议），提供了一种实时检查证书状态的机制。与 CRL 包含被撤销证书的序列号不同， OCSP 支持验证端直接查询证书数据库中的序列号，从而验证证书链是否有效。总之， OCSP 占用带宽更少，支持实时验证。• 证书颁发机构必须处理实时查询；• 证书颁发机构必须确保随时随地可以访问；• 客户端在进一步协商之前阻塞 OCSP 请求；• 由于证书颁发机构知道客户端要访问哪个站点，因此实时 OCSP 请求可能会泄露客户端的隐私。TLS 记录协议交付应用数据的典型流程如下。• 记录协议接收应用数据。• 接收到的数据被切分为块：最大为每条记录214 字节，即 16 KB。• 压缩应用数据（可选）。• 添加 MAC（ Message Authentication Code ）或 HMAC 。• 使用商定的加密套件加密数据。以上几步完成后，加密数据就会被交给 TCP 层传输。接收端的流程相同，顺序相反：使用商定的加密套件解密数据、验证 MAC 、提取并把数据转交给上层的应用。针对 TLS 的优化建议 公钥加密与私钥加密，公钥加密与对称加密相比，需要更大的计算工作量。因此，在 Web 发展早期，通常都需要专门的硬件来进行“ SSL 卸载”。好在现在不这样了。现代硬件突飞猛进的发展为减小这种损失提供了强力支持，原先需要专门硬件来做的工作，今天直接通过CPU就能完成。如果说重用 TCP 连接对于非加密通信是一个重要的优化手段，那么这个手段对运行在 TLS 上的应用同样至关重要。换句话说，只要能省掉握手，就应该省掉。如果必须握手，那么还有一个可能的技巧：尽早完成。 CDN 加速，做到尽早完成的最简单方式，就是在世界各地的服务器上缓存或重复部署数据和服务，而不要让所有用户都通过跨海或跨大陆光缆连接到一个中心原始服务器。当然，这正是 CDN （ Content Delivery Networks ，内容分发网络）服务的内容：通过使用本地代理服务器分流负载等手段降低延迟。虽然 CDN 最常用于在全球优化分发静态资源，但其优点并不止于此。距离客户端更近的服务器还可以缩短 TLS 会话，因为 TCP 和 TLS 握手的对象都是近处的服务器，所以建立连接的总延迟就会显著减少。相应地，本地代理服务器则可以与原始服务器建立一批长期的安全连接，全权代理请求与响应。 会话缓存和无状态恢复，由于会话记录单还是相对新的 TLS 扩展，并非所有客户端都支持它。实践中，为了取得最优结果，应该做好两手准备：在支持的客户端中使用会话记录单，而在不支持的客户端中使用会话标识符。这两种手段不会相互干扰，而是会很好地协同工作。 TLS 记录大小调整，小记录会造成浪费，大纪录会导致延迟。 TLS 压缩。 证书链的长度。性能检查清单 要最大限制提升 TCP 性能，请参考2.5节“针对TCP的优化建议”； 把 TLS 库升级到最新版本，在此基础上构建（或重新构建）服务器； 启用并配置会话缓存和无状态恢复；监控会话缓存的使用情况并作出相应调整； 在接近用户的地方完成 TLS 会话，尽量减少往返延迟； 配置TLS记录大小，使其恰好能封装在一个TCP段内； 确保证书链不会超过拥塞窗口的大小；从信任链中去掉不必要的证书，减少链条层次； 禁用服务器的 TLS 压缩功能； 启用服务器对 SNI 的支持； 启用服务器的 OCSP 封套功能；追加 HTTP 严格传输安全首部。" }, { "title": "MemorySafety", "url": "/posts/MemorySafety/", "categories": "", "tags": "Swift, 翻译", "date": "2020-09-30 10:15:10 +0800", "snippet": "原文：MemorySafety在默认情况下， Swift 会防止你的代码中发生不安全的行为。举个例子， Swift 保证所有变量在使用前都已经完成了初始化，当它们被释放后无法对内存进行存取，数组的索引越界时报错。Swift 还要求修改内存内容的代码具有独占的访问权限，以此来保证同时对同一区域内存的多次访问不会造成冲突。因为 Swift 会自动管理内存，所以大多数情况下你都不需要考虑有关内存访问的问题。然而，弄明白什么地方有可能发生冲突仍然非常重要，你可以避免写出访问内存时造成冲突的代码。如果你的代码保护这些冲突，那么你会得到一个编译时或者运行时的错误。存取内存时的冲突当你执行像是设置变量的值或者将参数传递给函数之类的操作时，就会在代码中访问内存。举个例子，下面的代码就包含读取访问和写入访问：// A write access to the memory where one is stored.var one = 1// A read access from the memory where one is stored.print(&quot;We&#39;re number \\(one)!&quot;)当你的代码中不同的部分试图同时访问内存中同一块区域时，对内存的存取就会产生冲突。同时对内存中的同一个区域进行多次访问会造成不可预期或者不一致的行为。在 Swift 中，有多种方法可以在修改跨越几行代码中的值，使得可以在修改过程中访问一些中间值。通过下面这个如何更新纸条上的预算的例子，你可以看到类似的问题。更新预算分为两个步骤：首先，你需要添加项目的名字和价格，然后你需要根据当前纸条上的预算来更新总金额。在更新前和更新后，你都可以从预算中读取任何信息和获取正确的答案，如下图所示：当你向预算中添加项目时，它处于一个临时的，无效的状态中，因为总金额尚未根据你添加的项目进行更新。在添加项目的过程中读取总金额会得到错误的信息。这个例子还说明了在解决内存冲突时可能会遇到的挑战：有时有几种方法来解决冲突，但是会导致不同的答案，且哪个答案是正确的有时是件不明显的事情。在这个示例中，根据你要需要的是原始的金额还是更新后的金额， $5 和 $320 都可以是正确答案。在你解决冲突前，必须要清楚需要获取的金额是哪个。 Note如果你编写了并发或者多线程的代码，那么对内存的冲突访问可能是一个常见的问题。但是这里讨论的冲突访问是发生在单线程中，不会涉及并发或者多线程的代码。如果你在单线程中对内存的访问存在冲突， Swift 会保证在编译时或者运行时报错。对于多线程代码，可以使用 Thread Sanitizer 来帮助你检查线程中的冲突访问。内存访问的特征在访问冲突的情况下需要考虑访问内存的三个特征： 访问是读访问还是写访问； 访问的持续时间； 访问的内存的位置；具体来说，如果你有两个满足以下所有条件的访问时，就会产生冲突： 至少有一个写操作； 访问内存中同一个位置； 持续时间重叠；读写操作之间的区别通常非常明显：写操作会改变内存中的位置，读操作不会。内存中的位置指向要访问的内容，如变量，常量和属性等。内存访问的持续时间可以是瞬间的，也可以是长期的。如果说在访问开始到结束之间无法执行其它代码，那么访问的持续时间就是瞬间的。从本质上来说，两个瞬间的访问是不可能同时发生。大多数内存访问都是瞬间的。在下面的代码中，所有的访问都是瞬间的：func oneMore(than number: Int) -&amp;gt; Int { return number + 1}var myNumber = 1myNumber = oneMore(than: myNumber)print(myNumber)// Prints &quot;2&quot;但是，有几种方法可以长期访问内存，跨越其他代码的执行过程。瞬间访问和长期访问的区别在于，其它代码有可能在长期访问开始到结束之间执行，这种情况称之为重叠。长期访问可以和其它长期或者瞬间访问重叠。重叠访问主要出现在使用了 in-out 参数的函数，方法或者结构体的可变方法中。下面所讨论的特定 Swift 代码都使用了长期访问。In-Out 参数的冲突访问一个函数对于它所有的 in-out 参数都具备长期写访问的权限。在所有非 in-out 参数完成求值后，就开始对 in-out 参数进行写访问，并持续到整个函数完成执行。如果有多个 in-out 参数，那么写访问开始的顺序与参数出现的顺序一致。长期写访问的一个影响是你无法访问 in-out 参数的原始变量，即使满足作用域规则和访问权限，所有访问原始变量的操作都会造成冲突。举个例子：var stepSize = 1func increment(_ number: inout Int) { number += stepSize}increment(&amp;amp;stepSize)// Error: conflicting accesses to stepSize在上述代码中， stepSize 是一个全局变量，所以在 increment(_:) 方法中可以直接访问它。然而， stepSize 的读访问和 number 的写访问重叠了。如下面配图所示， number 和 stepSize 都指向内存中同一个位置。读访问和写访问都指向相同的内存，且它们重叠了，因此产生了冲突。一个解决的办法是拷贝 stepSize ：// Make an explicit copy.var copyOfStepSize = stepSizeincrement(&amp;amp;copyOfStepSize)// Update the original.stepSize = copyOfStepSize// stepSize is now 2当你在调用 increment(_:) 前对 stepSize 进行拷贝时， copyOfStepSize 会加上当前的 stepSize 。读访问在写访问开始前已经结束了，所以这里是没有冲突的。长期写访问的另外一个影响是无法传递同一个变量给同一个函数中的多个 in-out 参数，否则会产生冲突。举个例子：func balance(_ x: inout Int, _ y: inout Int) { let sum = x + y x = sum / 2 y = sum - x}var playerOneScore = 42var playerTwoScore = 30balance(&amp;amp;playerOneScore, &amp;amp;playerTwoScore) // OKbalance(&amp;amp;playerOneScore, &amp;amp;playerOneScore)// Error: conflicting accesses to playerOneScore上面的 balance(_:_:) 函数会对它的两个参数进行操作，对它们的和进行等分。调用这个方法时如果使用 playerOneScore 和 playerTwoScore 作为参数是不会产生冲突的，虽然这个时候有两个写访问重叠了，但是它们访问的是内存中不同的位置。相反地，如果使用 playerOneScore 作为两个参数就会产生冲突，因为它试图在同一时间内对内存中相同的位置执行写访问。 Note因为操作符也是函数，它们也对 in-out 参数有长期访问。如果说 balance(_:_:) 是一个名称为 &amp;lt;^&amp;gt; 的操作符， playerOneScore &amp;lt;^&amp;gt; playerOneScore 跟 balance(&amp;amp;playerOneScore, &amp;amp;playerOneScore) 会产生相同的冲突。在方法中访问自身时冲突struct 的可变方法在执行期间对 self 持有写访问，假设有一个这样的游戏玩家，有生命值和能量两种属性，血量在收到伤害时会减少，能量在使用特殊技能时减少。struct Player { var name: String var health: Int var energy: Int static let maxHealth = 10 mutating func restoreHealth() { health = Player.maxHealth }}在上面的 restoreHealth() 方法中， self 的写访问从方法开始持续到结束。在这个例子中， restoreHealth() 中没有访问 Player 对象属性的代码。下面的 shareHealth(with:) 方法接受两个 Player 对象作为 in-out 参数，因此有可能产生访问重叠。extension Player { mutating func shareHealth(with teammate: inout Player) { balance(&amp;amp;teammate.health, &amp;amp;health) }}var oscar = Player(name: &quot;Oscar&quot;, health: 10, energy: 10)var maria = Player(name: &quot;Maria&quot;, health: 5, energy: 10)oscar.shareHealth(with: &amp;amp;maria) // OK在上面的例子中，调用 shareHealth(with:) 方法来共享 Oscar 玩家和 Maria 玩家之间的生命值不会产生冲突。在执行方法期间会存在一个对 oscar 的写访问，因为这是一个 mutating 的方法。然后还有对 maria 的写访问，因为 maria 是作为一个 in-out 参数传递进来的。如下图所示，它们指向的是内存中不同的位置，所以即使两个写访问在时间上重叠了，它们也不会产生冲突。然而，如果你将 oscar 作为 shareHealth(with:) 的参数进行传递，就会产生冲突：oscar.shareHealth(with: &amp;amp;oscar)// Error: conflicting accesses to oscarmutating 方法在执行期间对 self 有写访问， in-out 参数同时对 teammate 有写访问。所以 self 和 teammate 同时指向内存中相同的位置，如下所示，它们指向相同的内存，且重叠，所以会产生冲突。访问属性时冲突stuct ， tuple 和 enum 这些类型由不同的独立的值组成，比如说 struct 的 property 和 tuple 的 element 。因为它们是值类型，所以修改任何一部分都会修改整个值，这意味着对于属性的读或者写访问会持有对整个值的读或者写访问。举个例子，对 tuple 的不同 element 写访问重叠时就会产生冲突：var playerInformation = (health: 10, energy: 20)balance(&amp;amp;playerInformation.health, &amp;amp;playerInformation.energy)// Error: conflicting access to properties of playerInformation在上面的例子中，调用 balance(_:_:) 方法时如果传递的是 tuple 的元素，那么就会产生冲突，因为 playerInformation 的写访问重叠了。 playerInfomation.health 和 playerInfomation.energy 作为 in-out 参数进行传递，这意味着 balance(_:_:) 需要对它们进行写访问，对 tuple 的 element 进行写访问意味对整个 tuple 进行写访问。所以这两个针对 playerInformation 的写访问重叠了，产生冲突。下面的代码也显示了相同的错误，当对一个全局的 struct 变量的不同属性同时进行写访问时也会产生相同的冲突。var holly = Player(name: &quot;Holly&quot;, health: 10, energy: 10)balance(&amp;amp;holly.health, &amp;amp;holly.energy) // Error实际上，大多数对 struct 的属性的访问都可以安全地进行重叠。我们可以将上面的 holly 改成局部变量而不是全局变量，编译器可以在此保证对 struct 的存储属性进行的重叠访问是安全的。func someFunction() { var oscar = Player(name: &quot;Oscar&quot;, health: 10, energy: 10) balance(&amp;amp;oscar.health, &amp;amp;oscar.energy) // OK}在上面的例子中， Oscar 的生命值和能量值作为 balance(_:_:) 的两个 in-out 参数进行传递。编译器可以保证内存是安全的，因为这两个存储属性不会进行任何交互。对于结构提的属性来说，保证内存访问安全不一定需要进行重叠访问的限制。内存安全只是一个期望得到的保证，独占访问会比内存安全要求更严格，这意味着即使某些代码违反了对内存的独占性访问，也可以保证内存安全。如果说编译器可以保证对内存的非独占访问是安全的， Swift 就会允许执行这段非独占性的代码。如果满足以下条件，那么就可以证明对 struct 的属性进行重叠访问是安全的： 只访问实例的存储属性，不访问计算属性或者类属性； struct 是局部变量，不是全局变量； struct 没有被其它闭包捕获，或者只被非逃逸闭包捕获；如果编译器无法保证这次访问是安全的，它就不会允许这次访问。" }, { "title": "Swift 与 Objective-C 互操作中的 Optional", "url": "/posts/Optional-between-Swift-and-Objective-C/", "categories": "", "tags": "Swift, Objective-C", "date": "2020-07-13 23:33:20 +0800", "snippet": "参考 Optionals in Swift Objective-C Interoperability 本文基于 Swift 5.3 和 Xcode 12.0 beta 2 编写，不排除将来可能有变化。nonnull为了与 Swift 的 Optional 类型交互， Objective-C 提供了 nullable ， nonnull 等关键字，用于表示某个属性是否有可能为 nil ，这里是相关说明 Nullability 。假设我们有这么一个 Objective-C 类：#import &amp;lt;UIKit/UIKit.h&amp;gt;NS_ASSUME_NONNULL_BEGIN@interface SomeThing : NSObject@property (nonatomic, nonnull) UIScrollView *scrollView;@endNS_ASSUME_NONNULL_END#import &quot;SomeThing.h&quot;@implementation SomeThing@end使用了 nonnull 声明 UIScrollView *scrollView 属性，以此向 Swift 表明这个 scrollView 不会为 nil ，不需要进行解包操作，可以直接使用。在 SomeThing.m 中可以看到并没有对这个 scrollView 进行初始化，也就是这个 scrollView 为 nil ，但是编译器没有显示相关警告或者错误。 ps: 这在 Swift 中是不允许的，如果一个属性不是 Optional 或者隐式解包类型，那么在初始化中必须要设置对应的值，否则编译器会报错。由于 scrollView 是 UIScrollView 类型，所以我们可以直接对其进行一些操作：let thing: SomeThing = SomeThing()let scrollView: UIScrollView = thing.scrollViewlet contentSize: CGSize = scrollView.contentSizeprint(&quot;contentSize: \\(contentSize)&quot;)let indicatorStyle = scrollView.indicatorStyleswitch indicatorStyle {case .black: print(&quot;black&quot;)case .white: print(&quot;white&quot;)case .default: print(&quot;default&quot;)@unknown default: print(&quot;unknown default&quot;)}let gestureRecognizer = scrollView.panGestureRecognizergestureRecognizer.isEnabled = false由于 scrollView 本质上是 nil ，所以上述的代码运行后应该会导致崩溃才对，但是它是可以正常运行的，输出如下：contentSize: (0.0, 0.0)default我们直接把 scrollView 添加到当前 ViewController 的 view 上，看看是否可以正常显示：let scrollView: UIScrollView = thing.scrollViewscrollView.translatesAutoresizingMaskIntoConstraints = falsescrollView.backgroundColor = UIColor.blueview.addSubview(scrollView)NSLayoutConstraint.activate([ scrollView.leadingAnchor.constraint(equalTo: view.leadingAnchor), scrollView.topAnchor.constraint(equalTo: view.topAnchor), scrollView.trailingAnchor.constraint(equalTo: view.trailingAnchor), scrollView.bottomAnchor.constraint(equalTo: view.bottomAnchor)])什么也没有，界面一片空白。这就有可能导致一些奇奇怪怪的 bug ，我们在实际编码时会以为 scrollView 是实际存在的，把它添加到某个 view 上，进行相关操作，到最后发现一无所获。进行一些悲观的防护虽然 SomeThing 使用了 nonnull 来声明 scrollView ，但是我们还是想要判断 scrollView 是否为 nil ，以防止一些奇怪的 bug 出现。那么问题来了，由于 Swift 认为 scrollView 不可能为空，所以当我们进行解包操作时编译器会发出警告或者报错：guard let scrollView: UIScrollView = thing.scrollView else { return} warning: Non-optional expression of type ‘UIScrollView’ used in a check for optionalsguard let scrollView = thing.scrollView else { return} error: Initializer for conditional binding must have Optional type, not ‘UIScrollView’又或者说直接判断是否为 nil ：let scrollView = thing.scrollViewif scrollView == nil { print(&quot;The compiler says we won&#39;t get here.&quot;) print(&quot;But if we run the program, we do&quot;)} warning: Comparing non-optional value of type ‘UIScrollView’ to ‘nil’ always returns false虽然编译器也显示了警告说把一个 non-optional 值跟 nil 比较会一直返回 false ，但是我们运行相关代码时，控制台会输出相关的 log ：The compiler says we won&#39;t get here.But if we run the program, we do我们编写一个函数来清除 nonnull 相关信息以避免出现相关警告或者错误：func isNil(_ o: Any?) -&amp;gt; Bool { switch o { case .none: return true case .some(_): return false }}if isNil(scrollView) { print(&quot;This doesn&#39;t print.&quot;)}使用 Any? 作为参数时，不会返回 true ，因为 nil 也可以用 Any 来表示。所以需要使用 AnyObject ：func isNil(_ o: AnyObject?) -&amp;gt; Bool { switch o { case .none: return true case .some(_): return false }}if isNil(scrollView) { print(&quot;It works if we make it an AnyObject?&quot;)}我们可以通过这个方法来进行二次 nil 的判断，上面的例子说明所有从 Objective-C 层传进来的属性都是不可靠的（如果不注意编码规范的话）。Swift Extensions首先添加一个 Objective-C 类的 Swift extension ：extension UIScrollView { func doAThing() { print(&quot;doing it&quot;) }}然后尝试调用相关的方法：let scrollView = thing.scrollViewscrollView.doAThing()doAThing 方法会运行。跟 Objective-C 不同，如果你在 Objective-C 下给某个 nil 对象发送方法消息，是不会运行对应的方法的。但是 因为在 Swift 中， scrollView 不是 Optional 类型，Swift 认为 scrollView 不可能为 nil 。所以 Swift 会直接执行这个方法。Foundation 对象Foundation 对象也发生了一些有趣的事情。 NSCalendar 是 Foundation 中的类。我们尝试使用 NSCalendar 来重复上述实验：let calendarProvider = CalendarProvider()let calendar = calendarProvider.calendarlet weekStartsOn = calendar.firstWeekdaylet weekdays: [String] = calendar.shortWeekdaySymbols代码会在第 2 行崩溃： Thread 1: EXC_BAD_INSTRUCTION (code=EXC_I386_INVOP, subcode=0x0)跟 UIScrollView 不同， NSCalendar 在 Swift 中对应的类型为 Calendar ，但是这不是仅仅重命名，它做了一层桥接。 Swift 会自动把 NSCalendar 类型转换为 Calendar 。 Swift 的 Foundation 库中提供了 _ObjectiveCBridgeable 协议用于跟 Objective-C 类型进行桥接，其中可以通过 _unconditionallyBridgeFromObjectiveC 由 NSCalendar 生成对应的 Calendar ：public static func _unconditionallyBridgeFromObjectiveC(_ source: NSCalendar?) -&amp;gt; Calendar { var result: Calendar? = nil _forceBridgeFromObjectiveC(source!, result: &amp;amp;result) return result!}可以看到 _unconditionallyBridgeFromObjectiveC 方法接受一个 Optional&amp;lt;NSCalendar&amp;gt; 参数，但是在内部会进行强制解包，所以就触发了上述崩溃。这可以避免一些意料之外的行为。Array 属性nonnull Array 通过一种奇怪的方式从 Objective-C 层桥接到 Swift 中。首先定义以下 Objective-C 类，定义了 description 方法，用于输出相关数据：@interface OffendingObject : NSObject@property (nonatomic, nonnull) NSArray *array;@end@implementation OffendingObject- (NSString *)description { return [NSString stringWithFormat: @&quot;%@&quot; &quot;array: %@&quot;, [super description], self.array];}@endNSArray 在 Swift 中会桥接为 Array ，下面来看下一些奇怪的现象：let obj = OffendingObject()print(obj)print(obj.array)print(obj)obj.array.append(&quot;thing&quot;)print(obj)运行上述代码，输出如下：&amp;lt;OffendingObject: 0x600003210270&amp;gt;array: (null) // 1[] // 2&amp;lt;OffendingObject: 0x600003210270&amp;gt;array: (null) // 3&amp;lt;OffendingObject: 0x600003210270&amp;gt;array: ( thing) // 4输出 1 和 3 中的 array 为 null ，表现正常，但是输出 2 中的 array 是一个空的数组，这是因为 Swift 在进行桥接时如果 array 为 nil ， 就会返回一个空的 Array 。当我们通过 append 给 array 添加数据时并不会崩溃，且在输出 4 中可以看到 array 已经包含刚添加的对象。NSArray 是不可变的，但是 Array(Swift) 不同，在语义来说， Array 是值类型，不是引用类型。给 Array 添加一个新的元素时， Swift 会创建一个新的数组赋值给对应的属性，所以改变的是对应的属性，而不是 Array 。虽然 OffendingObject 中的 array 是 NSArray 类型，不可变，但是 array 属性是可读写的。所以 Swift 可以通过创建一个新的数组然后赋值给 array 来修改 array 的值。上面说到 array 为 nil 时 Swift 会返回一个空的数组，下面来看看为什么。跟 NSCalendar 一样， NSArray 会桥接为 Array ， Swift 中相关代码 Array.swift 如下：static public func _unconditionallyBridgeFromObjectiveC(_ source: NSArray?) -&amp;gt; Array { if let object = source { var value: Array&amp;lt;Element&amp;gt;? _conditionallyBridgeFromObjectiveC(object, result: &amp;amp;value) return value! } else { return Array&amp;lt;Element&amp;gt;() }}可以看到对 source 进行判断，如果 source 为 nil 则返回一个空的 Array 。最后相关讨论：SR-8622 Nonnull Objective-C property that falsely returns nil causes inconsistent Swift behavior The cost of checking every nonnull return value was determined to be too high, but maybe we could do it in Debug builds.—Jordan Rose, SR-8622" }, { "title": "Moya", "url": "/posts/Moya/", "categories": "", "tags": "源码解析", "date": "2020-07-05 23:53:07 +0800", "snippet": "是什么和为什么通过 Alamofire 可以对 URLSession 进行封装，使我们不需要过多关注一些琐碎的细节。但是在 Alamofire 的上层，我们可能还需要再做一层封装，这层封装针对于我们的 App ，更接近业务层。 Moya 正是对应的这层封装。 一般来说 App 的网络架构可能如下图所示：可能看到加入 Moya 后，整个 App 的网络层功能非常清晰， App 不会直接与 Alamofire 交互，所有网络请求都是通过 Moya 发起。Moya 支持以下特性： 编译时检测是否使用正确的 API endpoint ； 通过 enum 的关联值来对不同的 endpoints 定义清晰的用法； 测试插桩为一等值，使得单元测试变得非常容易；接入 Moya 后，你不再也不应该直接与 Alamofire 交互，所有的一切都由 Moya 来完成。 Moya 设计得非常灵活，可以满足各个开发者的需求。它更像是一个关于如何看待网络请求的库。Moya 基本的整体架构如下图所示：基础类型Moya 对请求的处理流水线如下图所示：Target(TargetType) 提供给开发者用于定义各个接口的参数， URL ， 测试数据等， 而 Endpoint 则是 Target 和 URLRequest 的中间态，所有 URLRequest 到最后都会经过 Endpoint 生成。TargetTypeTargetType 的定义如下：public protocol TargetType { var baseURL: URL { get } /// path 追加到 baseURL 中来构成当前请求的完整 URL var path: String { get } /// HTTP Method ，内部其实是 Alamofire.HTTPMethod var method: Moya.Method { get } /// 插桩测试时所用到的数据 var sampleData: Data { get } /// 所需要执行的 HTTP 任务 var task: Task { get } /// 执行请求时的验证类型，默认为 .none var validationType: ValidationType { get } /// 用于设置请求的 headers var headers: [String: String]? { get }}可以看到 TargetType 定义了一个请求所需要的基本数据，是开发者与 Moya 进行交互的第一层入口。 Moya 建议定义 enum 类型来支持 TargetType ，这样可以通过 switch case 和关联值来对不同的接口设置不同的数据，在添加了新的 case 后，编译器也可以及时检查和报错来提示我们编写对应的代码，如果使用 class 或者 struct ，就会失去这个优点。虽然使用 enum 需要编写大量的 switch case ，但在更加安全。 baseURL 属性对于同一个 enum 类型来说应该是相同的，也就是说我们可以根据 baseURL 的不同把接口放到不同的 enum 类型中，如果说一个 enum 中包含不同的 baseURL ，那么可以考虑拆成 多个 enum ； task 属性用于表示你如何发送/接收数据，如何添加数据，文件和数据流到请求的 body 中； validationType 属性用于定于哪些状态码是可以通过验证的；EndpointEndpoint 由 TargetType 转换而成，基本属性和初始化方法如下：open class Endpoint { public typealias SampleResponseClosure = () -&amp;gt; EndpointSampleResponse /// 用于生成 URLRequest 的 string public let url: String /// 插桩测试时返回的数据 `EndpointSampleResponse` public let sampleResponseClosure: SampleResponseClosure /// HTTP Method ，内部其实是 Alamofire.HTTPMethod public let method: Moya.Method /// 所需要执行的 HTTP 任务 public let task: Task /// 用于设置请求的 headers public let httpHeaderFields: [String: String]? /// 初始化方法 public init(url: String, sampleResponseClosure: @escaping SampleResponseClosure, method: Moya.Method, task: Task, httpHeaderFields: [String: String]?) { self.url = url self.sampleResponseClosure = sampleResponseClosure self.method = method self.task = task self.httpHeaderFields = httpHeaderFields } ///}Endpoint 和 TargetType 没有多大区别，为什么需要 Endpoint 这个中间态呢？后面再来解释下这个问题。在了解 TargetType 和 Endpoint 后，我们就可以进一步对 Moya 发起请求的流程进行探索。MoyaProvideropen class MoyaProvider&amp;lt;Target: TargetType&amp;gt;: MoyaProviderType { /// 用于 Target 转换为 Endpoint 的闭包 public typealias EndpointClosure = (Target) -&amp;gt; Endpoint /// 用于判断 URLRequest 是否需要执行以及对 URLRequest 进行哪些设置的闭包 public typealias RequestResultClosure = (Result&amp;lt;URLRequest, MoyaError&amp;gt;) -&amp;gt; Void /// 用于 Endpoint 转换为 RequestResultClosure 的闭包 public typealias RequestClosure = (Endpoint, @escaping RequestResultClosure) -&amp;gt; Void /// 用于判断 Target 是否需要和如何进行插桩测试 public typealias StubClosure = (Target) -&amp;gt; Moya.StubBehavior public let endpointClosure: EndpointClosure public let requestClosure: RequestClosure public let stubClosure: StubClosure /// Alamofire 的 session ，用于发起请求 public let session: Session /// 插件 public let plugins: [PluginType] /// 是否过滤重复的请求，如果有重复的请求在处理中，就不会发起新的请求而是把 completion 添加到对应的 inflightCompletionBlocks 中，根据 Endpoint 来判断是否为重复的请求 public let trackInflights: Bool open internal(set) var inflightRequests: [Endpoint: [Moya.Completion]] = [:] /// 与 Alamfire 的 callbackQueue 进行隔离，如果没有定义就会调用 Alamofire 默认的 queue （ main queue ） let callbackQueue: DispatchQueue? let lock: NSRecursiveLock = NSRecursiveLock() public init(endpointClosure: @escaping EndpointClosure = MoyaProvider.defaultEndpointMapping, requestClosure: @escaping RequestClosure = MoyaProvider.defaultRequestMapping, stubClosure: @escaping StubClosure = MoyaProvider.neverStub, callbackQueue: DispatchQueue? = nil, session: Session = MoyaProvider&amp;lt;Target&amp;gt;.defaultAlamofireSession(), plugins: [PluginType] = [], trackInflights: Bool = false) { self.endpointClosure = endpointClosure self.requestClosure = requestClosure self.stubClosure = stubClosure self.session = session self.plugins = plugins self.trackInflights = trackInflights self.callbackQueue = callbackQueue } ///}可以看到 MoyaProvider 支持了 MoyaProviderType 协议：public protocol MoyaProviderType: AnyObject { associatedtype Target: TargetType func request(_ target: Target, callbackQueue: DispatchQueue?, progress: Moya.ProgressBlock?, completion: @escaping Moya.Completion) -&amp;gt; Cancellable}抽离 MoyaProvider 的最小接口，用于跟 Reactive 框架交互。同时 MoyaProvider 也使用了范型 &amp;lt;Target: TargetType&amp;gt; ，在声明时需要定义 Target 的具体类型，如：let provider = MoyaProvider&amp;lt;UserAPI&amp;gt;()大多数情况下都不需要关心 MoyaProvider 的其它初始化参数， Moya 也为我们提供了一系列的默认初始化参数。defaultEndpointMapping 对 Target 不做任何处理，直接生成 Endpoint:final class func defaultEndpointMapping(for target: Target) -&amp;gt; Endpoint { return Endpoint( url: URL(target: target).absoluteString, sampleResponseClosure: { .networkResponse(200, target.sampleData) }, method: target.method, task: target.task, httpHeaderFields: target.headers )}defaultRequestMapping 将 Endpoint 转换为 RequestResultClosure ，可以异步执行，默认实现也不做任何处理，只鹅姐通过 Endpoint 的 urlRequest() 方法生成 URLRequest ，或者返回对应的 MoyaError ：final class func defaultRequestMapping(for endpoint: Endpoint, closure: RequestResultClosure) { do { let urlRequest = try endpoint.urlRequest() closure(.success(urlRequest)) } catch MoyaError.requestMapping(let url) { closure(.failure(MoyaError.requestMapping(url))) } catch MoyaError.parameterEncoding(let error) { closure(.failure(MoyaError.parameterEncoding(error))) } catch { closure(.failure(MoyaError.underlying(error, nil))) }}stubClosure 默认为 MoyaProvider.neverStub ，不进行测试插桩：final class func neverStub(_: Target) -&amp;gt; Moya.StubBehavior { return .never}defaultAlamofireSession() 默认使用 URLSessionConfiguration.default 来生成 Session ，这里会设置 startRequestsImmediately 为 false ，如果不设置为 false ， Alamofire 在创建 Request 后就会直接发起请求，即使在进行插桩测试的情况下。但是在 Alamofire5 中这块逻辑已经做了调整，在创建 Request 时不会直接发起请求，只有在调用 .response 相关方法添加响应处理后才会发起请求。final class func defaultAlamofireSession() -&amp;gt; Session { let configuration = URLSessionConfiguration.default configuration.headers = .default return Session(configuration: configuration, startRequestsImmediately: false)}PluginTypeMoya 提供的插件协议 ，用于请求发送或者接收时调用，这里也使用协议对具体的对象类型进行抽象， MoyaProvider 不需要知道具体的类型是什么，只需要实现 PluginType 协议即可：public protocol PluginType { /// 发送请求前调用，可以用来对 URLRequest 进行修改 func prepare(_ request: URLRequest, target: TargetType) -&amp;gt; URLRequest /// 发送请求前最后调用的方法，不管是插桩测试还是真正的网络请求都会调用这个方法 func willSend(_ request: RequestType, target: TargetType) /// 接收到响应结果时调用，会先调用该方法后再调用 MoyaProvider 调用自己的 completionHandler func didReceive(_ result: Result&amp;lt;Moya.Response, MoyaError&amp;gt;, target: TargetType) /// 响应结果的预处理器 func process(_ result: Result&amp;lt;Moya.Response, MoyaError&amp;gt;, target: TargetType) -&amp;gt; Result&amp;lt;Moya.Response, MoyaError&amp;gt;}插件请求前的处理借由 Alamofire 的 RequestInterceptor 协议来实现。每次发起请求时， MoyaProvider 都会生成一个 ` MoyaRequestInterceptor` ，其实现如下：final class MoyaRequestInterceptor: RequestInterceptor { private let lock: NSRecursiveLock = NSRecursiveLock() var prepare: ((URLRequest) -&amp;gt; URLRequest)? private var internalWillSend: ((URLRequest) -&amp;gt; Void)? var willSend: ((URLRequest) -&amp;gt; Void)? { get { lock.lock(); defer { lock.unlock() } return internalWillSend } set { lock.lock(); defer { lock.unlock() } internalWillSend = newValue } } init(prepare: ((URLRequest) -&amp;gt; URLRequest)? = nil, willSend: ((URLRequest) -&amp;gt; Void)? = nil) { self.prepare = prepare self.willSend = willSend } func adapt(_ urlRequest: URLRequest, for session: Alamofire.Session, completion: @escaping (Result&amp;lt;URLRequest, Error&amp;gt;) -&amp;gt; Void) { // 先调 prepare 对 urlRequest 进行处理，再调 willSend 。 let request = prepare?(urlRequest) ?? urlRequest willSend?(request) completion(.success(request)) }}/// 初始化private func interceptor(target: Target) -&amp;gt; MoyaRequestInterceptor { return MoyaRequestInterceptor(prepare: { [weak self] urlRequest in // 使用 reduce 简化代码 return self?.plugins.reduce(urlRequest) { $1.prepare($0, target: target) } ?? urlRequest })}请求流程请求前的处理大多数情况下我们都是通过 MoyaProvider 下面的接口来发起请求：open func request(_ target: Target, callbackQueue: DispatchQueue? = .none, progress: ProgressBlock? = .none, completion: @escaping Completion) -&amp;gt; Cancellable { let callbackQueue = callbackQueue ?? self.callbackQueue return requestNormal(target, callbackQueue: callbackQueue, progress: progress, completion: completion)}这个接口的返回结果使用了 Cancellable 协议进行封装：public protocol Cancellable { /// 判断请求是否已经取消 var isCancelled: Bool { get } /// 取消请求 func cancel()}可以看到也是同样使用协议提供了最小接口和对实际的对象进行抽象，调用方不需要知道具体的对象是什么，只需要通过 Cancellable 的接口来进行相关调用。经过一层 callbackqueue 的处理后会调用下面的方法，方法有点长，下面拆开几部分来讲解下：func requestNormal(_ target: Target, callbackQueue: DispatchQueue?, progress: Moya.ProgressBlock?, completion: @escaping Moya.Completion) -&amp;gt; Cancellable { /// 1. let endpoint = self.endpoint(target) /// 2. let stubBehavior = self.stubClosure(target) /// 3. let cancellableToken = CancellableWrapper() // 4. let pluginsWithCompletion: Moya.Completion = { result in let processedResult = self.plugins.reduce(result) { $1.process($0, target: target) } completion(processedResult) } ///} 将 Target 转换为对应的 Endpoint ：open func endpoint(_ token: Target) -&amp;gt; Endpoint { return endpointClosure(token)} 获取 Target 对应的插桩行为； 生成一个 CancellableWrapper ：internal class CancellableWrapper: Cancellable { internal var innerCancellable: Cancellable = SimpleCancellable() var isCancelled: Bool { return innerCancellable.isCancelled } internal func cancel() { innerCancellable.cancel() }}internal class SimpleCancellable: Cancellable { var isCancelled = false func cancel() { isCancelled = true }}CancellableWrapper 内部使用一个 SimpleCancellable 来实现 Cancellable 协议，如果进行插桩测试，就直接使用 SimpleCancellable ，如果发起实际请求，就会生成对应的 Cancellable ，替换 SimpleCancellable ； 使用 reduce调用插件的 process 方法对相应结果进行处理；做完上面的预处理后，就会判断是否需要处理重复的请求，进行相关的处理：if trackInflights { lock.lock() /// 根据 Endpoint 获取对应的回调 var inflightCompletionBlocks = self.inflightRequests[endpoint] /// 追加新的 pluginsWithCompletion inflightCompletionBlocks?.append(pluginsWithCompletion) self.inflightRequests[endpoint] = inflightCompletionBlocks lock.unlock() /// 如果 inflightCompletionBlocks 不为空，则表示有重复的请求在处理中，不需要发起新的请求，返回 cancellableToken 即可 if inflightCompletionBlocks != nil { return cancellableToken } else { /// 否则设置对应的回调到 inflightRequests 中 lock.lock() self.inflightRequests[endpoint] = [pluginsWithCompletion] lock.unlock() }}接下来就会设置一个 performNetworking 的 closure ：let performNetworking = { (requestResult: Result&amp;lt;URLRequest, MoyaError&amp;gt;) in /// 1. if cancellableToken.isCancelled { self.cancelCompletion(pluginsWithCompletion, target: target) return } var request: URLRequest! /// 2. switch requestResult { case .success(let urlRequest): request = urlRequest case .failure(let error): pluginsWithCompletion(.failure(error)) return } /// 3. let networkCompletion: Moya.Completion = { result in if self.trackInflights { self.inflightRequests[endpoint]?.forEach { $0(result) } self.lock.lock() self.inflightRequests.removeValue(forKey: endpoint) self.lock.unlock() } else { pluginsWithCompletion(result) } } /// 4. cancellableToken.innerCancellable = self.performRequest(target, request: request, callbackQueue: callbackQueue, progress: progress, completion: networkCompletion, endpoint: endpoint, stubBehavior: stubBehavior)}/// 5.requestClosure(endpoint, performNetworking)return cancellableToken 判断请求是否已经取消，如果已经取消就不用发起请求； 判断 requestRequest 是否为 .success ，如果不是则调用 pluginsWithCompletion 处理对应的 error ； 生成 networkCompletion ，也是根据 trackInflights 调用不同的 closure ； 调用 performRequest 执行请求，同时替换 cancellableToken 的 innerCancellable ； 调用 requestClosure 来将 Endpoint 转换为 URLRequest ，转换完成后则调用 performNetworking ，而上述步骤也都是在 performNetworking 内执行，之所以使用 closure 来进行处理，是为了支持异步转换，调用方可以在异步将 Endpoint 转换为 URLRequest 后再调用 performNetworking ；发起请求performRequest 会根据是否需要进行插桩测试来调用不同的方法： 如果进行插桩测试，就调用 stubRequest ； 如果不进行插桩测试，就调用 sendRequest ；stubRequest当进行插桩测试时，不会发起真正的网络请求，而是通过 Endpoint 获取对应的假数据，进行回调：open func stubRequest(_ target: Target, request: URLRequest, callbackQueue: DispatchQueue?, completion: @escaping Moya.Completion, endpoint: Endpoint, stubBehavior: Moya.StubBehavior) -&amp;gt; CancellableToken { let callbackQueue = callbackQueue ?? self.callbackQueue /// 1. let cancellableToken = CancellableToken { } /// 2. let preparedRequest = notifyPluginsOfImpendingStub(for: request, target: target) let plugins = self.plugins /// 3. let stub: () -&amp;gt; Void = createStubFunction(cancellableToken, forTarget: target, withCompletion: completion, endpoint: endpoint, plugins: plugins, request: preparedRequest) switch stubBehavior { case .immediate: switch callbackQueue { case .none: stub() case .some(let callbackQueue): callbackQueue.async(execute: stub) } case .delayed(let delay): let killTimeOffset = Int64(CDouble(delay) * CDouble(NSEC_PER_SEC)) let killTime = DispatchTime.now() + Double(killTimeOffset) / Double(NSEC_PER_SEC) (callbackQueue ?? DispatchQueue.main).asyncAfter(deadline: killTime) { stub() } case .never: fatalError(&quot;Method called to stub request when stubbing is disabled.&quot;) } return cancellableToken} 生成 CancellableToken ，由于不会发起真正的请求，所以这里的 CancellableToken 没有包含对应的 Request ， cancelAction 也是一个空的实现； 调用插件的相关方法，这里有调用 Request 的 cancel() 方法，其实在 Alamofire5 里是不需要调用 cancel() 方法来取消请求了，因为 Alamofire5 里只有在添加 response 后才会发起请求，如果进行插桩测试是不会添加 responnse 的： func notifyPluginsOfImpendingStub(for request: URLRequest, target: Target) -&amp;gt; URLRequest { let alamoRequest = session.request(request) alamoRequest.cancel() let preparedRequest = plugins.reduce(request) { $1.prepare($0, target: target) } /// 使用 RequestTypeWrapper 进行封装，抽象成 RequestType 协议 let stubbedAlamoRequest = RequestTypeWrapper(request: alamoRequest, urlRequest: preparedRequest) plugins.forEach { $0.willSend(stubbedAlamoRequest, target: target) } return preparedRequest} 而 createStubFunction 则会进行验证和经由 Endpoint 的 sampleResponseClosure 来获取对应的假数据，同时也会调用插件的对应方法；sendRequestfunc sendRequest(_ target: Target, request: URLRequest, callbackQueue: DispatchQueue?, progress: Moya.ProgressBlock?, completion: @escaping Moya.Completion) -&amp;gt; CancellableToken { /// 1. let interceptor = self.interceptor(target: target) let initialRequest = session.request(request, interceptor: interceptor) /// 2. setup(interceptor: interceptor, with: target, and: initialRequest) let validationCodes = target.validationType.statusCodes let alamoRequest = validationCodes.isEmpty ? initialRequest : initialRequest.validate(statusCode: validationCodes) /// 3. return sendAlamofireRequest(alamoRequest, target: target, callbackQueue: callbackQueue, progress: progress, completion: completion)} 生成 MoyaRequestInterceptor ，用于调用插件对应的方法； 设置 interceptor 的 willSend ； 调用 Alamofire 的方法发送请求；func sendAlamofireRequest&amp;lt;T&amp;gt;(_ alamoRequest: T, target: Target, callbackQueue: DispatchQueue?, progress progressCompletion: Moya.ProgressBlock?, completion: @escaping Moya.Completion) -&amp;gt; CancellableToken where T: Requestable, T: Request { /// 1. let plugins = self.plugins var progressAlamoRequest = alamoRequest let progressClosure: (Progress) -&amp;gt; Void = { progress in let sendProgress: () -&amp;gt; Void = { progressCompletion?(ProgressResponse(progress: progress)) } if let callbackQueue = callbackQueue { callbackQueue.async(execute: sendProgress) } else { sendProgress() } } /// 2. if progressCompletion != nil { switch progressAlamoRequest { case let downloadRequest as DownloadRequest: if let downloadRequest = downloadRequest.downloadProgress(closure: progressClosure) as? T { progressAlamoRequest = downloadRequest } case let uploadRequest as UploadRequest: if let uploadRequest = uploadRequest.uploadProgress(closure: progressClosure) as? T { progressAlamoRequest = uploadRequest } case let dataRequest as DataRequest: if let dataRequest = dataRequest.downloadProgress(closure: progressClosure) as? T { progressAlamoRequest = dataRequest } default: break } } /// 3. let completionHandler: RequestableCompletion = { response, request, data, error in let result = convertResponseToResult(response, request: request, data: data, error: error) plugins.forEach { $0.didReceive(result, target: target) } if let progressCompletion = progressCompletion { let value = try? result.get() switch progressAlamoRequest { case let downloadRequest as DownloadRequest: progressCompletion(ProgressResponse(progress: downloadRequest.downloadProgress, response: value)) case let uploadRequest as UploadRequest: progressCompletion(ProgressResponse(progress: uploadRequest.uploadProgress, response: value)) case let dataRequest as DataRequest: progressCompletion(ProgressResponse(progress: dataRequest.downloadProgress, response: value)) default: progressCompletion(ProgressResponse(response: value)) } } completion(result) } progressAlamoRequest = progressAlamoRequest.response(callbackQueue: callbackQueue, completionHandler: completionHandler) progressAlamoRequest.resume() return CancellableToken(request: progressAlamoRequest)} 获取插件，生成对应的 progressClosure ； 这里不太明白为什么先生成 progressClosure 再通过 progressCompletion 判断是否使用，为什么不通过 progressCompletion 一起判断？ 生成 completionHandler ，这一步的目的是为了将 Alamofire 的 response 转换为 Moya 所需要的格式，调用插件的 didReceive 方法；至此，已经走完了 Moya 发送请求和处理相应结果的基本流程，可以看到 Moya 在 Alamofire 的基础上再提供了一层封装，简单易用，只需要进行少量的定义就可以直接使用，也提供了足够灵活的插件和入口给调用方使用。一些总结使用协议进行抽象Moya 中使用了协议来对接口进行抽象，如TargetType ， Cancellable 和 PluginType 等，使用协议可以隐藏具体的类型，也可以通过 extension 来提供默认实现：public extension TargetType { var validationType: ValidationType { return .none }}借用 enum 实现安全检查Moya 中也有使用 enum 来调用不同的逻辑，而 enum 在我们没有实现对应的逻辑时则会报错，这样可以避免我们遗漏 case ：public enum StubBehavior { /// Do not stub. case never /// Return a response immediately. case immediate /// Return a response after a delay. case delayed(seconds: TimeInterval)}public enum EndpointSampleResponse { /// The network returned a response, including status code and data. case networkResponse(Int, Data) /// The network returned response which can be fully customized. case response(HTTPURLResponse, Data) /// The network failed to send the request, or failed to retrieve a response (eg a timeout). case networkError(NSError)}对 Alamofire 的类型进行桥接由于 Moya 是在 Alamofire 基础上进行的封装，很多类型都是由 Alamofire 提供，使用类型桥接可以把 Alamofire 隐藏掉，调用方在使用时完全不知道 Alamofire 的存在：public typealias Session = Alamofire.Session/// Represents an HTTP method.public typealias Method = Alamofire.HTTPMethod/// Choice of parameter encoding.public typealias ParameterEncoding = Alamofire.ParameterEncodingpublic typealias JSONEncoding = Alamofire.JSONEncodingpublic typealias URLEncoding = Alamofire.URLEncoding/// Multipart form.public typealias RequestMultipartFormData = Alamofire.MultipartFormData/// Multipart form data encoding result.public typealias DownloadDestination = Alamofire.DownloadRequest.Destination/// Represents Request interceptor type that can modify/act on Requestpublic typealias RequestInterceptor = Alamofire.RequestIntercepto为了避免把 Alamofire 暴露给插件，使用 RequestType 对 Alamofire 的 Request 进行抽象：extension Request: RequestType { public var sessionHeaders: [String: String] { return delegate?.sessionConfiguration.httpAdditionalHeaders as? [String: String] ?? [:] }}高阶函数Moya 的 Response 提供了不少高阶函数给调用方使用，如 filter ，mapJSON() 等：Filterfunc filter&amp;lt;R: RangeExpression&amp;gt;(statusCodes: R) throws -&amp;gt; Response where R.Bound == Int { guard statusCodes.contains(statusCode) else { throw MoyaError.statusCode(self) } return self}func filter(statusCode: Int) throws -&amp;gt; Response { return try filter(statusCodes: statusCode...statusCode)}func filterSuccessfulStatusCodes() throws -&amp;gt; Response { return try filter(statusCodes: 200...299)}使用 RangeExpression 以支持字面量的 Range 参数， filter 会过滤掉所有 statusCode 不在对应范围的响应结果，并抛出一个 MoyaError.statusCode 。MapJSONfunc mapJSON(failsOnEmptyData: Bool = true) throws -&amp;gt; Any { do { return try JSONSerialization.jsonObject(with: data, options: .allowFragments) } catch { if data.count &amp;lt; 1 &amp;amp;&amp;amp; !failsOnEmptyData { return NSNull() } throw MoyaError.jsonMapping(self) }}mapJSON() 会将响应结果转换为 JSONObject ，如果失败则抛出 MoyaError.jsonMapping 。更多的用法可以这个文档： Moya/Response.md类型擦除EncodableMoya 的 Task 支持 Encodable 进行编码：/// A request body set with `Encodable` typecase requestJSONEncodable(Encodable)在 Endpoint 生成对应的 URLRequest 时会通过 Encodable 参数来设置 httpBody ：internal extension URLRequest { mutating func encoded(encodable: Encodable, encoder: JSONEncoder = JSONEncoder()) throws -&amp;gt; URLRequest { do { let encodable = AnyEncodable(encodable) httpBody = try encoder.encode(encodable) let contentTypeHeaderName = &quot;Content-Type&quot; if value(forHTTPHeaderField: contentTypeHeaderName) == nil { setValue(&quot;application/json&quot;, forHTTPHeaderField: contentTypeHeaderName) } return self } catch { throw MoyaError.encodableMapping(error) } }}这里需要声明方法为 mutating ，因为方法会修改属性。可以看到方法会通过 encodable 参数生成一个 AnyEncodable struct ：struct AnyEncodable: Encodable { private let encodable: Encodable public init(_ encodable: Encodable) { self.encodable = encodable } func encode(to encoder: Encoder) throws { try encodable.encode(to: encoder) }}通过 AnyEncodable 可以把传进行来的协议参数转换成具体的值参数，而这个参数是遵循 Encodable 协议的。这是在 Swift 上进行类型擦除的一种方式，把具体的类型隐藏起来。为什么要进行类型擦除呢？因为 JSONEncoder 的 encode 方法只接收具体的类型参数，不接受协议参数：open func encode&amp;lt;T&amp;gt;(_ value: T) throws -&amp;gt; Data where T : Encodable它表示 T 为遵循了 Encodable 协议的类型，也就是说我们无法通过以下方式调用 encode 方法：mutating func encoded(encodable: Encodable, encoder: JSONEncoder = JSONEncoder()) throws -&amp;gt; URLRequest { do { httpBody = try encoder.encode(encodable) return self } catch { throw MoyaError.encodableMapping(error) }}Value of protocol type ‘Encodable’ cannot conform to ‘Encodable’; only struct/enum/class types can conform to protocols ，我们无法直接使用 Encodable 参数。至于为什么 JSONEncoder 需要 encode 为具体的类型，而不是协议，又是另外一个问题了。MultiTargetMoyaProvider 在使用时需要指定 TargetType 的类型，而 App 中可能会根据 baseURL 分成多个 TargetType ，这样导致我们需要根据不同的 TargetType 提供不同的 MoyaProvider ，那么有没有办法只使用一个 MoyaProvider 就可以支持所有的 TargetType ？答案是使用 MultiTarget ：enum MultiTarget: TargetType { case target(TargetType) public init(_ target: TargetType) { self = MultiTarget.target(target) } public var path: String { return target.path } public var baseURL: URL { return target.baseURL } public var method: Moya.Method { return target.method } public var sampleData: Data { return target.sampleData } public var task: Task { return target.task } public var validationType: ValidationType { return target.validationType } public var headers: [String: String]? { return target.headers } public var target: TargetType { switch self { case .target(let target): return target } }}MultiTarget 为 enum 类型，只有一个由 TargetType 生成的 case ，内部属性也是对应的 TargetType ，这就可以将协议抽象成具体的类型。用法如下：let provider = MoyaProvider&amp;lt;MultiTarget&amp;gt;(plugins: [NetworkLoggerPlugin(configuration: .init(logOptions: .verbose))])provider.request(MultiTarget(GitHub.userRepositories(username))) { result in /// ...}与响应式框架交互RxSwiftextension Reactive where Base: MoyaProviderType { func request(_ token: Base.Target, callbackQueue: DispatchQueue? = nil) -&amp;gt; Single&amp;lt;Response&amp;gt; { return Single.create { [weak base] single in let cancellableToken = base?.request(token, callbackQueue: callbackQueue, progress: nil) { result in switch result { case let .success(response): single(.success(response)) case let .failure(error): single(.error(error)) } } return Disposables.create { cancellableToken?.cancel() } } }}普通请求返回的是 Single ， Single 是 Observable 的另外一个版本，不可以发出多个元素，只能发出一个元素或者一个 error 事件，这和网络请求的流程一致，每个请求只能返回一个响应结果。带有进度的请求：func requestWithProgress(_ token: Base.Target, callbackQueue: DispatchQueue? = nil) -&amp;gt; Observable&amp;lt;ProgressResponse&amp;gt; { let progressBlock: (AnyObserver) -&amp;gt; (ProgressResponse) -&amp;gt; Void = { observer in return { progress in observer.onNext(progress) } } let response: Observable&amp;lt;ProgressResponse&amp;gt; = Observable.create { [weak base] observer in let cancellableToken = base?.request(token, callbackQueue: callbackQueue, progress: progressBlock(observer)) { result in switch result { case .success: observer.onCompleted() case let .failure(error): observer.onError(error) } } return Disposables.create { cancellableToken?.cancel() } } // Accumulate all progress and combine them when the result comes return response.scan(ProgressResponse()) { last, progress in let progressObject = progress.progressObject ?? last.progressObject let response = progress.response ?? last.response return ProgressResponse(progress: progressObject, response: response) }}这里使用 Observable ，因为在请求过程中会调用 onNext 更新进度。使用 scan 操作符判断是否需要使用之前的 response 。ReactiveCocoafunc request(_ token: Base.Target, callbackQueue: DispatchQueue? = nil) -&amp;gt; SignalProducer&amp;lt;Response, MoyaError&amp;gt; { return SignalProducer { [weak base] observer, lifetime in let cancellableToken = base?.request(token, callbackQueue: callbackQueue, progress: nil) { result in switch result { case let .success(response): observer.send(value: response) observer.sendCompleted() case let .failure(error): observer.send(error: error) } } lifetime.observeEnded { cancellableToken?.cancel() } }}由于 ReactiveCocoa 没有类似 RxSwift 那样的 Single ，所以对于普通请求，会在 send(value: Value) 之后立即调用 sendComplete() 。" }, { "title": "Alamofire", "url": "/posts/Alamofire/", "categories": "", "tags": "源码解析", "date": "2020-06-15 22:10:26 +0800", "snippet": "为什么需要一个第三方框架对于大部分 App 来说都需要跟服务器做数据传输，通常情况下都是通过 HTTPS/HTTP 来完成。 URLSession 已经封装得很好，但是如果需要把网络层跟业务层分离开来，我们需要基于 URLSession 再做一层封装，对 method ，header ，上传，下载，错误处理等再做一层处理，让业务方在调用的时候更加舒服。Alamofire 是基于 URLSession 进行的封装，使用 Swift 编写的一个优雅的网络框架。本文主要是讲述 Alamofire 的具体逻辑和用法，对应的 Alamofire 版本为 5.2.1 。URLSession 和 Alamofire 比较举一个简单例子来说明下 URLSession 和 Alamofire 是如何发起请求的。// URLSessionlet session = URLSession.sharedlet dataTask = session.dataTask(with: URL(string: “https://www.github.com”)!) { (data, response, error) in guard let data = data, let string = String(data: data, encoding: .utf8) else { return } print(string)}dataTask.resume()// AlamofireAF.request(“https://www.github.com”) .responseString { (response) in guard let string = response.value else { return } print(string)}可以看到 Alamofire 简洁之处，不再需要手动创建 URLSessionDataTask 和调用 resume ，也不需要自己对请求结果进行解码和格式转换。网络请求都需要进行错误处理，参数转换和结果处理，而 Alamofire 都为我们提供了一系列链式调用的处理方法，代码也更容易理解和统一。整体架构Alamofire 基本的整体架构如下图所示：Alamofire 项目结构非常简单清晰，Alamofire.swift 只提供一个 AF 单例：public let AF = Session.default跟 4.0 版本比起来的好处就是不会污染全局的命名空间，且如果 Session 添加了新的接口， Alamofire.swift 文件也不需要作出改动。-- Alamofire.swift -- Core -- AFError.swift -- HTTPHeaders.swift -- HTTPMethod.swift -- Notifications.swift -- ParameterEncoder.swift -- ParameterEncoding.swift -- Protected.swift -- Request.swift -- RequestTaskMap.swift -- Response.swift -- Session.swift -- SessionDelegate.swift -- URLConvertible+URLRequestConvertible.swift -- Extensions -- DispatchQueue+Alamofire.swift -- OperationQueue+Alamofire.swift -- Result+Alamofire.swift -- StringEncoding+Alamofire.swift -- URLRequest+Alamofire.swift -- URLSessionConfiguration+Alamofire.swift -- Features -- AlamofireExtended.swift -- AuthenticationInterceptor.swift -- CachedResponseHandler.swift -- Combine.swift -- EventMonitor.swift -- MultipartFormData.swift -- MultipartUpload.swift -- NetworkReachabilityManager.swift -- RedirectHandler.swift -- RequestInterceptor.swift -- ResponseSerialization.swift -- RetryPolicy.swift -- ServerTrustEvaluation.swift -- URLEncodedFormEncoder.swift -- Validation.swift Core 里面包含的是网络请求过程中必须要调用的部分； Extensions 为系统的一些类添加了便捷方法； Features 则是 Alamofire 提供的一些特定功能，如缓存策略，重试策略，请求结果的处理等；基础解析为了在熟悉整个请求流程时各个参数，协议的作用，先来熟悉一下请求流程中都有使用到哪些类，协议或者方法。AFError请求错误时的 enum 类型，因为网络请求错误的类型较多，所以分了两层，第一层是 AFError ，而每个 error 也有可能会因应自己的二级分类再定义一个 enum 类型，下面是二级 enum 类型：MultipartEncodingFailureReason // 表单转码错误ParameterEncodingFailureReason // 参数转码错误ParameterEncoderFailureReason // 参数转码器错误 - RequiredComponent // 缺少必要的组件ResponseValidationFailureReason // 响应数据验证错误ResponseSerializationFailureReason // 响应数据序列化错误ServerTrustFailureReason // 服务器验证错误URLRequestValidationFailureReason // 请求验证错误除此之外，Alamofire 也提供了不少扩展方法给 Error和 AFError 使用，以求在使用上更便捷。如 Error 可以转化为 AFError ：extension Error { /// Returns the instance cast as an `AFError`. public var asAFError: AFError? { self as? AFError } public func asAFError(orFailWith message: @autoclosure () -&amp;gt; String, file: StaticString = #file, line: UInt = #line) -&amp;gt; AFError { guard let afError = self as? AFError else { fatalError(message(), file: file, line: line) } return afError } func asAFError(or defaultAFError: @autoclosure () -&amp;gt; AFError) -&amp;gt; AFError { self as? AFError ?? defaultAFError() }}这里使用了 @autoclosure 来声明对应的 Closure 。 使用闭包是为了利用其延迟执行的特性，如果 Error 其实是个 AFError ，那么我们就不需要获取 defaultAFError ，也不需要执行对应的代码，所以这里使用了闭包来传参。 使用 @autoclosure 进行声明，这样调用方在调用的时候不需要加上 {} ，看起来跟普通的参数一样：error.asAFError(or: .responseSerializationFailed(reason: .customSerializationFailed(error: error)))HTTPHeadersHTTPHeaders 是一个 Struct 类型，保存了 HTTP 头的一些 name / value 配对。 HTTPHeader 则封装了一些快速生成 HTTP 头属性的方法。你可以使用 URLSessionConfiguration.af.default 来获取默认的 HTTPHeaders 对应的 URLSessionConfiguration 。为了方便直接生成 HTTPHeaders ， 还支持 ExpressibleByDictionaryLiteral 和 ExpressibleByArrayLiteral 协议，可以直接使用 Dictionary 和 Array 的 字面表达式来直接生成：extension HTTPHeaders: ExpressibleByDictionaryLiteral { public init(dictionaryLiteral elements: (String, String)…) { self.init() elements.forEach { update(name: $0.0, value: $0.1) } }}extension HTTPHeaders: ExpressibleByArrayLiteral { public init(arrayLiteral elements: HTTPHeader…) { self.init(elements) }}// 这里的 .authorization 和 .accpet 都是 HTTPHeader 中为了方便我们调用提供的初始化方法。let headers: HTTPHeaders = [ .authorization(username: &quot;Username”, password: “Password&quot;), .accept(“application/json”)]对于一些系统的类，也提供了便捷方法来获取 HTTPHeaders ：extension URLRequest { public var headers: HTTPHeaders { get { allHTTPHeaderFields.map(HTTPHeaders.init) ?? HTTPHeaders() } set { allHTTPHeaderFields = newValue.dictionary } }}extension HTTPURLResponse { public var headers: HTTPHeaders { (allHeaderFields as? [String: String]).map(HTTPHeaders.init) ?? HTTPHeaders() }}public extension URLSessionConfiguration { var headers: HTTPHeaders { get { (httpAdditionalHeaders as? [String: String]).map(HTTPHeaders.init) ?? HTTPHeaders() } set { httpAdditionalHeaders = newValue.dictionary } }}在设定 HTTP 头时我们不再需要进行字符串的 hardcode ，通过 ExpressibleByDictionaryLiteral 和 ExpressibleByArrayLiteral 这两个协议，结合 HTTPHeaders 和 HTTPHeader 可以很舒服地设置相关的属性。NotificationsNotifications.swift 的结构分为几部分。第一部分是 Request 的扩展，定义了请求相关的通知，通过 static let 定义相关通知，方便调用：public extension Request { static let didResumeNotification = Notification.Name(rawValue: “org.alamofire.notification.name.request.didResume”)}// 调用Request.didResumeNotification第二部分是 Notification 和 NotificationCenter 的扩展，方便与 Request 进行交互：extension Notification { /// 把userInfo 的 Request 通过 String.requestKey 封装起来，方便获取 public var request: Request? { return userInfo?[String.requestKey] as? Request } /// 通过 Request 和 NotificationName 生成 Notification ，不需要每次都手动设置 userInfo init(name: Notification.Name, request: Request) { self.init(name: name, object: nil, userInfo: [String.requestKey: request]) }}第三部分定义了一个 AlamofireNotifications 类，遵循 EventMonitor协议，通过 AlamofireNotifications 我们可以在需要的地方添加 Request 的相关通知，灵活地实现对应的方法，不需要统一配置，而发送通知的时机也嵌入到 EventMonitor 的逻辑中，不需要额外处理：/// `EventMonitor` that provides Alamofire’s notifications.public final class AlamofireNotifications: EventMonitor { public func requestDidResume(_ request: Request) { NotificationCenter.default.postNotification(named: Request.didResumeNotification, with: request) } public func requestDidSuspend(_ request: Request) { NotificationCenter.default.postNotification(named: Request.didSuspendNotification, with: request) } public func requestDidCancel(_ request: Request) { NotificationCenter.default.postNotification(named: Request.didCancelNotification, with: request) } public func requestDidFinish(_ request: Request) { NotificationCenter.default.postNotification(named: Request.didFinishNotification, with: request) } public func request(_ request: Request, didResumeTask task: URLSessionTask) { NotificationCenter.default.postNotification(named: Request.didResumeTaskNotification, with: request) } public func request(_ request: Request, didSuspendTask task: URLSessionTask) { NotificationCenter.default.postNotification(named: Request.didSuspendTaskNotification, with: request) } public func request(_ request: Request, didCancelTask task: URLSessionTask) { NotificationCenter.default.postNotification(named: Request.didCancelTaskNotification, with: request) } public func request(_ request: Request, didCompleteTask task: URLSessionTask, with error: AFError?) { NotificationCenter.default.postNotification(named: Request.didCompleteTaskNotification, with: request) }}ParameterEncoderParameterEncoder 协议，一个参数编码器，用来编码支持 Encodable 协议类型到 URLRequest 中，只需要实现一个方法用于处理 parameters 并生成对应的 URLRequest ：func encode&amp;lt;Parameters: Encodable&amp;gt;(_ parameters: Parameters?, into request: URLRequest) throws -&amp;gt; URLRequestJSONParameterEncoder 用于 JSON 的编码，如果 URLRequest 的请求头没有设置 Content-Type ，它就会设置为 application/json 。 JSONParameterEncoder 只支持对 URLRequest 的 httpBody 属性进行设置：open func encode&amp;lt;Parameters: Encodable&amp;gt;(_ parameters: Parameters?, into request: URLRequest) throws -&amp;gt; URLRequest { guard let parameters = parameters else { return request } var request = request do { let data = try encoder.encode(parameters) request.httpBody = data if request.headers[&quot;Content-Type&quot;] == nil { request.headers.update(.contentType(&quot;application/json&quot;)) } } catch { throw AFError.parameterEncodingFailed(reason: .jsonEncodingFailed(error: error)) } return request}URLEncodedFormParameterEncoder 用于生成 URL 编码方式的字符串，与 JSONParameterEncoder 不同，可以追加到 URL 后面，也可以设置到 body 中，取决于 Destination ：enum Destination { case methodDependent // 如果是 .get， .head 和 .delete 方法则追加到 URL 链接后面，否则设置为 httpBody case methodDependent // 全都追加到 URL 链接后面 case httpBody // 全都设置为 httpBody }URLEncodedFormParameterEncoder 的 encoder 属性是 URLEncodedFormEncoder 类型，用于编码时各种类型的转换。open func encode&amp;lt;Parameters: Encodable&amp;gt;(_ parameters: Parameters?, into request: URLRequest) throws -&amp;gt; URLRequest { guard let parameters = parameters else { return request } var request = request // 1. guard let url = request.url else { throw AFError.parameterEncoderFailed(reason: .missingRequiredComponent(.url)) } // 2. guard let method = request.method else { let rawValue = request.method?.rawValue ?? &quot;nil&quot; throw AFError.parameterEncoderFailed(reason: .missingRequiredComponent(.httpMethod(rawValue: rawValue))) } // 3. if destination.encodesParametersInURL(for: method), var components = URLComponents(url: url, resolvingAgainstBaseURL: false) { // 4. let query: String = try Result&amp;lt;String, Error&amp;gt; { try encoder.encode(parameters) } .mapError { AFError.parameterEncoderFailed(reason: .encoderFailed(error: $0)) }.get() let newQueryString = [components.percentEncodedQuery, query].compactMap { $0 }.joinedWithAmpersands() components.percentEncodedQuery = newQueryString.isEmpty ? nil : newQueryString guard let newURL = components.url else { throw AFError.parameterEncoderFailed(reason: .missingRequiredComponent(.url)) } request.url = newURL } else { // 5. if request.headers[&quot;Content-Type&quot;] == nil { request.headers.update(.contentType(&quot;application/x-www-form-urlencoded; charset=utf-8&quot;)) } request.httpBody = try Result&amp;lt;Data, Error&amp;gt; { try encoder.encode(parameters) } .mapError { AFError.parameterEncoderFailed(reason: .encoderFailed(error: $0)) }.get() } return request} 判断 request 是否有 url ，如果没有则报 AFError.parameterEncoderFailed(reason: .missingRequiredComponent(.httpMethod(rawValue: rawValue))) 错误； 判断 request 是否有指定 method ，如果没有则报 AFError.parameterEncoderFailed(reason: .missingRequiredComponent(.httpMethod(rawValue: rawValue))) 错误； 根据参数编码类型判断是否追加到 url 中； mapError 用于转换 Result 为 failure 时的 error ，get() 可以获取 success value ； 参数编码后设置为 httpBody 。ParameterEncodingParameterEncoding 协议，跟 ParameterEncoder 协议的不同之处在于参数不再需要遵循 Encodable 协议，改为直接使用 typealias Parameters = [String: Any] ， 即 key 类型指定为 String 的 Dictionary 。 ParameterEncoding 的作用跟 ParameterEncoder 类似，这里不再赘述。Protected&amp;lt;T&amp;gt;Protected&amp;lt;T&amp;gt; 支持范型，所以我们可以通过 Protected&amp;lt;T&amp;gt; 为各个类，结构体提供线程安全的封装，如同 Protected&amp;lt;T&amp;gt; 的说明。为了实现线程安全，一般都需要一把锁， Protected.swift 里定义了一个 private protocol Lock ，这里对 defer 的使用也非常巧妙：private protocol Lock { func lock() func unlock()}extension Lock { // 执行有返回值的 closure func around&amp;lt;T&amp;gt;(_ closure: () -&amp;gt; T) -&amp;gt; T { lock(); defer { unlock() } return closure() } /// 执行无返回值的 closure func around(_ closure: () -&amp;gt; Void) { lock(); defer { unlock() } closure() }}遵循 Lock 协议需要提供两个方法， lock() 和 unlock() ，而在 Lock 的 extension 里面，提供了两个结合 closure 实现加锁的方法，这两个方法可以满足大部分需要加锁的操作需求。之所以将 Lock 抽离为协议，是因为 Alamofire 需要支持 Linux ，而 Linux 无法使用 os_unfair_lock ，只能使用 pthread_mutex_t 。#if os(Linux)/// 5.1 新增的 MutexLock ，是 pthread_mutex_t 的 wrapper ，为了支持 Linux 平台。final class MutexLock: Lock { private var mutex: UnsafeMutablePointer&amp;lt;pthread_mutex_t&amp;gt; init() { mutex = .allocate(capacity: 1) var attr = pthread_mutexattr_t() pthread_mutexattr_init(&amp;amp;attr) pthread_mutexattr_settype(&amp;amp;attr, .init(PTHREAD_MUTEX_ERRORCHECK)) let error = pthread_mutex_init(mutex, &amp;amp;attr) precondition(error == 0, &quot;Failed to create pthread_mutex&quot;) } deinit { let error = pthread_mutex_destroy(mutex) precondition(error == 0, &quot;Failed to destroy pthread_mutex&quot;) } fileprivate func lock() { let error = pthread_mutex_lock(mutex) precondition(error == 0, &quot;Failed to lock pthread_mutex&quot;) } fileprivate func unlock() { let error = pthread_mutex_unlock(mutex) precondition(error == 0, &quot;Failed to unlock pthread_mutex&quot;) }}#endif#if os(macOS) || os(iOS) || os(watchOS) || os(tvOS)/// 原有的 os_unfair_lock ，苹果平台使用。final class UnfairLock: Lock { private let unfairLock: os_unfair_lock_t init() { unfairLock = .allocate(capacity: 1) unfairLock.initialize(to: os_unfair_lock()) } deinit { unfairLock.deinitialize(count: 1) unfairLock.deallocate() } fileprivate func lock() { os_unfair_lock_lock(unfairLock) } fileprivate func unlock() { os_unfair_lock_unlock(unfairLock) }}#endif在定义了 Lock 类之后，Protected&amp;lt;T&amp;gt; 就可以通过 Lock 来实现线程安全，这里使用了 @propertyWrapper 来进行声明。@propertyWrapperfinal class Protected&amp;lt;T&amp;gt; { #if os(macOS) || os(iOS) || os(watchOS) || os(tvOS) private let lock = UnfairLock() #elseif os(Linux) private let lock = MutexLock() #endif private var value: T init(_ value: T) { self.value = value } /// 访问 wrappedValue 时必须要加锁。 var wrappedValue: T { get { lock.around { value } } set { lock.around { value = newValue } } } var projectedValue: Protected&amp;lt;T&amp;gt; { self } init(wrappedValue: T) { value = wrappedValue } /// 同步获取值或者进行转换 func read&amp;lt;U&amp;gt;(_ closure: (T) -&amp;gt; U) -&amp;gt; U { lock.around { closure(self.value) } } /// 同步修改值，同时可以返回修改后的值。 @discardableResult func write&amp;lt;U&amp;gt;(_ closure: (inout T) -&amp;gt; U) -&amp;gt; U { lock.around { closure(&amp;amp;self.value) } } /// 支持 @dynamicMemberLookup 后实现的方法，使得 Protected 声明的属性可以通过点语法来进行 keyPath 读写 subscript&amp;lt;Property&amp;gt;(dynamicMember keyPath: WritableKeyPath&amp;lt;T, Property&amp;gt;) -&amp;gt; Property { get { lock.around { value[keyPath: keyPath] } } set { lock.around { value[keyPath: keyPath] = newValue } } }}为了方便使用， Protected 又添加了几个扩展。这部分是为 T 实现了 RangeReplaceableCollection 协议后支持的方法，都是集合的 append 方法：extension Protected where T: RangeReplaceableCollection { func append(_ newElement: T.Element) { write { (ward: inout T) in ward.append(newElement) } } func append&amp;lt;S: Sequence&amp;gt;(contentsOf newElements: S) where S.Element == T.Element { write { (ward: inout T) in ward.append(contentsOf: newElements) } } func append&amp;lt;C: Collection&amp;gt;(contentsOf newElements: C) where C.Element == T.Element { write { (ward: inout T) in ward.append(contentsOf: newElements) } }}T 为 Data? 类型时支持 append :extension Protected where T == Data? { func append(_ data: Data) { write { (ward: inout T) in ward?.append(data) } }}T 为 Request.MutableState 时提供一些编辑方法，用于状态转换：extension Protected where T == Request.MutableState { func attemptToTransitionTo(_ state: Request.State) -&amp;gt; Bool { lock.around { guard value.state.canTransitionTo(state) else { return false } value.state = state return true } } func withState(perform: (Request.State) -&amp;gt; Void) { lock.around { perform(value.state) } }}RequestRequest 是 Alamofire 中对应每个网络请求的父类，每次发起网络请求都会生成一个对应的子类对象，根据不同的网络请求会生成 DataRequest ，DataStreamRequest ， DownloadRequest 和 UploadRequest 。调用方不需要直接生成 Request 对象， Request 对象由 Session 负责生成。Request 状态机：// 当 Request 调用 resume() ， suspend() 或者 cancel() 方法时，处理状态之间的转换。public enum State { /// 初始化状态 case initialized /// 当调用 resume() 时就会切换为 resumed 状态，同时也会调用对应的 task 的 resume() 方法 case resumed /// 当调用 suspend() 时就会切换为 suspended 状态，同时也会调用对应的 task 的 suspend() 方法 case suspended /// 当调用 cancel() 时就会切换为 cancelled 状态，同时也会调用对应的 task 的 cancel() 方法 /// 跟 resumed 和 suspended 状态不同，转换至 cancelled 状态后无法再转换至其它状态 case cancelled /// 完成所有请求结果的序列化操作 case finished /// 判断当前状态是否可以转换到其它状态 func canTransitionTo(_ state: State) -&amp;gt; Bool { switch (self, state) { case (.initialized, _): return true case (_, .initialized), (.cancelled, _), (.finished, _): return false case (.resumed, .cancelled), (.suspended, .cancelled), (.resumed, .suspended), (.suspended, .resumed): return true case (.suspended, .suspended), (.resumed, .resumed): return false case (_, .finished): return true } }}状态机转换图如下：Request 定义了一个 MutableState ，用于将可变属性和不可变属性区分开，所有可变属性到放到 MutableState 中，且使用 @Protected 声明，保证线程安全。@Protectedfileprivate var mutableState = MutableState()Request 的不可变属性：/// `UUID` ，作为 `Request` 的唯一 id 使用，用于支持 `Hashble` 和 `Equatable` 协议public let id: UUID/// 串行队列， `Request` 内所有异步调用都是在这个队列内进行public let underlyingQueue: DispatchQueue/// 进行序列化时所使用到的队列，默认跟 `underlyingQueue` 一致public let serializationQueue: DispatchQueue/// `EventMonitor` ，下面会说到具体的作用public let eventMonitor: EventMonitor?/// `Request`&#39;s interceptor ，用于 URL 适配，请求重试，认证等public let interceptor: RequestInterceptor?/// `Request`&#39;s delegate ，用于调用 `Session` 的一些方法public private(set) weak var delegate: RequestDelegate?Request 的方法和具体内容在后面介绍整体的请求流程时再分析。RequestDelegateRequestDelegate 负责提供一些 Session 的方法给 Request 调用， Request 的 delegate 都是 Session 对象。public protocol RequestDelegate: AnyObject { /// 创建 `URLSessionTask` 时使用到的 `URLSessionConfiguration` var sessionConfiguration: URLSessionConfiguration { get } /// 是否直接开始，如果 `startImmediately` 为 `true` ，则当添加第一个 response handler 时就会调用 `resume()` 方法发送请求 var startImmediately: Bool { get } /// 清除 Session 中关于 Request 的记录 func cleanup(after request: Request) /// 异步调用 delegate 的方法，用于判断 Request 是否需要进行重试 func retryResult(for request: Request, dueTo error: AFError, completion: @escaping (RetryResult) -&amp;gt; Void) /// 异步重试 Request func retryRequest(_ request: Request, withDelay timeDelay: TimeInterval?)}RequestTaskMapRequestTaskMap 用于串联 URLSessionTask 和 Request ，当请求结果更新时，需要根据 URLSessionTask 找到对应的 Request ，进行处理。或者通过 Request 找到对应的 URLSessionTask 。定义了两个 Dictionary ，用于实现两者之间的 map ，通过 subscript 方法提供下标设置和访问：struct RequestTaskMap { private var tasksToRequests: [URLSessionTask: Request] private var requestsToTasks: [Request: URLSessionTask] init(tasksToRequests: [URLSessionTask: Request] = [:], requestsToTasks: [Request: URLSessionTask] = [:], taskEvents: [URLSessionTask: (completed: Bool, metricsGathered: Bool)] = [:]) { self.tasksToRequests = tasksToRequests self.requestsToTasks = requestsToTasks self.taskEvents = taskEvents } subscript(_ request: Request) -&amp;gt; URLSessionTask? { get { requestsToTasks[request] } set { guard let newValue = newValue else { guard let task = requestsToTasks[request] else { fatalError(&quot;RequestTaskMap consistency error: no task corresponding to request found.&quot;) } requestsToTasks.removeValue(forKey: request) tasksToRequests.removeValue(forKey: task) taskEvents.removeValue(forKey: task) return } requestsToTasks[request] = newValue tasksToRequests[newValue] = request taskEvents[newValue] = (completed: false, metricsGathered: false) } } subscript(_ task: URLSessionTask) -&amp;gt; Request? { get { tasksToRequests[task] } set { guard let newValue = newValue else { guard let request = tasksToRequests[task] else { fatalError(&quot;RequestTaskMap consistency error: no request corresponding to task found.&quot;) } tasksToRequests.removeValue(forKey: task) requestsToTasks.removeValue(forKey: request) taskEvents.removeValue(forKey: task) return } tasksToRequests[task] = newValue requestsToTasks[newValue] = task taskEvents[task] = (completed: false, metricsGathered: false) } }}EventMonitorEventMonitor 协议可以用来获取 Request 各种方法和状态的相关回调，一种最常见的用法就是打印日志：final class Logger: EventMonitor { let queue = DispatchQueue(label: ...) // Event called when any type of Request is resumed. func requestDidResume(_ request: Request) { print(&quot;Resuming: \\(request)&quot;) } // Event called whenever a DataRequest has parsed a response. func request&amp;lt;Value&amp;gt;(_ request: DataRequest, didParseResponse response: DataResponse&amp;lt;Value, AFError&amp;gt;) { debugPrint(&quot;Finished: \\(response)&quot;) }}let logger = Logger()let session = Session(eventMonitors: [logger])可以看到 Session 支持多个 eventMonitors 。 Alamofire 里面为了让调用方可以更灵活地使用 EventMonitor ，添加了一个 extension ，里面实现了 EventMonitor 的全部方法和属性，这样调用方就不需要实现 EventMonitor 的全部方法，可以根据自己需要添加对应的方法即可，算是一种 protocol 实现 optional 方法的曲线救国方式。为了支持多个 eventMonitors 和抽离 EventMonitor 的处理， Alamofire 实现了一个 CompositeEventMonitor 类，用于组合各个 EventMonitors ，在它自己的回调方法里遍历各个 EventMonitors ，调用对应的方法：/// An `EventMonitor` which can contain multiple `EventMonitor`s and calls their methods on their queues.public final class CompositeEventMonitor: EventMonitor { public let queue = DispatchQueue(label: &quot;org.alamofire.compositeEventMonitor&quot;, qos: .utility) let monitors: [EventMonitor] init(monitors: [EventMonitor]) { self.monitors = monitors } func performEvent(_ event: @escaping (EventMonitor) -&amp;gt; Void) { queue.async { for monitor in self.monitors { monitor.queue.async { event(monitor) } } } } public func urlSession(_ session: URLSession, didBecomeInvalidWithError error: Error?) { performEvent { $0.urlSession(session, didBecomeInvalidWithError: error) } } // ...}Session 中则定义了一个 eventMonitor: CompositeEventMonitor 属性，用于组合多个 EventMonitor 。Alamofire 提供了一个 打印日志的例子： NSLoggingEventMonitor.swiftResponse对请求结果进行封装，根据类型不同分为 DataResponse 和 DownloadResponse 。DataRequest 或者 UploadRequest 请求返回的结果是 DataResponse&amp;lt;Success, Failure: Error&amp;gt; 。public struct DataResponse&amp;lt;Success, Failure: Error&amp;gt; { /// 对应的 URLRequest public let request: URLRequest? /// 服务器返回的 HTTPURLResponse public let response: HTTPURLResponse? /// 服务器返回的 Data public let data: Data? /// 响应对应的 URLSessionTaskMetrics public let metrics: URLSessionTaskMetrics? /// 序列化所消耗的时间 public let serializationDuration: TimeInterval /// 序列化的结果 public let result: Result&amp;lt;Success, Failure&amp;gt; public var value: Success? { result.success } public var error: Failure? { result.failure } public init(request: URLRequest?, response: HTTPURLResponse?, data: Data?, metrics: URLSessionTaskMetrics?, serializationDuration: TimeInterval, result: Result&amp;lt;Success, Failure&amp;gt;) { self.request = request self.response = response self.data = data self.metrics = metrics self.serializationDuration = serializationDuration self.result = result }}跟 Result 类似， Alamofire 也为 DataResponse 添加了 map&amp;lt;NewSuccess&amp;gt; ， tryMap&amp;lt;NewSuccess&amp;gt; ， mapError&amp;lt;NewFailure: Error&amp;gt; 和 tryMapError&amp;lt;NewFailure: Error&amp;gt; 这几个方法。DownloadRequest 对应的则是 DownloadResponse&amp;lt;Success, Failure: Error&amp;gt; ，大部分属性跟 DataResponse 一致，新增以下两个属性：/// 用于存储响应的数据的文件 URLpublic let fileURL: URL?/// 取消请求时所接收到的数据public let resumeData: Data?SessionDelegateSessionDelegate 负责处理 URLSessionDelegate 的相关方法，相当于 Session 和 URLSessionDelegate 的一个中间层。/// 负责调用 Session 的一些方法和获取对应的属性protocol SessionStateProvider: AnyObject { var serverTrustManager: ServerTrustManager? { get } var redirectHandler: RedirectHandler? { get } var cachedResponseHandler: CachedResponseHandler? { get } func request(for task: URLSessionTask) -&amp;gt; Request? func didGatherMetricsForTask(_ task: URLSessionTask) func didCompleteTask(_ task: URLSessionTask, completion: @escaping () -&amp;gt; Void) func credential(for task: URLSessionTask, in protectionSpace: URLProtectionSpace) -&amp;gt; URLCredential? func cancelRequestsForSessionInvalidation(with error: Error?)}下面是默认的 SessionDelegate 实现，你可以在初始化 Session 时提供自定义的 SessionDelegate 的子类：/// Class which implements the various `URLSessionDelegate` methods to connect various Alamofire features.open class SessionDelegate: NSObject { private let fileManager: FileManager // stateProvider 就是 Session weak var stateProvider: SessionStateProvider? // eventMonitor var eventMonitor: EventMonitor? // 提供一个 fileManager 属性，用于管理下载文件 public init(fileManager: FileManager = .default) { self.fileManager = fileManager } // 通过 stateProvider 即 Session 获取对应的 Request func request&amp;lt;R: Request&amp;gt;(for task: URLSessionTask, as type: R.Type) -&amp;gt; R? { guard let provider = stateProvider else { assertionFailure(&quot;StateProvider is nil.&quot;) return nil } return provider.request(for: task) as? R }}当 URLSession 无效后调用 eventMonitor 对应的方法，以及调用 stateProvider 取消所有 requests ：extension SessionDelegate: URLSessionDelegate { open func urlSession(_ session: URLSession, didBecomeInvalidWithError error: Error?) { eventMonitor?.urlSession(session, didBecomeInvalidWithError: error) stateProvider?.cancelRequestsForSessionInvalidation(with: error) }}SessionDelegate 也定义了 URLSessionTaskDelegate ， URLSessionDataDelegate 和 URLSessionDownloadDelegate 的方法，基本实现和上面的大同小异，负责调用 EventMonitor ， Session 和 Request 的相关方法。URLConvertible+URLRequestConvertibleURLconvertible 协议，用于转化为 URL 。当我们发起一个网络请求时就需要构建一个对应的 URL ，为了方便调用方可以直接传递 String ， URL 或者 URLComponents 来生成 URL ，而不需要自己先生成 URL 。同时也可以自定义一些生成 URL 的规则，只要支持 URLConvertible 协议即可。public protocol URLConvertible { func asURL() throws -&amp;gt; URL}String ， URL 和 URLComponents 默认支持 URLConvertible ：extension String: URLConvertible { public func asURL() throws -&amp;gt; URL { guard let url = URL(string: self) else { throw AFError.invalidURL(url: self) } return url }}extension URL: URLConvertible { public func asURL() throws -&amp;gt; URL { self }}extension URLComponents: URLConvertible { public func asURL() throws -&amp;gt; URL { guard let url = url else { throw AFError.invalidURL(url: self) } return url }}所以 Alamofire 默认支持以下三种发起请求的方式：let urlString = &quot;https://httpbin.org/get&quot;AF.request(urlString)let url = URL(string: urlString)!AF.request(url)let urlComponents = URLComponents(url: url, resolvingAgainstBaseURL: true)!AF.request(urlComponents)URLRequestConvertible 则是用于生成 URLRequest 的协议，通过 URLRequest 可以生成对应的 URLSessionTask 。 URLRequest 默认支持 URLRequestConvertible ：public protocol URLRequestConvertible { func asURLRequest() throws -&amp;gt; URLRequest}extension URLRequestConvertible { public var urlRequest: URLRequest? { try? asURLRequest() }}extension URLRequest: URLRequestConvertible { public func asURLRequest() throws -&amp;gt; URLRequest { self }}// 给 URLRequest 添加了一个初始化方法，方便在初始化时直接设置 method 和 allHTTPHeaderFieldsextension URLRequest { public init(url: URLConvertible, method: HTTPMethod, headers: HTTPHeaders? = nil) throws { let url = try url.asURL() self.init(url: url) httpMethod = method.rawValue allHTTPHeaderFields = headers?.dictionary }}通过 URLRequest 发送请求：let url = URL(string: &quot;https://httpbin.org/post&quot;)!var urlRequest = URLRequest(url: url)urlRequest.method = .postlet parameters = [&quot;foo&quot;: &quot;bar&quot;]do { urlRequest.httpBody = try JSONEncoder().encode(parameters)} catch { // Handle error.}urlRequest.headers.add(.contentType(&quot;application/json&quot;))AF.request(urlRequest)这样可以把具体对象抽离出来，提供的参数只需要支持 URLRequestConvertible 协议即可。当我们的 App 有大量的请求接口需要进行定义时，可以通过 URLRequestConvertible 协议来定义相关的参数编码，请求方法等。如下面代码所示，可以定一个 enum Router ， 支持 URLRequestConvertible 类型，这样在调用时生成对应的 enum 就可以了。这为调用方提供了横向扩展的能力， Alamofire 不需要知道具体的对象类型，只需要通过 URLRequestConvertible 来进行 URLRequest 转换，这样有利于我们对网络层的请求进行组织和整理。enum Router: URLRequestConvertible { case get([String: String]), post([String: String]) var baseURL: URL { return URL(string: &quot;https://httpbin.org&quot;)! } var method: HTTPMethod { switch self { case .get: return .get case .post: return .post } } var path: String { switch self { case .get: return &quot;get&quot; case .post: return &quot;post&quot; } } func asURLRequest() throws -&amp;gt; URLRequest { let url = baseURL.appendingPathComponent(path) var request = URLRequest(url: url) request.method = method switch self { case let .get(parameters): request = try URLEncodedFormParameterEncoder().encode(parameters, into: request) case let .post(parameters): request = try JSONParameterEncoder().encode(parameters, into: request) } return request }}Result+AlamofireAlamofire 为了使用 Result 更方便而定义的一些便捷方法。使用 typealias 定义了一个 AFResult ，其 Failure 类型固定为 AFError ：public typealias AFResult&amp;lt;Success&amp;gt; = Result&amp;lt;Success, AFError&amp;gt;判断是否为 .success 和 .failure ：var isSuccess: Bool { guard case .success = self else { return false } return true}var isFailure: Bool { !isSuccess}获取对应的值：var success: Success? { guard case let .success(value) = self else { return nil } return value}var failure: Failure? { guard case let .failure(error) = self else { return nil } return error}通过 Success 和 Failure 进行初始化：init(value: Success, error: Failure?) { if let error = error { self = .failure(error) } else { self = .success(value) }}tryMap 对 Success 进行转换，在转换过程中可以抛出 Error ：func tryMap&amp;lt;NewSuccess&amp;gt;(_ transform: (Success) throws -&amp;gt; NewSuccess) -&amp;gt; Result&amp;lt;NewSuccess, Error&amp;gt; { switch self { case let .success(value): do { return try .success(transform(value)) } catch { return .failure(error) } case let .failure(error): return .failure(error) }}用法如下：let possibleData: Result&amp;lt;Data, Error&amp;gt; = .success(Data(...))let possibleObject = possibleData.tryMap { try JSONSerialization.jsonObject(with: $0)}tryMapError 对 Failure 进行转换，在转换过程中也可以抛出 Error ：func tryMapError&amp;lt;NewFailure: Error&amp;gt;(_ transform: (Failure) throws -&amp;gt; NewFailure) -&amp;gt; Result&amp;lt;Success, Error&amp;gt; { switch self { case let .failure(error): do { return try .failure(transform(error)) } catch { return .failure(error) } case let .success(value): return .success(value) }}用法如下：let possibleData: Result&amp;lt;Data, Error&amp;gt; = .success(Data(...))let possibleObject = possibleData.tryMapError { try someFailableFunction(taking: $0)}整体流程Session 作为 Alamofire 的第一层入口，所有 Alamofire.swift 的请求方法都会调用 Session 里面对应的方法。Session 负责创建和管理 Alamofire 的 Request 类。同时也提供一些公共的方法给所有 Request 使用，如请求队列，信任管理，重定向处理和响应缓存处理等。Session 类似于一个 Manager 的角色，处理各个请求的创建流程。当创建一个 Request 的子类后， Alamofire 会进行一系列的操作来完成这个请求。一个成功的请求包括以下流程： 一些初始化参数，比如 HTTP 方法， HTTP 头和参数等会被封装进内部的 URLRequestConvertible 值中，用于初始化 Request ； 调用 URLRequestConvertible 的 asURLRequest() 方法来创建第一个 URLRequest 。 URLRequest 会存储到 Request 的 mutableState.requests 属性中。如果有定义 RequestModifier ， 在生成 URLRequest 会进行调用来调整 URLRequest ； 如果 Session 或者 Request 有提供 RequestAdapters 或者 RequestInterceptors ，则会对之前生成的 URLRequest 进行调整，同时也会存储到 Request 的 mutableState.requests 属性中； Session 调用 Request 的方法来生成对应的 URLSessionTask ，不同的 Request 子类 会生成不同的 URLSessionTask ； 当 URLSessionTask 完成任务，且已经收集到 URLSessionTaskMetrics ， Request 就会执行自己的 Validators 来验证请求结果是否正确； 通过验证后， Request 就会执行 mutableState.responseSerializers 来处理请求结果。在上面这些步骤中，每个步骤都有可能产生错误或者接收到网络返回的错误结果，这些错误会传递给对应的 Request 。在处理结果时会判断是否需要重试。当 Error 传递给 Request 后，Request 会调用对应的 RequestRetriers 来判断是否需要进行重试，如果需要进行重试，则再走一次上面的流程。下面以 DataRequest 为例讲一下发起网络请求的整体流程。生成 DataRequestAlamofire 为发起 DataRequest 提供了三个接口： parameters 为 Parameters ，即 [String: Any] ：open func request(_ convertible: URLConvertible, method: HTTPMethod = .get, parameters: Parameters? = nil, encoding: ParameterEncoding = URLEncoding.default, headers: HTTPHeaders? = nil, interceptor: RequestInterceptor? = nil, requestModifier: RequestModifier? = nil) -&amp;gt; DataRequest { let convertible = RequestConvertible(url: convertible, method: method, parameters: parameters, encoding: encoding, headers: headers, requestModifier: requestModifier) return request(convertible, interceptor: interceptor)}定义一个 struct RequestConvertible ，支持 URLRequestConvertible 协议，负责处理参数的编码和生成对应的 URLRequest ：public typealias RequestModifier = (inout URLRequest) throws -&amp;gt; Voidstruct RequestConvertible: URLRequestConvertible { let url: URLConvertible let method: HTTPMethod let parameters: Parameters? let encoding: ParameterEncoding let headers: HTTPHeaders? let requestModifier: RequestModifier? func asURLRequest() throws -&amp;gt; URLRequest { var request = try URLRequest(url: url, method: method, headers: headers) try requestModifier?(&amp;amp;request) return try encoding.encode(request, with: parameters) }} parameters 支持 Encodable ：open func request&amp;lt;Parameters: Encodable&amp;gt;(_ convertible: URLConvertible, method: HTTPMethod = .get, parameters: Parameters? = nil, encoder: ParameterEncoder = URLEncodedFormParameterEncoder.default, headers: HTTPHeaders? = nil, interceptor: RequestInterceptor? = nil, requestModifier: RequestModifier? = nil) -&amp;gt; DataRequest { let convertible = RequestEncodableConvertible(url: convertible, method: method, parameters: parameters, encoder: encoder, headers: headers, requestModifier: requestModifier) return request(convertible, interceptor: interceptor)}由于参数编码方式不同，所以需要定义一个 struct RequestEncodableConvertible&amp;lt;Parameters: Encodable&amp;gt; ，来处理参数为 Encodable 时的编码和生成 URLRequest ：struct RequestEncodableConvertible&amp;lt;Parameters: Encodable&amp;gt;: URLRequestConvertible { let url: URLConvertible let method: HTTPMethod let parameters: Parameters? let encoder: ParameterEncoder let headers: HTTPHeaders? let requestModifier: RequestModifier? func asURLRequest() throws -&amp;gt; URLRequest { var request = try URLRequest(url: url, method: method, headers: headers) try requestModifier?(&amp;amp;request) return try parameters.map { try encoder.encode($0, into: request) } ?? request }} 上面两个接口经过处理生成对应的 URLRequestConvertible 后会调用这个接口来生成 DataRequest ，在使用的时候也可以自己生成 URLRequestConvertible ，直接调用这个接口：open func request(_ convertible: URLRequestConvertible, interceptor: RequestInterceptor? = nil) -&amp;gt; DataRequest { let request = DataRequest(convertible: convertible, underlyingQueue: rootQueue, serializationQueue: serializationQueue, eventMonitor: eventMonitor, interceptor: interceptor, delegate: self) perform(request) return request}这样可以统一 DataRequest 的处理流程，虽然可以通过不同的参数来生成 DataRequest ，但是在 Session 内部的处理时，会通过 URLRequestConvertible 进行转换，收敛到同一个接口中。perform这里 perform 跟 resume 不同，不会发起真正的网络请求，只是用来进行进行请求前的准备工作：func perform(_ request: Request) { rootQueue.async { // 1. guard !request.isCancelled else { return } // 2. self.activeRequests.insert(request) self.requestQueue.async { // 3. switch request { case let r as UploadRequest: self.performUploadRequest(r) // UploadRequest must come before DataRequest due to subtype relationship. case let r as DataRequest: self.performDataRequest(r) case let r as DownloadRequest: self.performDownloadRequest(r) case let r as DataStreamRequest: self.performDataStreamRequest(r) default: fatalError(&quot;Attempted to perform unsupported Request subclass: \\(type(of: request))&quot;) } } }} 判断 request 是否有取消，因为有可能还没发起请求就已经被取消了； 添加到 activeRequests 中； 使用 switch case let 进行类型判断然后调用 performSetupOperations 方法进行一些请求前的准备工作。在处理过程中会判断是否有设置 adapter ，如果有设置 adapter ，则调用 adapter 对请求做一次适配。func performSetupOperations(for request: Request, convertible: URLRequestConvertible) { dispatchPrecondition(condition: .onQueue(requestQueue)) let initialRequest: URLRequest do { // 1. initialRequest = try convertible.asURLRequest() // 2. try initialRequest.validate() } catch { rootQueue.async { request.didFailToCreateURLRequest(with: error.asAFError(or: .createURLRequestFailed(error: error))) } return } // 3. rootQueue.async { request.didCreateInitialURLRequest(initialRequest) } guard !request.isCancelled else { return } // 4. guard let adapter = adapter(for: request) else { rootQueue.async { self.didCreateURLRequest(initialRequest, for: request) } return } // 5. adapter.adapt(initialRequest, for: self) { result in do { let adaptedRequest = try result.get() try adaptedRequest.validate() self.rootQueue.async { request.didAdaptInitialRequest(initialRequest, to: adaptedRequest) self.didCreateURLRequest(adaptedRequest, for: request) } } catch { self.rootQueue.async { request.didFailToAdaptURLRequest(initialRequest, withError: .requestAdaptationFailed(error: error)) } } }} 尝试生成对应的 URLRequest ； 检验 URLRequest 是否符合格式要求，如果是 GET 请求，而且 httpBody 中有数据，就会报一个 bodyDataInGETRequest 的错； 调用 request 的 didCreateInitialURLRequest 方法，负责更新 request 的 mutableState 和调用 eventMonitor 对应的方法； 判断是否有 adapter ，如果没有则调用 didCreateURLRequest 进行一些最后的处理工作； 使用 adapter 对 request 进行转换，然后调用 request.didAdaptInitialRequest 和 didCreateURLRequest ；可以看到上面的代码在调用 request 的方法时都会通过 rootRequeue 进行异步调用，以保证线程安全。再看一下 Request 中对应的方法都做了哪些处理：func didCreateInitialURLRequest(_ request: URLRequest) { dispatchPrecondition(condition: .onQueue(underlyingQueue)) $mutableState.write { $0.requests.append(request) } eventMonitor?.request(self, didCreateInitialURLRequest: request)}Session 中调用 request 的方法都跟上面的实现类似： 更新 request.state ； 通过 eventMonitor 调用相关回调；didCreateURLRequest 则负责创建对应的 URLSessionTask ，在 requestTaskMap 中添加对应的记录：func didCreateURLRequest(_ urlRequest: URLRequest, for request: Request) { dispatchPrecondition(condition: .onQueue(rootQueue)) request.didCreateURLRequest(urlRequest) guard !request.isCancelled else { return } let task = request.task(for: urlRequest, using: session) requestTaskMap[request] = task request.didCreateTask(task) // 根据 request 的 state 对 task 进行操作 updateStatesForTask(task, request: request)}这里之所以需要根据 request 的 state 对 task 进行操作，是因为当 request 进行重试时也需要调用这个方法，所以如果是重试，就需要根据 request 的 state 来调用 task 对应的方法：func updateStatesForTask(_ task: URLSessionTask, request: Request) { dispatchPrecondition(condition: .onQueue(rootQueue)) request.withState { state in switch state { case .initialized, .finished: break case .resumed: task.resume() rootQueue.async { request.didResumeTask(task) } case .suspended: task.suspend() rootQueue.async { request.didSuspendTask(task) } case .cancelled: task.resume() task.cancel() rootQueue.async { request.didCancelTask(task) } } }}至此已经走完了一个 Request 的创建流程，流程如下图所示：响应处理进度我们可以通过相关的 cloures 来设置进度的回调：AF.request(...) .uploadProgress { progress in print(progress) } .downloadProgress { progress in print(progress) } .responseDecodable(of: SomeType.self) { response in debugPrint(response) }@discardableResultpublic func downloadProgress(queue: DispatchQueue = .main, closure: @escaping ProgressHandler) -&amp;gt; Self { mutableState.downloadProgressHandler = (handler: closure, queue: queue) return self}@discardableResultpublic func uploadProgress(queue: DispatchQueue = .main, closure: @escaping ProgressHandler) -&amp;gt; Self { mutableState.uploadProgressHandler = (handler: closure, queue: queue) return self}使用 mutableState 来保存相关的 uploadProgressHandler 和 downloadProgressHandler ， uploadProgressHandler 和 downloadProgressHandler 只支持设置一个，同时会返回 Self ，这样就可以进行链式调用。在 SessionDelegate 中，如果有进度更新，就会通过 stateProvider(session) 获取 request ，调用 request 对应的方法进行进度更新：// SessionDelegateopen func urlSession(_ session: URLSession, task: URLSessionTask, didSendBodyData bytesSent: Int64, totalBytesSent: Int64, totalBytesExpectedToSend: Int64) { eventMonitor?.urlSession(session, task: task, didSendBodyData: bytesSent, totalBytesSent: totalBytesSent, totalBytesExpectedToSend: totalBytesExpectedToSend) stateProvider?.request(for: task)?.updateUploadProgress(totalBytesSent: totalBytesSent, totalBytesExpectedToSend: totalBytesExpectedToSend)}// Requestfunc updateUploadProgress(totalBytesSent: Int64, totalBytesExpectedToSend: Int64) { uploadProgress.totalUnitCount = totalBytesExpectedToSend uploadProgress.completedUnitCount = totalBytesSent uploadProgressHandler?.queue.async { self.uploadProgressHandler?.handler(self.uploadProgress) }}这些closure 的配置需要在添加 response handler 前，因为添加 response handler 之后， request 有可能会直接调用 resume() 方法，导致在更新进度时可能 uploadProgress 和 downloadProgress 还没进行配置，错过部分进度更新的回调。重定向Alamofire 提供了一个重定向协议 RedirectHandler ，提供了以下方法，可以生成新的 URLRequest ，也可以直接调用 completion(nil) 来拒绝重定向：public protocol RedirectHandler { func task(_ task: URLSessionTask, willBeRedirectedTo request: URLRequest, for response: HTTPURLResponse, completion: @escaping (URLRequest?) -&amp;gt; Void)}let redirector = Redirector(behavior: .follow)AF.request(...) .redirect(using: redirector) .responseDecodable(of: SomeType.self) { response in debugPrint(response) }Redirector 为 Alamofire 提供了的一个重定向默认实现，在重定向时根据 behavior 来判断如何进行重定向的相关操作：public enum Behavior { case follow case doNotFollow case modify((URLSessionTask, URLRequest, HTTPURLResponse) -&amp;gt; URLRequest?)}extension Redirector: RedirectHandler { public func task(_ task: URLSessionTask, willBeRedirectedTo request: URLRequest, for response: HTTPURLResponse, completion: @escaping (URLRequest?) -&amp;gt; Void) { switch behavior { case .follow: completion(request) case .doNotFollow: completion(nil) case let .modify(closure): let request = closure(task, request, response) completion(request) } }}在设置完 redirectHandler 后， SessionDelegate 中也会调用对应的 redirectHandler 进行重定向：open func urlSession(_ session: URLSession, task: URLSessionTask, willPerformHTTPRedirection response: HTTPURLResponse, newRequest request: URLRequest, completionHandler: @escaping (URLRequest?) -&amp;gt; Void) { eventMonitor?.urlSession(session, task: task, willPerformHTTPRedirection: response, newRequest: request) // 获取对应的 redirectHandler ，如果 request 的 redirectHandler 为 nil ，就尝试获取 session 的 redirectHandler if let redirectHandler = stateProvider?.request(for: task)?.redirectHandler ?? stateProvider?.redirectHandler { redirectHandler.task(task, willBeRedirectedTo: request, for: response, completion: completionHandler) } else { completionHandler(request) }}自定义缓存Alamofire 提供了一个自定义协议 CachedResponseHandler ，用于判断是否需要缓存当前的 HTTP 响应结果，可以生成新的 CachedURLResponse ，也可以调用 completion(nil) 来拒绝进行缓存：public protocol CachedResponseHandler { func dataTask(_ task: URLSessionDataTask, willCacheResponse response: CachedURLResponse, completion: @escaping (CachedURLResponse?) -&amp;gt; Void)}跟 RedirectHandler 类似， ResponseCacher 是 Alamofire 提供的遵循 CachedResponseHandler 协议的一个类，也是通过 Behavior 来判断如何实现缓存。open func urlSession(_ session: URLSession, dataTask: URLSessionDataTask, willCacheResponse proposedResponse: CachedURLResponse, completionHandler: @escaping (CachedURLResponse?) -&amp;gt; Void) { eventMonitor?.urlSession(session, dataTask: dataTask, willCacheResponse: proposedResponse) // 获取对应的 cachedResponseHandler ，如果 request 的 cachedResponseHandler 为 nil ，就尝试获取 session 的 cachedResponseHandler if let handler = stateProvider?.request(for: dataTask)?.cachedResponseHandler ?? stateProvider?.cachedResponseHandler { handler.dataTask(dataTask, willCacheResponse: proposedResponse, completion: completionHandler) } else { completionHandler(proposedResponse) }}其它的一些相关配置的实现原理也大致相同，这里不再赘述。处理请求结果Request 处理请求结果的流程：每个 ResponseSerializer 完成处理后都会调用 responseSerializerDidComplete(completion: @escaping () -&amp;gt; Void) ，获取下一个 nextResponseSerializer() 。DataRequest 和 DownloadRequest 都提供了对结果不做任何序列化操作的方法：// DataRequestfunc response(queue: DispatchQueue = .main, completionHandler: @escaping (AFDataResponse&amp;lt;Data?&amp;gt;) -&amp;gt; Void) -&amp;gt; Self// DownloadRequestfunc response(queue: DispatchQueue = .main, completionHandler: @escaping (AFDownloadResponse&amp;lt;URL?&amp;gt;) -&amp;gt; Void) -&amp;gt; SelfDataRequest 对应的方法实现：func response(queue: DispatchQueue = .main, completionHandler: @escaping (AFDataResponse&amp;lt;Data?&amp;gt;) -&amp;gt; Void) -&amp;gt; Self { appendResponseSerializer { let result = AFResult&amp;lt;Data?&amp;gt;(value: self.data, error: self.error) // 1. self.underlyingQueue.async { // 2. let response = DataResponse(request: self.request, response: self.response, data: self.data, metrics: self.metrics, serializationDuration: 0, result: result) self.eventMonitor?.request(self, didParseResponse: response) // 3. self.responseSerializerDidComplete { queue.async { completionHandler(response) } } } } return self} 完成序列化操作后，转换到 underlyingQueue 中进行处理，因为在进行序列化操作时是在 serializationQueue 进行处理； 生成对应的 DataResponse ，因为不做任何序列化操作，所以 serializationDuration 直接设置 0 ； 调用 responseSerializerDidComplete 添加 completionHandler ；添加 ResponseSerializer ：func appendResponseSerializer(_ closure: @escaping () -&amp;gt; Void) { $mutableState.write { mutableState in mutableState.responseSerializers.append(closure) // 1. if mutableState.state == .finished { mutableState.state = .resumed } // 2. if mutableState.responseSerializerProcessingFinished { underlyingQueue.async { self.processNextResponseSerializer() } } // 3. if mutableState.state.canTransitionTo(.resumed) { underlyingQueue.async { if self.delegate?.startImmediately == true { self.resume() } } } }} 这里之所以把状态由 .finished 为 .resumed ，是因为如果 ResponseSerializer 序列化失败，会重新发送请求，而重新发送请求时会调用 updateStatesForTask 方法，只有 request 的状态为 resumed 时才会调用 task.resume() ， 所以这里要设置为 resumed ，使得可以调用 task.resume() ，重新发送请求； 是否已经处理完其它 ResponseSerializer ，如果已经处理完，则直接开始处理新增的 ResponseSerializer ； 是否需要直接开始进行网络请求；调用下一个 ResponseSerializer 进行处理，如果所有 ResponseSerializer 都处理完毕则调用所有的 completions ：func processNextResponseSerializer() { guard let responseSerializer = nextResponseSerializer() else { var completions: [() -&amp;gt; Void] = [] $mutableState.write { mutableState in completions = mutableState.responseSerializerCompletions // 1. mutableState.responseSerializers.removeAll() mutableState.responseSerializerCompletions.removeAll() if mutableState.state.canTransitionTo(.finished) { mutableState.state = .finished } mutableState.responseSerializerProcessingFinished = true mutableState.isFinishing = false } completions.forEach { $0() } cleanup() return } // 3. serializationQueue.async { responseSerializer() } } 如果已经完成所有序列化操作，优先移除所有的 ResponseSerializers 和 ResponseSerializerCompletions ， 这个 PR 有提到具体原因； 执行所有 ResponseSerializerCompletions ； 如果还有序列化操作未执行，就先执行；获取下一个序列化操作，因为只有完成了序列化操作后才会添加对应的 ResponseSerializerCompletion ，所以通过 responseSerializers 和 responseSerializerCompletions 的 count 来比较即可知道是否还有序列化操作未处理：func nextResponseSerializer() -&amp;gt; (() -&amp;gt; Void)? { var responseSerializer: (() -&amp;gt; Void)? $mutableState.write { mutableState in let responseSerializerIndex = mutableState.responseSerializerCompletions.count if responseSerializerIndex &amp;lt; mutableState.responseSerializers.count { responseSerializer = mutableState.responseSerializers[responseSerializerIndex] } } return responseSerializer}添加序列化操作Alamofire 提供了 DataResponseSerializerProtocol 和 DownloadResponseSerializerProtocol 协议，用于添加一些自定义的序列化操作：public protocol DataResponseSerializerProtocol { associatedtype SerializedObject func serialize(request: URLRequest?, response: HTTPURLResponse?, data: Data?, error: Error?) throws -&amp;gt; SerializedObject}public protocol DownloadResponseSerializerProtocol { associatedtype SerializedObject func serializeDownload(request: URLRequest?, response: HTTPURLResponse?, fileURL: URL?, error: Error?) throws -&amp;gt; SerializedObject}这两个协议都比较好理解，定义了一个关联类型 SerializedObject 和一个用于将原始数据转换为 SerializedObject 的方法。 DataRequest 提供了以下方法给我们添加自定义的序列化操作：public func response&amp;lt;Serializer: DataResponseSerializerProtocol&amp;gt;(queue: DispatchQueue = .main, responseSerializer: Serializer, completionHandler: @escaping (AFDataResponse&amp;lt;Serializer.SerializedObject&amp;gt;) -&amp;gt; Void) -&amp;gt; Self { appendResponseSerializer { // 1. 进行序列化转换，记录时间 let start = ProcessInfo.processInfo.systemUptime let result: AFResult&amp;lt;Serializer.SerializedObject&amp;gt; = Result { try responseSerializer.serialize(request: self.request, response: self.response, data: self.data, error: self.error) }.mapError { error in error.asAFError(or: .responseSerializationFailed(reason: .customSerializationFailed(error: error))) } let end = ProcessInfo.processInfo.systemUptime self.underlyingQueue.async { // 2. 生成对应的 DataResponse ，调用 eventMonitor 对应的方法 let response = DataResponse(request: self.request, response: self.response, data: self.data, metrics: self.metrics, serializationDuration: end - start, result: result) self.eventMonitor?.request(self, didParseResponse: response) // 3. 如果没有错误，就调用 completionHandler guard let serializerError = result.failure, let delegate = self.delegate else { self.responseSerializerDidComplete { queue.async { completionHandler(response) } } return } // 4. 判断是否重试 delegate.retryResult(for: self, dueTo: serializerError) { retryResult in var didComplete: (() -&amp;gt; Void)? defer { if let didComplete = didComplete { self.responseSerializerDidComplete { queue.async { didComplete() } } } } switch retryResult { case .doNotRetry: didComplete = { completionHandler(response) } case let .doNotRetryWithError(retryError): let result: AFResult&amp;lt;Serializer.SerializedObject&amp;gt; = .failure(retryError.asAFError(orFailWith: &quot;Received retryError was not already AFError&quot;)) // 5. 不进行重试 let response = DataResponse(request: self.request, response: self.response, data: self.data, metrics: self.metrics, serializationDuration: end - start, result: result) didComplete = { completionHandler(response) } case .retry, .retryWithDelay: delegate.retryRequest(self, withDelay: retryResult.delay) } } } } return self}而 Alamofire 也提供了一些常见的序列化操作给我们使用： responseString(queue:encoding:completionHandler:) 通过 StringResponseSerializer 将 Data 转换为 String ； responseJSON(queue:options:completionHandler) 通过 JSONResponseSerializer(JSONSerialization) 将 Data 转换为 JSON 对象； responseDecodable(of:queue:decoder:completionHandler:) 通过 DecodableResponseSerializer 将 Data 转换为 Decodable 对象， decoder 默认为 JSONDecoder ；这里也是通过协议来对自动的序列化操作进行抽象。NetworkReachabilityManagerNetworkReachabilityManager 是 Alamofire 提供的用于检测网络状态的工具类。NetworkReachabilityManager 只用获取监测网络状态，在设备的网络状态改变时收到通知，不要以此来判断是否可以连接某个 host 或者地址。NetworkReachabilityStatusNetworkReachabilityManager 首先定义了 NetworkReachabilityStatus 的 enum 类型：public enum NetworkReachabilityStatus { /// 不确定网络状态 case unknown /// 无法连接 case notReachable /// 可以连接，具体类型由 ConnectionType 定义 case reachable(ConnectionType) init(_ flags: SCNetworkReachabilityFlags) { // isActuallyReachable 为 Alamofire 定义的 extension 属性 guard flags.isActuallyReachable else { self = .notReachable; return } // 先初始化为 .ethernetOrWiFi ，然后判断是否为蜂窝网络，如果是蜂窝网络再转为 . cellular var networkStatus: NetworkReachabilityStatus = .reachable(.ethernetOrWiFi) if flags.isCellular { networkStatus = .reachable(.cellular) } self = networkStatus } /// 定义可以连接时的网络状态类型 public enum ConnectionType { case ethernetOrWiFi case cellular }}MutableStateMutableState 为 NetworkReachabilityManager 一些可变状态的封装：struct MutableState { var listener: Listener? var listenerQueue: DispatchQueue? var previousStatus: NetworkReachabilityStatus?}NetworkReachabilityManager 的 mutableState 属性使用 @Protected 进行声明，保证线程安全。属性监听 0.0.0.0 地址的单例， listenerQueue 为 .main ：public static let `default` = NetworkReachabilityManager()/// 当前的网络状态是否可以连接open var isReachable: Bool { return isReachableOnCellular || isReachableOnEthernetOrWiFi }/// 当前的蜂窝网络是否可用/// - 用于判断一些是否推荐执行一些需要高或者低带宽的请求，如视频自动播放open var isReachableOnCellular: Bool { return status == .reachable(.cellular) }/// 当前的 WiFi 是否可用open var isReachableOnEthernetOrWiFi: Bool { return status == .reachable(.ethernetOrWiFi) }/// `DispatchQueue` 系统 Reachability的更新 queue.public let reachabilityQueue = DispatchQueue(label: &quot;org.alamofire.reachabilityQueue&quot;)/// 可选的 SCNetworkReachabilityFlagsopen var flags: SCNetworkReachabilityFlags? { var flags = SCNetworkReachabilityFlags() return (SCNetworkReachabilityGetFlags(reachability, &amp;amp;flags)) ? flags : nil}/// 当前网络状态，使用 Optional 的 map 方法动态生成open var status: NetworkReachabilityStatus { return flags.map(NetworkReachabilityStatus.init) ?? .unknown}/// 系统的 `SCNetworkReachability` ，用于发送通知private let reachability: SCNetworkReachability/// 线程安全的 `MutableState`@Protectedprivate var mutableState = MutableState()初始化NetworkReachabilityManager 提供了两个 convenience init? 方法：// 监听指定 host public convenience init?(host: String) { guard let reachability = SCNetworkReachabilityCreateWithName(nil, host) else { return nil } self.init(reachability: reachability)}// 监听 0.0.0.0 地址public convenience init?() { var zero = sockaddr() zero.sa_len = UInt8(MemoryLayout&amp;lt;sockaddr&amp;gt;.size) zero.sa_family = sa_family_t(AF_INET) guard let reachability = SCNetworkReachabilityCreateWithAddress(nil, &amp;amp;zero) else { return nil } self.init(reachability: reachability)}// 上面两个方法如果成功生成 SCNetworkReachability ，到最后会调用这个方法来进行初始化private init(reachability: SCNetworkReachability) { self.reachability = reachability}流程startListening 添加监听：@discardableResultopen func startListening(onQueue queue: DispatchQueue = .main, onUpdatePerforming listener: @escaping Listener) -&amp;gt; Bool { stopListening() // 修改 mutableState ，这里使用的是 @propertyWrapper 的语法糖，直接访问 projectedValue 也就是 Protected&amp;lt;MutableState&amp;gt; // 这样就可以调用 Protected&amp;lt;MutableState&amp;gt; 的 write 方法 $mutableState.write { state in state.listenerQueue = queue state.listener = listener } // 与 SCNetworkReachability 交互，添加 callBack 。 var context = SCNetworkReachabilityContext(version: 0, info: Unmanaged.passUnretained(self).toOpaque(), retain: nil, release: nil, copyDescription: nil) let callback: SCNetworkReachabilityCallBack = { _, flags, info in guard let info = info else { return } let instance = Unmanaged&amp;lt;NetworkReachabilityManager&amp;gt;.fromOpaque(info).takeUnretainedValue() instance.notifyListener(flags) } let queueAdded = SCNetworkReachabilitySetDispatchQueue(reachability, reachabilityQueue) let callbackAdded = SCNetworkReachabilitySetCallback(reachability, callback, &amp;amp;context) // 因为 SCNetworkReachability 不会在初始化时调用一次 callBack ，所以这里有手动调一下。 if let currentFlags = flags { reachabilityQueue.async { self.notifyListener(currentFlags) } } return callbackAdded &amp;amp;&amp;amp; queueAdded}由于 NetworkReachabilityManager.default 获取的是单例，调用 startListening 会清空之前的 mutableState ，导致无法调用之前的 listener ，所以还是使用自己生成的 NetworkReachabilityManager 比较好，各自管理自己的 mutableState 。notifyListener 网络状态变化时调用，执行对应的 listener ：func notifyListener(_ flags: SCNetworkReachabilityFlags) { let newStatus = NetworkReachabilityStatus(flags) $mutableState.write { state in // 如果状态相等就不调用 listener guard state.previousStatus != newStatus else { return } state.previousStatus = newStatus let listener = state.listener state.listenerQueue?.async { listener?(newStatus) } }}stopListening 停止监听，调用 SCNetworkReachabilitySetCallback 和 SCNetworkReachabilitySetDispatchQueue 清空 reachability ，然后清空 mutableState 的属性：open func stopListening() { SCNetworkReachabilitySetCallback(reachability, nil, nil) SCNetworkReachabilitySetDispatchQueue(reachability, nil) $mutableState.write { state in state.listener = nil state.listenerQueue = nil state.previousStatus = nil }}总结 不要通过 NetworkReachabilityManager 来判断是否应该发送请求； 当网络状态切换时，可以考虑重新发送请求； 网络状态可以为用户请求失败提供一些更明确的提示； 判断用户的网络状态来执行不同的流量策略，如视频的清晰度；最后Alamofire 作为一个使用 Swift 编写的网络库，提供的发起网络请求接口十分简单，学习成本非常低，有不少值得学习和借鉴的地方： 使用协议进行抽象； 使用 @propertyWrapper 来实现属性的线程安全； 支持链式调用，使用上更加优雅和方便； 借用 extension 来为 protocol 提供默认的方法实现，从而使得 protocol 的方法是可选的； ……" }, { "title": "Swift 与指针", "url": "/posts/Swift-and-Pointer/", "categories": "", "tags": "Swift", "date": "2020-05-18 21:27:24 +0800", "snippet": "为什么使用指针Swift 是一门非常安全的语言，强类型，Optinal 都是为了提高安全性所引入的，当我们对一个值为 nil 的 Optional 进行强制解包时就会触发崩溃，这是为了安全而触发的崩溃，可以防止程序有预期之外的行为。如果这里不崩溃，可能导致后续程序行为不可预期。大多数情况下，我们在使用 Swift 时都不需要使用指针，但是在某些情况下我们不可避免地需要使用指针相关 API ： 追求性能，直接操作内存； 与 C 进行交互； 通过修改指针的值来进行数据通讯；但是当我们越过类型的边界，直接对内存进行操作时，所有一切都变得不安全，从严格意义上来说，我们不能确定某个指针所指向的地址包含的类型是什么，对指针的操作必须小心翼翼。所以在 Swift 中，所有与指针操作相关的 API 都带有 unsafe 的关键字。MemoryLayoutSwift 提供了 MemoryLayout 来提供类型在内存占用中的信息，如：size ， alignment 和 stride 。物理内存以字节 (byte) 为单位，一个字节 (byte) 代表 8 bit ，bit 表示 0 或 1 。CPU 在读写内存时，会按照 word size 来读取内存，64 bit 的 CPU 会以 8 字节为 word size ，每次都会读取 word size 倍数的内存。有了内存对齐，使得每次读取都可以通过读取CPU 在读取的时候就不需要多次读取，提高效率。更详细的说明在这里：Purpose of memory alignment - Stack Overflow 。 alignment 表示内存对齐的字节，对应的对象地址必须是 alignment 的倍数，某些计算机系统要求对象的起始地址必须要是 1，2，4，8 的倍数； size 表示对象所占用的真实内存字节大小； stride 则表示对象在进行内存对齐后所占用的内存字节；// 基本类型的内存布局MemoryLayout&amp;lt;Int16&amp;gt;.size // returns 2MemoryLayout&amp;lt;Int16&amp;gt;.alignment // returns 2MemoryLayout&amp;lt;Int16&amp;gt;.stride // returns 2MemoryLayout&amp;lt;Bool&amp;gt;.size // returns 1MemoryLayout&amp;lt;Bool&amp;gt;.alignment // returns 1MemoryLayout&amp;lt;Bool&amp;gt;.stride // returns 1MemoryLayout&amp;lt;Float&amp;gt;.size // returns 4MemoryLayout&amp;lt;Float&amp;gt;.alignment // returns 4MemoryLayout&amp;lt;Float&amp;gt;.stride // returns 4MemoryLayout&amp;lt;String&amp;gt;.size // returns 16MemoryLayout&amp;lt;String&amp;gt;.alignment // returns 8MemoryLayout&amp;lt;String&amp;gt;.stride // returns 16大多数基本类型的 stride ， alignment 和 stride 都是一致的，但是当我们将其组合成 Struct 时就会发生一点变化了：struct Memory { let boolValue: Bool let floatValue: Float let int16: Int16}MemoryLayout&amp;lt;Memory&amp;gt;.size // returns 10MemoryLayout&amp;lt;Memory&amp;gt;.alignment // returns 4MemoryLayout&amp;lt;Memory&amp;gt;.stride // returns 12如果按照上面所显示的 size 来计算：MemoryLayout&amp;lt;Bool&amp;gt;.size + MemoryLayout&amp;lt;Float&amp;gt;.size + MemoryLayout&amp;lt;Int16&amp;gt;.size = 1 + 2 + 4 = 7 。为什么 MemoryLayout&amp;lt;Memory&amp;gt;.size 是 10 呢？这是因为内存对齐所造成的影响。假设 Memory 以 0x0 为起始内存地址，那么 Memory 详细的内存布局如下：struct Memory { let boolValue: Bool // 0x0 // padding 3 let floatValue: Float // 0x4 内存对齐 let int16: Int16 // 0x8 // padding 2 内存对齐}因为 floatValue 需要以 4 的倍数来作为起始地址，所以会在 boolValue 后加上 3 个字节作为补充，而 Memory 的 alignment 则以其所包含属性的 alignment 的最大值为自己的 alignment 。这里如果对 Memory 的属性声明顺序进行以下调整可以减少 Memory 在内存中占用的字节大小：struct Memory { let boolValue: Bool // 0x0 // padding 1 let int16: Int16 // 0x2 let floatValue: Float // 0x4}这样调整后 Memory 的 size 和 stride 都是 8 ，可以减少一些 Memory 的内存占比。这里有个详细分析 Swift 中各种数据类型的内存布局的 repo ： GitHub - TannerJin/Swift-MemoryLayout: Swift MemoryLayout 。UnsafePointerUnsafePointer 的声明如下：@frozen struct UnsafePointer&amp;lt;Pointee&amp;gt;Pointee 表示其内存中所包含的类型，你可以通过 pointee 属性来访问对应的类型，当使用 UnsafePointer 时，我们就负担起对生命周期进行管理的责任，调用一些初始化和释放相关的函数。指针的内存状态一个指针的对象可以有多种状态。很多指针的操作只在特定的内存状态中起作用，你必须要了解你所操作的内存的状态，明白各种操作在不同的状态下的区别。指针的内存可以有以下几种状态： 未类型化和未初始化； 类型化但未初始化； 类型化和初始化；未初始化的内存在读取前必须要进行初始化，已经初始化内存的指针可以通过 pointee 属性或者下标法进行访问：let pointer: UnsafePointer&amp;lt;Int&amp;gt; = ...print(pointer.pointee)print(pointer[0])将内存绑定到不同的类型当你通过 UnsafePointer 对象来操作内存时， Pointee 的类型必须要和内存中的类型一致。如果需要转换为其它类型的 UnsafePointer ， Swift 提供了类型安全的方式来临时或者永久地修改内存中的类型，也可以从原始的内存中直接加载类型的对象。比如说我们初始化了一个 UnsafePointer&amp;lt;UInt8&amp;gt; 对象，可以通过 withMemoryRebound(to:capacity:) 方法将其临时转化为 UnsafePointer&amp;lt;Int8&amp;gt; ：let pointer: UnsafePointer&amp;lt;UInt8&amp;gt; = ... // 255print(pointer.pointee) // 255pointer.withMemoryRebound(to: Int8.self, capacity: 8) { print($0.pointee) // -1}在讲内存绑定到不同的类型时，你必须要保证两者之间的内存布局是可兼容的。如果需要永久地将内存绑定到不同的类型，首先需要初始化一个 raw 的指针，然后调用 bindMemory(to:capacity:) 方法将其绑定到对应的类型：let pointer: UnsafePointer&amp;lt;Bool&amp;gt; = ... // truelet uint64Pointer = UnsafeRawPointer(pointer).bindMemory(to: UInt64.self, capacity: 1)let uint64Value = uint64Pointer.pointee // 1let originalBoolValue = pointer.pointee // true也可以通过 UnsafePointer 的 load(as:) 方法直接进行类型转换：let rawPointer = UnsafeRawPointer(pointer)let uint64Value = rawPointer.load(as: UInt64.self) // 1let originalBoolValue = rawPointer.load(as: Bool.self) // true指针的运算指针支持根据 Pointee 的类型进行步长 strides 相关的运算：// 数组第一个值的指针let intPointer: UnsafePointer&amp;lt;Int&amp;gt; = // [10, 20, 30, 40]print(intPointer.pointee) // 10print((intPointer + 2).pointee) // 30print(intPointer[2]) // 30隐式转换与桥接当调用含有 UnsafePointer 参数的方法或者函数时，你可以使用指向对应类型的指针，也可以使用指向兼容类型的指针，还可以使用 Swift 的隐式桥接。func printInt(atAddress p: UnsafePointer&amp;lt;Int&amp;gt;) { print(p.pointee)}printInt(atAddress: intPointer)let mutableIntPointer = UnsafeMutablePointer(mutating: intPointer)printInt(atAddress: mutableIntPointer) // 兼容类型，进行隐式转化printInt(atAddress: &amp;amp;number) // Swift 隐式桥接let numbers = [5, 10, 15, 20]printInt(atAddress: numbers) // numbers 第一个元素的地址，即 5 经由隐式桥接创建的对象或者数组元素只在调用的函数的执行期间有效。在其之后对指针进行操作都是未定义的行为，我们无法保证内存中还是对应的数据，尤其不要在 UnsafePointer 初始化中使用隐式桥接var number = 5let numberPointer = UnsafePointer&amp;lt;Int&amp;gt;(&amp;amp;number)// Accessing &#39;numberPointer&#39; is undefined behavior.UnsafeMutablePointer与 UnsafePointer 不同， UnsafeMutablePointer 支持通过 allocate 和 initialize 来进行分配内存和初始化：var bytes: [UInt8] = [1, 2, 3, 4, 5, 6, 7, 8]let uint8Pointer = UnsafeMutablePointer&amp;lt;UInt8&amp;gt;.allocate(capacity: 8)uint8Pointer.initialize(from: &amp;amp;bytes, count: 8)bytes[0] = 9print(uint8Pointer.pointee)同时因为需要自己管理指针的生命周期，所以需要手动销毁指针：uint8Pointer.deinitialize(count: 8)uint8Pointer.deallocate()UnsafeBufferPointer &amp;amp; UnsafeMutableBufferPointerUnsafeBufferPointer 是一段在连续的内存中存储元素的指针，对应的是 Swift 中的集合。在更低级别上使用 UnsafeBufferPointer 可以去除单一性检测和边界检测（ Release 模式），提高性能。UnsafeBufferPointer 只是一个进入对应内存的入口，它并不拥有它所引用的内存对象，对它进行拷贝不会拷贝对应的内存对象。UnsafeMutableBufferPointer 是 UnsafeBufferPointer 的可变版本。 Buffer Pointer 提供了大量与 Swift 集合类型一致的 api ，在调用的时候非常方便：var array = [1, 2, 3, 4, 5]let bufferPointer = UnsafeMutableBufferPointer&amp;lt;Int&amp;gt;(start: &amp;amp;array, count: array.count)for (index, pointer) in bufferPointer.enumerated() { print(index, pointer)}UnsafeRawPointer &amp;amp; UnsafeMutableRawPointer与上面对应具体类型的指针不同， Raw 指针不清楚自己指向的数据具体类型是什么，它不是类型安全的。在 Raw 指针分配内存后，需要调用 bindMemory(to:count:) 方法在没初始化的情况下将内存绑定到某个类型。当通过 Raw 指针读取已经绑定到某个类型的内存时，你必须要保证满足所有内存对齐的条件。运算Raw 指针也支持进行运算// 设置 byteCount 和 alignmentlet bytesPointer = UnsafeMutableRawPointer.allocate(byteCount: 4, alignment: 4)// 初始化值为 0xFFFFFFFF 的 UInt32bytesPointer.storeBytes(of: 0xFFFF_FFFF, as: UInt32.self)// 加载第一个字节为 UInt8let x = bytesPointer.load(as: UInt8.self) // 255// 移动两个字节，加载第三个和第四个字节let offsetPointer = bytesPointer + 2let y = offsetPointer.load(as: UInt16.self) // 65535// 释放内存bytesPointer.deallocate()隐式转换和桥接首先定义一个 print(address:as:) 函数， 第一个参数为 UnsafeRawPointer 对象。func print&amp;lt;T&amp;gt;(address p: UnsafeMutableRawPointer, as type: T.Type) { let value = p.load(as: type) print(value)}输入 Raw 指针作为参数：let bytesPointer = UnsafeMutableRawPointer.allocate(byteCount: 4, alignment: 4)bytesPointer.storeBytes(of: 123, as: UInt32.self)print(address: bytesPointer, as: UInt32.self)bytesPointer.deallocate()所有类型指针都可以隐式转换为 Raw 指针，所以也可以输入类型指针作为参数：let mutableIntPointer = UnsafeMutablePointer&amp;lt;Int&amp;gt;.allocate(capacity: 1)mutableIntPointer.initialize(to: 456)print(address: mutableIntPointer, as: Int.self)mutableIntPointer.deinitialize(count: 1)mutableIntPointer.deallocate()也可以通过 Swift 的隐式桥接来输入对象的指针或者数组作为参数：var value: Int = 23print(address: &amp;amp;value, as: Int.self)let numbers = [5, 10, 15, 20]print(address: numbers, as: Int.self)COpaquePointerCOpaquePointer 用于指向一些不能在 Swift 中表示的类型，比如说 C struct ：struct SomeStruct;void opaquePointer(struct SomeStruct *someStruct);func opaquePointer(someStruct: COpaquePointer)指针转换Swift 不支持 C 那样使用 &amp;amp; 获取地址后直接进行操作，所以提供了一系列以 withUnsafe 为前缀的方法，同样地也有可变和不可变版本。func withUnsafePointer&amp;lt;T, Result&amp;gt;(to value: inout T, _ body: (UnsafePointer&amp;lt;T&amp;gt;) throws -&amp;gt; Result) rethrows -&amp;gt; Result第一个参数是 inout 类型，第二个是闭包， 这个方法会将第一个参数转换为对应的指针，你可以在闭包中进行相关处理，比如调用接收指针参数的 Objective-C API ，但是不要在闭包范围外使用这个指针，因为在闭包范围外的释放时机是不确定的。var number: Int = 1let value = withUnsafePointer(to: &amp;amp;number) { (pointer) -&amp;gt; Int in return pointer.pointee + 1}Swift 也提供指针版本的 swap ：func swap&amp;lt;T&amp;gt;(_ a: inout T, _ b: inout T)var a: Int = 1var b: Int = 2swap(&amp;amp;a, &amp;amp;b)print(a, b)unsafeBitCast通过 unsafeBitCast 可以强制将指针指向的内存转为另一种类型。在进行 unsafeBitCast 转换时必须保证两者在内存布局上必须是兼容的，苹果文档 unsafeBitCast(_:to:) 也使用 Warning 标明 unsafeBitCast 不受 Swift 的类型系统保护，所以必须要非常小心。一般来说， unsafeBitCast 用于指针间的相互转换，因为指针的大小是相同的，某些 C API 要求的参数是 void * ，可以通过 unsafeBitCast 进行转换，结合 withUnsafe 函数可以将 UnsafePointer&amp;lt;T&amp;gt; 转换为 UnsafePointer&amp;lt;Void&amp;gt; ：var number = 4withUnsafePointer(&amp;amp;number, { (ptr: UnsafePointer&amp;lt;Int&amp;gt;) -&amp;gt; Int32 in var voidPtr: UnsafePointer&amp;lt;Void&amp;gt; = unsafeBitCast(ptr, UnsafePointer&amp;lt;Void&amp;gt;.self) return takesAnObjectAndReturnsAnInt(voidPtr)})assumingMemoryBound通过 UnsafeMutableRawPointer 的 assumingMemoryBound(to:) 方法可以生成一个指向同样内存地址的 UnsafeMutablePointer&amp;lt;T&amp;gt; ，使用 assumingMemoryBound(to:) 需要保证内存已经绑定至对应的类型。struct Struct { var a: UInt8 = 2 var b: UInt16 = 2}var structValue = Struct()let pointer = withUnsafePointer(to: &amp;amp;structValue) { UnsafeMutableRawPointer(mutating: $0) }.advanced(by: 2).assumingMemoryBound(to: UInt16.self)pointer.pointee = 4print(structValue.b) // 4Unmanaged为了与 C 进行交互，有时我们需要在 Raw 指针和 Swift 对象之间进行转换，为此，Swift 提供了 Unmanaged 给我们使用。而 Swift 对象和 Raw 指针的转换分为两部分： void * 与 Swift 对象之间的转换； 内存管理，当指针传递给 C 之后，Swift 的 ARC 就失效了，这时需要我们进行手动管理内存；Swift To C Unmanaged.passRetained(obj) 会增加引用计数，需要在适当的时机调用 release ，否则会造成内存泄露； Unmanaged.passUnretained(obj) 不会增加引用计数，可以在一些会在内部处理 ownership 或者直接使用值的 C API 中使用；let str0 = &quot;boxcar&quot; as CFStringlet bits = Unmanaged.passRetained(str0)let ptr = bits.toOpaque()Unmanaged 调用 toOpaque() 方法可以转换为 UnsafeMutableRawPointer ，与 C 的 void * 等价，可以与 C API 交互。C To SwiftUnmanaged 也提供了相关方法将 Raw 指针转换为 Swift 对象，转换为 Swift 对象时，你必须要指定类型：let string = Unmanaged&amp;lt;CFString&amp;gt;.fromOpaque(ptr).takeRetainedValue()takeRetainedValue() 会执行一次 release ，与 passRetained 对应，如果在转换为 UnsafeMutableRawPointer 时使用的是 passRetained ，这里就需要调用 takeRetainedValue() 。如果不需要进行 retain 或者 release ，这里可以调用 takeUnretainedValue() 。C 指针和 Swift 指针的对应表 C Swift const T * UnsafePointer T * UnsafeMutablePointer const T * [] UnsafeBufferPointer T * [] UnsafeMutableBufferPointer T ** AutoreleasingUnsafeMutablePointer const void * UnsafeRawPointer void * UnsafeMutableRawPointer void * [] UnsafeBufferRawPointer 示例UIScrollViewDelegateUIScrollViewDelegate 中有这么一个方法： scrollViewWillEndDragging(_:withVelocity:targetContentOffset:) ，当用户停止滑动使调用：optional func scrollViewWillEndDragging(_ scrollView: UIScrollView, withVelocity velocity: CGPoint, targetContentOffset: UnsafeMutablePointer&amp;lt;CGPoint&amp;gt;)其中 targetContentOffset 是一个 UnsafeMutablePointer&amp;lt;CGPoint&amp;gt; ，通过修改 targetContentOffset 的值可以在 UIScrollView 完成滑动时调整 offset ，因为 CGPoint 是一个 struct ，这里使用指针，从而修改对应内存上的值， UIScrollView 也可以获取到调用后的结果。ReachabilitySwift在 iOS 中，如果需要监听或者获取当前的网络状态，就需要跟 SCNetworkReachability 打交道，SCNetworkReachabilityContext 提供了 retain 和 release callback ，可以通过 callback 来进行内存管理，也可以直接通过 Unmanaged 对应的方法来进行内存管理。ReachabilitySwift 采取通过 callback 来进行内存管理的方式：// Class ReachabilityWeakifierclass ReachabilityWeakifier { weak var reachability: Reachability? init(reachability: Reachability) { self.reachability = reachability }}func startNotifier() throws { guard !notifierRunning else { return } let callback: SCNetworkReachabilityCallBack = { (reachability, flags, info) in guard let info = info else { return } // info 是一个 UnsafeMutableRawPointer ，对应的是下面设置 context 的 info 类型 // 这里通过 Unmanaged 的 fromOpaque 来转换成 ReachabilityWeakifier ，这里不需要 takeRetainedValue ， // 内存管理由 context 对应的 callbacks 负责 let weakifiedReachability = Unmanaged&amp;lt;ReachabilityWeakifier&amp;gt;.fromOpaque(info).takeUnretainedValue() weakifiedReachability.reachability?.flags = flags } let weakifiedReachability = ReachabilityWeakifier(reachability: self) // 这里同样不需要增加计数，调用 passUnretained 。 let opaqueWeakifiedReachability = Unmanaged&amp;lt;ReachabilityWeakifier&amp;gt;.passUnretained(weakifiedReachability).toOpaque() var context = SCNetworkReachabilityContext( version: 0, info: UnsafeMutableRawPointer(opaqueWeakifiedReachability), retain: { (info: UnsafeRawPointer) -&amp;gt; UnsafeRawPointer in // 在 Unmanaged 和 UnsafeRawPointer 间转换，同时 retain 增加计数 let unmanagedWeakifiedReachability = Unmanaged&amp;lt;ReachabilityWeakifier&amp;gt;.fromOpaque(info) _ = unmanagedWeakifiedReachability.retain() return UnsafeRawPointer(unmanagedWeakifiedReachability.toOpaque()) }, release: { (info: UnsafeRawPointer) -&amp;gt; Void in // 调用 release 减少计数 let unmanagedWeakifiedReachability = Unmanaged&amp;lt;ReachabilityWeakifier&amp;gt;.fromOpaque(info) unmanagedWeakifiedReachability.release() }, copyDescription: { (info: UnsafeRawPointer) -&amp;gt; Unmanaged&amp;lt;CFString&amp;gt; in let unmanagedWeakifiedReachability = Unmanaged&amp;lt;ReachabilityWeakifier&amp;gt;.fromOpaque(info) let weakifiedReachability = unmanagedWeakifiedReachability.takeUnretainedValue() let description = weakifiedReachability.reachability?.description ?? &quot;nil&quot; return Unmanaged.passRetained(description as CFString) } ) // ...}Alamofire 在 deinit 时设置 callback 为 nil ，所以不需要额外进行生命周期的管理，老版本的 Alamofire 是这样，5.0 后可能在写代码时没注意，而且有大量代码提交， review 的时候没太注意，调用了 Unmanaged.passRetained ，造成内存泄露。10 lines of code = 10 issues.500 lines of code = “looks fine.”Code reviews.” 。我提了个 Fix memory leak in NetworkReachabilityManager ，已经 merged 了。open func startListening(onQueue queue: DispatchQueue = .main, onUpdatePerforming listener: @escaping Listener) -&amp;gt; Bool { stopListening() $mutableState.write { state in state.listenerQueue = queue state.listener = listener } // 都调用 unretainedValue 方法，不进行内存管理 var context = SCNetworkReachabilityContext(version: 0, info: Unmanaged.passUnretained(self).toOpaque(), retain: nil, release: nil, copyDescription: nil) let callback: SCNetworkReachabilityCallBack = { _, flags, info in guard let info = info else { return } let instance = Unmanaged&amp;lt;NetworkReachabilityManager&amp;gt;.fromOpaque(info).takeUnretainedValue() instance.notifyListener(flags) } let queueAdded = SCNetworkReachabilitySetDispatchQueue(reachability, reachabilityQueue) let callbackAdded = SCNetworkReachabilitySetCallback(reachability, callback, &amp;amp;context) // Manually call listener to give initial state, since the framework may not. if let currentFlags = flags { reachabilityQueue.async { self.notifyListener(currentFlags) } } return callbackAdded &amp;amp;&amp;amp; queueAdded}实现系统的 swap 方法下面是 Swift 自己的实现， 为了减少 retain/release 带来的消耗，直接通过地址进行赋值操作：@inlinablepublic func swap&amp;lt;T&amp;gt;(_ a: inout T, _ b: inout T) { // Semantically equivalent to (a, b) = (b, a). // Microoptimized to avoid retain/release traffic. let p1 = Builtin.addressof(&amp;amp;a) let p2 = Builtin.addressof(&amp;amp;b) _debugPrecondition( p1 != p2, &quot;swapping a location with itself is not supported&quot;) // Take from P1. let tmp: T = Builtin.take(p1) // Transfer P2 into P1. Builtin.initialize(Builtin.take(p2) as T, p1) // Initialize P2. Builtin.initialize(tmp, p2)}Builtin 是 Swift 内部框架，用于跟 LLVM IR 的类型进行交互。所以我使用 UnsafeMutableRawPointer 来实现自己 swap 方法：func mySwap&amp;lt;T&amp;gt;(_ a: inout T, _ b: inout T) { let p1 = withUnsafeMutablePointer(to: &amp;amp;a) { (pointer) -&amp;gt; UnsafeMutableRawPointer in UnsafeMutableRawPointer(pointer) } let p2 = withUnsafeMutablePointer(to: &amp;amp;b) { (pointer) -&amp;gt; UnsafeMutableRawPointer in UnsafeMutableRawPointer(pointer) } guard p1 != p2 else { fatalError() } let temp = p1.load(as: T.self) p1.storeBytes(of: b, as: T.self) p2.storeBytes(of: temp, as: T.self)}总结由于安全的原因，在 Swift 上使用指针显得比较啰嗦，需要写一点代码来保证安全。虽然大多数情况下我们不需要与指针交互，但是当我们需要与某些 C 的库打交道，或者需要进行一些极致的性能优化时，熟悉指针的基本操作和相关知识可以让我们避免像上面那样造成内存泄露或者出现崩溃的情况。当然，进行指针操作应该是我们最后的手段，如果不足够谨慎，有可能带来的只是负收益。参考The 5-Minute Guide to C PointersSwift 皇冠上的明珠：不安全的 Swift 和指针类型Swift 对象内存模型探究（一）Swifter - Swift 必备 tips - UNSAFEPOINTERUnsafeRawPointer - Swift Standard Library | Apple Developer Documentationswift-evolution/0101-standardizing-sizeof-namingCalling Functions With Pointer Parameters | Apple Developer DocumentationSwift 中的指针使用" }, { "title": "Apple Keywords", "url": "/posts/Apple-Keywords/", "categories": "", "tags": "iOS", "date": "2020-04-29 23:02:22 +0800", "snippet": "Why熟悉 Apple 提供的一些 Keyword ，在适当的时候使用，有助于写出更规范的接口，也可以提高代码质量。Nullability在 Swift 中可以使用 ? 和 ! 来显式声明一个对象是 optional 还是 non-optional ，但是 Objective-C 中没有这一行为，所有对象都默认是可以设置为 nil 的，在 Swift 与 Objective-C 混编时， Swift 层不知道 Objective-C 层的对象是否为 optional ，它会统一当成 non-optional 来处理。这样导致 Swift 层在调用时有可能对 nil 进行强制解包导致崩溃。为了解决这个问题，Xcode 引入了一个 Objective-C 的新特性： Nullability Annotations ，如果我们没有显示地声明一个对象是否可以设置为 nil 时，编译器就会产生警告。对于属性，方法返回值，方法参数，推荐使用 nullable 和 nonnull ：- (nullable AAPLListItem *)itemWithName:(nonnull NSString *)name;- (NSInteger)indexOfItem:(nonnull AAPLListItem *)item;@property (copy, nullable) NSString *name;@property (copy, readonly, nonnull) NSArray *allItems;对于 C 函数相关参数，Block 参数和 Block 返回值，使用 _Nonnull 和 _Nullable 。Xcode 提供了两个宏定义： NS_ASSUME_NONNULL_BEGIN 和 NS_ASSUME_NONNULL_END ，在两个宏定义之间的对象都是 nonnull ，可以根据需要指定某个对象为 nullable 。NS_ASSUME_NONNULL_BEGIN@interface AAPLList : NSObject &amp;lt;NSCoding, NSCopying&amp;gt;// …- (nullable AAPLListItem *)itemWithName:(NSString *)name;- (NSInteger)indexOfItem:(AAPLListItem *)item;@property (copy, nullable) NSString *name;@property (copy, readonly) NSArray *allItems;// …@endNS_ASSUME_NONNULL_END在生成新的 Objective-C 文件时，Xcode 会自动添加 NS_ASSUME_NONNULL_BEGIN 和 NS_ASSUME_NONNULL_END ，只需要根据实际情况将某个对象设为 nullable 即可。null_resettable ：需要重写 setter 或者 getter 来处理 nil ， getter 不可为空。可在 setter 可以为 nil 时使用。null_unspecified ：Swift 可选类型的隐式解包，这个暂时不清楚怎么使用，只看到 WKNavigationDelegate 有使用到。官方博客说明： Nullability and Objective-C - Swift Blog - Apple Developerattribute((noescape))Swift 的 closure 分为逃逸 escaping 和非逃逸 non-escaping 。 逃逸背包表示可能会在函数返回之后才调用，比如一些网络请求。逃逸背包因为可能会在函数返回之后才调用，所以需要捕获 self ，处理 self 的持有和释放，在使用时为了循环引用，需要添加 [weak self] 声明，如果需要调用 self 的属性，需要添加 self. 。 非逃逸背包择表示会在函数结束前调用，编译器会进行一些优化，去掉对 self 的相关管理，调用 self 的属性不需要添加 self. 。Swift 使用 non-escaping 作为默认属性，如果是逃逸闭包则需要显式声明 @escaping ：func withLock(perform closure: @escaping () -&amp;gt; Void) { myLock.lock() closure() myLock.unlock()}class MyClass { var counter = 0 func incrementCounter() { counter += 1 // “self.” elided in an instance method withLock { [weak self] in // Without @noescape, the following line would produce the error // “reference to property ‘counter&#39; in closure requires // explicit ‘self.’ to make capture semantics explicit”. self.counter += 1 } }}为了更好地服务 Swift 和让编译器进行相关优化， Objective-C 的一些基础框架也支持了 non-escaping ：// GCD#if __has_attribute(noescape)#define DISPATCH_NOESCAPE __attribute__((__noescape__))#else#define DISPATCH_NOESCAPE#endifdispatch_sync(dispatch_queue_t queue, DISPATCH_NOESCAPE dispatch_block_t block);// CoreFoundation#if __has_attribute(noescape)#define CF_NOESCAPE __attribute__((noescape))#else#define CF_NOESCAPE#endifvoid CFArrayApplyFunction(CFArrayRef theArray, CFRange range, CFArrayApplierFunction CF_NOESCAPE applier, void *context);// Foundation#define NS_NOESCAPE CF_NOESCAPE// NSArray- (NSArray&amp;lt;ObjectType&amp;gt; *)sortedArrayUsingFunction:(NSInteger (NS_NOESCAPE *)(ObjectType, ObjectType, void * _Nullable))comparator context:(nullable void *)context;在编写 Objective-C 代码时，如果 block 会在函数返回前调用，建议加上 NS_NOESCAPE ，或者直接使用 (__attribute__((noescape)) 。提案链接：swift-evolution/0012-add-noescape-to-public-library-api.md at master · apple/swift-evolution · GitHub swift-evolution/0103-make-noescape-default.md at master · apple/swift-evolution · GitHubNS_SWIFT_NAME与 Objective-C 不同， Swift 有命名空间，不需要通过添加前缀来避免类名重复等问题。如果你想在 Swift 中调用时去掉丑陋的前缀，可以使用 NS_SWIFT_NAME 来重定义Objective-C API 在 Swift 层的命名。 NS_SWIFT_NAME 适用于类型，属性，方法，函数。NS_SWIFT_NAME(Sandwich.Preferences)@interface SandwichPreferences : NSObject@property BOOL includesCrust NS_SWIFT_NAME(isCrusty);@end@interface Sandwich : NSObject@endSwift 调用代码：var preferences = Sandwich.Preferences()preferences.isCrusty = true 官方文档：[Renaming Objective-C APIs for Swift Apple Developer Documentation](https://developer.apple.com/documentation/swift/objective-c_and_c_code_customization/renaming_objective-c_apis_for_swift) NS_REFINED_FOR_SWIFT如果你想要 Objective-C API 在 Swift 层的声明不同，可以使用 NS_REFINED_FOR_SWIFT ，使用之后可以加多一层封装来添加更 Swift 的 API 。@interface ObjcClass : NSObject- (instancetype)initWithName:(NSString *)name aka:(NSString *)name NS_REFINED_FOR_SWIFT;@endextension ObjcClass { @nonobjc convenience init(name: String = “”, aka: String) { self.init(__name: name, aka: aka) }}let objc = ObjcClass(aka: “Test”)注意：加了 NS_REFINED_FOR_SWIFT 之后，带有 __ 不会自动补全，需要手打出来。好处： 提供一些默认参数； 封装层给 block 添加 @escaping ； 更 Swift 的 API 。 官方文档：[Improving Objective-C API Declarations for Swift Apple Developer Documentation](https://developer.apple.com/documentation/swift/objective-c_and_c_code_customization/improving_objective-c_api_declarations_for_swift) NS_CLOSED_ENUMSwift 5 引入了 Frozen enums ，如果 C enum 或者系统的 enums 没有添加 NS_CLOSED_ENUM ， Xcode 就会产生如下警告：Switch covers known cases, but ‘AccountType’ may have additional unknown values这表示 AccountType 在将来可能会添加其它的 values 。点击 Fix 后会新增一个 @unknown default 的 case ，用于处理以后增加的其它 values 。与 case default 不同，在添加了其它 values 后， Xcode 还是会产生如下警告：Switch must be exhaustive如果使用 case default ，就不会产生警告。这个警告有助于提示你处理新增的 values 。如果你确保未来不会新增 values ，那么就可以使用 NS_CLOSED_ENUM 来说明。 NSComparisonResult 使用了 NS_CLOSED_ENUM 来表明不会新增 values 。 Swift 层在进行 switch 的时候也无需添加 @unknown default 。typedef NS_CLOSED_ENUM(NSInteger, NSComparisonResult) { NSOrderedAscending = -1L, NSOrderedSame, NSOrderedDescending};Swift 5 Frozen enumsswift-evolution/0192-non-exhaustive-enums.md at master · apple/swift-evolution · GitHubNS_TYPED_ENUM使用 NS_TYPED_ENUM 来给一组常量进行定义，和在 Swift 中使用 struct 和 static 属性来定义一组类型相似。// Store the three traffic light color options as 0, 1, and 2.typedef long TrafficLightColor NS_TYPED_ENUM; TrafficLightColor const TrafficLightColorRed;TrafficLightColor const TrafficLightColorYellow;TrafficLightColor const TrafficLightColorGreen;其作用跟 Swift 以下代码一致：struct TrafficLightColor: RawRepresentable, Equatable, Hashable { typealias RawValue = Int init(rawValue: RawValue) var rawValue: RawValue { get } static var red: TrafficLightColor { get } static var yellow: TrafficLightColor { get } static var green: TrafficLightColor { get }}但是 NS_TYPED_ENUM 对应的 struct 不允许使用 extension ，如果需要使用到 extension ，则需要使用 NS_TYPED_EXTENSIBLE_ENUM 来进行声明。availability在 Swift 中我们可以使用 @available 来声明 API 在某个特定的平台或者系统上可用， Objective-C 中可以使用 API_AVAILABLE 来实现同样的功能：@interface MyViewController : UIViewController- (void) newMethod API_AVAILABLE(ios(11), macosx(10.13));@end其作用跟以下 Swift 代码一致：@available(iOS 11, macOS 10.13, *)func newMethod() { // Use iOS 11 APIs.}使用 @available() 来判断是否满足某些系统版本：if (@available(iOS 11, *)) { // Use iOS 11 APIs.} else { // Alternative code for earlier versions of iOS.}其作用跟以下 Swift 代码一致：if #available(iOS 11, *) { // Use iOS 11 APIs.} else { // Alternative code for earlier versions of iOS.}NS_UNAVAILABLE如果需要禁止使用某些方法，比如禁止使用系统提供的 init 方法：- (instancetype)init NS_UNAVAILABLE;在调用对应的 init 方法时就会报错。如果只需要禁止 Swift 调用，可以使用 NS_SWIFT_UNAVAILABLE 。CF_SWIFT_NAME因为 C 中的 struct 无法提供方法，属性或者自定义初始化方法，不得不通过编写全局函数来实现以上功能。Swift 中的 struct 则可以定义方法，属性或者初始化方法，如果需要将 C 中的方法桥接到 Swift 的 struct 中，可以使用 CF_SWIFT_NAME 。Color ColorCreateWithCMYK(float c, float m, float y, float k) CF_SWIFT_NAME(Color.init(c:m:y:k:)); float ColorGetHue(Color color) CF_SWIFT_NAME(getter:Color.hue(self:));void ColorSetHue(Color color, float hue) CF_SWIFT_NAME(setter:Color.hue(self:newValue:)); Color ColorDarkenColor(Color color, float amount) CF_SWIFT_NAME(Color.darken(self:amount:)); extern const Color ColorBondiBlue CF_SWIFT_NAME(Color.bondiBlue); Color ColorGetCalibrationColor(void) CF_SWIFT_NAME(getter:Color.calibration());Color ColorSetCalibrationColor(Color color) CF_SWIFT_NAME(setter:Color.calibration(newValue:));对应的 Swift 代码如下：extension Color { init(c: Float, m: Float, y: Float, k: Float) var hue: Float { get set } func darken(amount: Float) -&amp;gt; Color static var bondiBlue: Color static var calibration: Color}当我们想为 C 中的全局方法提供更 Swift 的 API 时，可以考虑使用 CF_SWIFT_NAME 。NS_ERROR_ENUM结合 NS_ERROR_ENUM ，在 Swift 层可以 catch 特定的 error 来进行特定的处理：extern NSErrorDomain const MyErrorDomain;typedef NS_ERROR_ENUM(MyErrorDomain, MyError) { specificError1 = 0, specificError2 = 1};@objc func customThrow() throws { throw NSError( domain: MyErrorDomain, code: MyError.specificError2.rawValue, userInfo: [ NSLocalizedDescriptionKey: &quot;A customized error from MyErrorDomain.&quot; ] )}do { try customThrow()} catch MyError.specificError1 { print(&quot;Caught specific error #1&quot;)} catch let error as MyError where error.code == .specificError2 { print(&quot;Caught specific error #2, &quot;, error.localizedDescription) // Prints &quot;Caught specific error #2. A customized error from MyErrorDomain.&quot;} let error { fatalError(&quot;Some other error: \\(error)&quot;)}同时也支持 Objective-C 进行调用，在 Objective-C 层的调用方式如下：NSError *error;[object customThrowAndReturnError:&amp;amp;error];提案链接： swift-evolution/0112-nserror-bridging.md at master · apple/swift-evolution · GitHub" }, { "title": "Aspects", "url": "/posts/Aspects/", "categories": "", "tags": "源码解析", "date": "2020-03-07 17:23:30 +0800", "snippet": "Aspects 好处都有啥在 Objective-C 中可以使用 method swizzling 来进行 AOP 编程，可以替换掉原有方法的执行，或者在原有方法执行前后添加自己的代码。举个最普遍的例子：我们需要统计 app 中每个 ViewController 出现的次数，需要在 viewDidAppear: 中添加统计方法，一般来说我们可能会考虑用继承，但是继承会带来以下两个问题： 需要一个基类来实现这些代码，如果有多个类似的需求则会导致基类非常庞大； 所有新建的 ViewController 都需要继承自这个基类，需要针对不同的 Controller 类型来编写不同的基类；通过 method swizzling 我们可以在 UIViewController 的 viewDidAppear: 插入自己的替换代码，大多数无痕埋点都是使用这个解决方法。下面来看看不怎么优雅地实现一个 method swizzling 的代码：@implementation UIViewController (MethodSwizzling)+ (void)load { static dispatch_once_t onceToken; dispatch_once(&amp;amp;onceToken, ^{ Class class = [self class]; SEL originalSelector = @selector(viewWillAppear:); SEL swizzledSelector = @selector(melon_viewWillAppear:); Method originalMethod = class_getInstanceMethod(class, originalSelector); Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector); BOOL didAddMethod = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); if (didAddMethod) { class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); } else { method_exchangeImplementations(originalMethod, swizzledMethod); } });}- (void)melon_viewWillAppear:(BOOL)animated { [self melon_viewWillAppear:animated]; NSLog(@“View Controller %@ view will appear”, self);}@end可以看到如果通过 runtime 提供的方法来进行 method swizzling 的话，我们需要进行以下工作： 新建分类，在分类中添加 load 方法，在 load 方法中进行 method swizzling ； 在分类中添加需要替换的具有相同参数的方法；如果有大量类的需要进行 method swizzling ，我们就需要编写大量分类和参数相同的方法。为了解决这个问题，Aspects 给我们提供了通过 Block 来进行 method swizzling 的途径，不需要分类，不需要编写参数相同的方法，一切都在 Block 中进行。下面来看下优雅地使用 Aspects 实现相同的功能：[UIViewController aspect_hookSelector:@selector(viewWillAppear:) withOptions:AspectPositionAfter usingBlock:^(id&amp;lt;AspectInfo&amp;gt; aspectInfo, BOOL animated) { NSLog(@“View Controller %@ view will appear&quot;, aspectInfo.instance); } error:NULL];不算上自己实现的 Block 代码，Aspects 几乎算得上是只需要一行代码就可以实现 method swizzling 。原理 Aspects uses Objective-C message forwarding to hook into messages. This will create some overhead. Don’t add aspects to methods that are called a lot. Aspects is meant for view/controller code that is not called a 1000 times per second. Adding aspects returns an opaque token which can be used to deregister again. All calls are thread safe.上面是 Aspects 的说明，可以看到 Aspects 是通过 Objective-C 的消息转发来实现 hook 方法的。它会带来一些性能消耗。不要对那些会在一定时间内大量调用的方法使用。Aspects 也提供了一个用于还原 hook 的 token 。Objective-C 是一门消息发送的语言，消息由接收对象，selector 和参数构成，消息派发系统会根据这三者来寻找对应的 IMP ，也就是具体的方法实现，如果给某个对象发送了一条无法找到对应 IMP 的 selector ，就会进入消息转发流程。resolveInstanceMethod对象在接受到无法处理的 selector 时，首先会调用：+ (BOOL)resolveInstanceMethod:(SEL)selector;在返回结果前，可以动态地添加方法，然后返回 YES ：+ (BOOL)resolveInstanceMethod:(SEL)selector { if (selector 符合条件) { class_addMethod(self, selector, imp, @“v@:@&quot;); return YES; } return NO;}如果是类方法，则会调用 resolveClassMethod: 方法。forwardingTargetForSelector如果 resolveInstanceMethod: 返回 NO ，那么就会调用 forwardingTargetForSelector: 方法，可以将方法转给其它对象来处理：- (id)forwardingTargetForSelector:(SEL)selector;返回的 id 为对应的执行方法的对象，通过 forwardingTargetForSelector: 可以实现类似多继承的特性。如果当前的对象没有实现对应的方法，我们也可以在 forwardingTargetForSelector: 里动态生成一个新的类，然后给它添加对应的方法，再转发给新的类的对象，防止出现 doesNotRecognizeSelector: 的崩溃，当然我个人觉得越早崩溃越容易发现问题，不然有些逻辑上的错误找不出来。forwardInvocation如果 forwardingTargetForSelector: 返回的 id 为 nil ，就会走到消息转发流程的最后一步，首先会调用 methodSignatureForSelector: 方法来生成 NSMethodSignature 对象，NSMethodSignature 包含 selector 的各种信息，参数类型，返回类型和调用对象类型等，它用于创建 NSInvocation 对象。当 methodSignatureForSelector: 返回了一个 NSMethodSignature 对象后，就会调用 forwardInvocation: 方法：- (void)forwardInvocation:(NSInvocation *)invocation { [invocation setTarget:self.target]; [invocation invoke];}通过 NSInvocation ，我们可以修改 selector 的接收对象，参数和返回值，等等。可以做的事情比较多。消息转发整体流程整体流程如下图所示， resolveInstanceMethod: 主要用于为类动态添加方法，forwardingTargetForSelector: 则用于将接收对象转换成其它类的对象， forwardInvocation: 可以做的事情较多，但是越往后成本越大，所以如果需要转换消息的接收对象，最好是在 forwardingTargetForSelector: 中执行，而不是在 forwardInvocation: 中转换。Aspects 则是选择在 forwardInvocations: 上进行处理，对应需要 hook 的 selector ，Aspects 将其指向了 _objc_msgForward 方法，同时也对 forwardInvocation: 方法进行 hook 处理，使其指向自己的 __ASPECTS_ARE_BEING_CALLED__ 方法，在 __ASPECTS_ARE_BEING_CALLED__ 中插入自己需要进行调用的方法，然后会生成一个新的 aliasSelector 指向原有的方法 IMP ，通过 aliasSelector 来调用原有的方法。先来看看头文件Aspects.h 首先定义了 hook 的几种类型typedef NS_OPTIONS(NSUInteger, AspectOptions) { AspectPositionAfter = 0, /// 在原方法之后执行 AspectPositionInstead = 1, /// 替代原方法 AspectPositionBefore = 2, /// 在原方法之前执行 AspectOptionAutomaticRemoval = 1 &amp;lt;&amp;lt; 3 /// 只执行一次};id&amp;lt;AspectToken&amp;gt; 是 Aspects 在 hook 方法时返回的结果，使用 protocol 的方式对具体的类进行了抽象，调用者不需要关心具体的类是什么，只需要知道它是个遵循了 AspectToken protocol 的类。id&amp;lt;AspectToken&amp;gt; 相当于每个 hook 的 token ，通过这个 token ，我们可以调用 remove 方法来移除特定的 hook ：/// Opaque Aspect Token that allows to deregister the hook.@protocol AspectToken &amp;lt;NSObject&amp;gt;/// Deregisters an aspect./// @return YES if deregistration is successful, otherwise NO.- (BOOL)remove;@endid&amp;lt;AspectInfo&amp;gt; 协议，是我们使用的 block 返回的第一个参数，/// The AspectInfo protocol is the first parameter of our block syntax.@protocol AspectInfo &amp;lt;NSObject&amp;gt;/// 当前被 hook 的实例。- (id)instance;/// 原始的 invocation 。- (NSInvocation *)originalInvocation;/// 方法参数，懒加载。- (NSArray *)arguments;@end然后 Aspects.h 给 NSObject 添加了两个 hook 方法，一个是类方法，一个是实例方法，根据说明，block 的第一个参数是 id&amp;lt;AspectInfo&amp;gt; ，紧接着是被 hook 的方法的所有参数，这些都是可选的，你可以直接使用一个没有参数的 block ，也可以只传 id&amp;lt;AspectInfo&amp;gt; ，还可以输入跟原有方法参数一样的参数列表。@interface NSObject (Aspects)+ (id&amp;lt;AspectToken&amp;gt;)aspect_hookSelector:(SEL)selector withOptions:(AspectOptions)options usingBlock:(id)block error:(NSError **)error;/// 针对特定对象进行 hook- (id&amp;lt;AspectToken&amp;gt;)aspect_hookSelector:(SEL)selector withOptions:(AspectOptions)options usingBlock:(id)block error:(NSError **)error;@end走进 AspectAspect 的入口只有 NSObject 的两个 hook 方法，以下是两个 hook 的方法的具体实现：+ (id&amp;lt;AspectToken&amp;gt;)aspect_hookSelector:(SEL)selector withOptions:(AspectOptions)options usingBlock:(id)block error:(NSError **)error { return aspect_add((id)self, selector, options, block, error);}/// @return A token which allows to later deregister the aspect.- (id&amp;lt;AspectToken&amp;gt;)aspect_hookSelector:(SEL)selector withOptions:(AspectOptions)options usingBlock:(id)block error:(NSError **)error { return aspect_add(self, selector, options, block, error);}可以看到不管是类还是实例方法的 hook ，都是统一调度 aspect_add 方法。只是类对象需要加多一层 (id)self 的转换。下面来看看作为统一入口的 aspect_add 方法的实现：static id aspect_add(id self, SEL selector, AspectOptions options, id block, NSError **error) { NSCParameterAssert(self); NSCParameterAssert(selector); NSCParameterAssert(block); __block AspectIdentifier *identifier = nil; // 给 hook 操作加锁 aspect_performLocked(^{ // 判断方法是否允许被 hook if (aspect_isSelectorAllowedAndTrack(self, selector, options, error)) { AspectsContainer *aspectContainer = aspect_getContainerForObject(self, selector); identifier = [AspectIdentifier identifierWithSelector:selector object:self options:options block:block error:error]; if (identifier) { [aspectContainer addAspect:identifier withOptions:options]; // 进行 hook 的具体操作 aspect_prepareClassAndHookSelector(self, selector, error); } } }); return identifier;}aspect_add 作为内部实现的第一层方法，负责统筹调度各个内部方法，它自己并没有什么单独的代码逻辑。aspect_performLocked为了方便加减锁，Aspects 提供了 aspect_performLocked 的方法，可以直接在 block 里进行线程安全的操作：static void aspect_performLocked(dispatch_block_t block) { static OSSpinLock aspect_lock = OS_SPINLOCK_INIT; OSSpinLockLock(&amp;amp;aspect_lock); block(); OSSpinLockUnlock(&amp;amp;aspect_lock);} 使用的是 OSSpinLock ，但是 OSSpinLock 存在优先级反转的问题，具体可以看这里 [不再安全的 OSSpinLock Garan no dou](https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/) ，苹果推荐我们使用 os_unfair_lock 来替换掉，替换成 os_unfair_lock 后的代码如下： static void aspect_performLocked(dispatch_block_t block) { static os_unfair_lock aspect_lock = OS_UNFAIR_LOCK_INIT; os_unfair_lock_lock(&amp;amp;aspect_lock); block(); os_unfair_lock_unlock(&amp;amp;aspect_lock);}aspect_isSelectorAllowedAndTrackAspectTracker在开始说 aspect_isSelectorAllowedAndTrack 前先说说 AspectTracker ， AspectTracker 用于 hook 时判断子父类是否有重复 hook 。@interface AspectTracker : NSObject- (id)initWithTrackedClass:(Class)trackedClass;// hook 的类@property (nonatomic, strong) Class trackedClass;// hook 的类名，在调用时会通过 NSStringFromClass 来生成@property (nonatomic, readonly) NSString *trackedClassName;// 被 hook 的方法名@property (nonatomic, strong) NSMutableSet *selectorNames;// 子类已经进行 hook 的方法名@property (nonatomic, strong) NSMutableDictionary *selectorNamesToSubclassTrackers;- (void)addSubclassTracker:(AspectTracker *)subclassTracker hookingSelectorName:(NSString *)selectorName;- (void)removeSubclassTracker:(AspectTracker *)subclassTracker hookingSelectorName:(NSString *)selectorName;- (BOOL)subclassHasHookedSelectorName:(NSString *)selectorName;- (NSSet *)subclassTrackersHookingSelectorName:(NSString *)selectorName;@end@implementation AspectTracker- (id)initWithTrackedClass:(Class)trackedClass { if (self = [super init]) { _trackedClass = trackedClass; _selectorNames = [NSMutableSet new]; _selectorNamesToSubclassTrackers = [NSMutableDictionary new]; } return self;}- (BOOL)subclassHasHookedSelectorName:(NSString *)selectorName { return self.selectorNamesToSubclassTrackers[selectorName] != nil;}- (void)addSubclassTracker:(AspectTracker *)subclassTracker hookingSelectorName:(NSString *)selectorName { NSMutableSet *trackerSet = self.selectorNamesToSubclassTrackers[selectorName]; if (!trackerSet) { trackerSet = [NSMutableSet new]; self.selectorNamesToSubclassTrackers[selectorName] = trackerSet; } [trackerSet addObject:subclassTracker];}- (void)removeSubclassTracker:(AspectTracker *)subclassTracker hookingSelectorName:(NSString *)selectorName { NSMutableSet *trackerSet = self.selectorNamesToSubclassTrackers[selectorName]; [trackerSet removeObject:subclassTracker]; if (trackerSet.count == 0) { [self.selectorNamesToSubclassTrackers removeObjectForKey:selectorName]; }}- (NSSet *)subclassTrackersHookingSelectorName:(NSString *)selectorName { NSMutableSet *hookingSubclassTrackers = [NSMutableSet new]; for (AspectTracker *tracker in self.selectorNamesToSubclassTrackers[selectorName]) { if ([tracker.selectorNames containsObject:selectorName]) { [hookingSubclassTrackers addObject:tracker]; } [hookingSubclassTrackers unionSet:[tracker subclassTrackersHookingSelectorName:selectorName]]; } return hookingSubclassTrackers;}- (NSString *)trackedClassName { return NSStringFromClass(self.trackedClass);}- (NSString *)description { return [NSString stringWithFormat:@“&amp;lt;%@: %@, trackedClass: %@, selectorNames:%@, subclass selector names: %@&amp;gt;”, self.class, self, NSStringFromClass(self.trackedClass), self.selectorNames, self.selectorNamesToSubclassTrackers.allKeys];}@endAspectTracker 维护了一个字典 selectorNamesToSubclassTrackers ，以 selectorName 为 key ，value 为 NSMutableSet ，包含子类中对应 selectorName 的 tracker 。aspect_isSelectorAllowedAndTrack 对 SEL 和类方法重复 hook 做了处理，下面分段来说下具体的处理逻辑。disallowedSelectorList 包含了 retain ， release ， autorelease 和 forwardInvocation ，不允许对以上四个方法进行 hook：static NSSet *disallowedSelectorList;static dispatch_once_t pred;dispatch_once(&amp;amp;pred, ^{ disallowedSelectorList = [NSSet setWithObjects:@&quot;retain”, @“release”, @“autorelease”, @“forwardInvocation:”, nil];});NSString *selectorName = NSStringFromSelector(selector);if ([disallowedSelectorList containsObject:selectorName]) { NSString *errorDescription = [NSString stringWithFormat:@&quot;Selector %@ is blacklisted.&quot;, selectorName]; AspectError(AspectErrorSelectorBlacklisted, errorDescription); return NO;}对于 dealloc 方法，只允许进行 AspectPositionBefore 的 hook ：AspectOptions position = options&amp;amp;AspectPositionFilter;if ([selectorName isEqualToString:@&quot;dealloc&quot;] &amp;amp;&amp;amp; position != AspectPositionBefore) { NSString *errorDesc = @&quot;AspectPositionBefore is the only valid position when hooking dealloc.”; AspectError(AspectErrorSelectorDeallocPosition, errorDesc); return NO;}检查是否有包含需要进行 hook 的方法：if (![self respondsToSelector:selector] &amp;amp;&amp;amp; ![self.class instancesRespondToSelector:selector]) { NSString *errorDesc = [NSString stringWithFormat:@&quot;Unable to find selector -[%@ %@].&quot;, NSStringFromClass(self.class), selectorName]; AspectError(AspectErrorDoesNotRespondToSelector, errorDesc); return NO;}最后就是针对类方法的重复 hook 。判断是否为类对象，如果是类对象，则表示是在类这一层上进行 hook ，需要判断是否有重复 hook 相同的方法。这里判断是否为类对象时使用了 object_getClass ，跟 class 方法不同在于，如果 self 为类对象( Class )，则会返回 meta class ，如果是实例对象 ( Instance )，则返回类对象( Class )。而 class 只会返回类对象。如果是实例对象则不需要检测是否有重复 hook 相同的方法。为什么需要判断是否有重复 hook 呢？因为 Aspect 是在消息转发流程的时候对原有的方法进行处理，所有消息都会经由它自己生成的 __ASPECTS_ARE_BEING_CALLED__ 方法，如果子类和父类 hook 了同一个方法，子类的方法调用父类方法时，父类的方法走到 __ASPECTS_ARE_BEING_CALLED__ 方法时就会丢失了是由父类进行调用这一信息，于是会重新调用子类的方法，造成死循环，所以这里要进行判断。if (class_isMetaClass(object_getClass(self))) { // 防止重复 hook} else { return YES;}aspect_getSwizzledClassesDict() 方法返回一个全局的 NSMutableDictionary ，用于记录已经进行过 hook 的类对应的 AspectTracker：static NSMutableDictionary *aspect_getSwizzledClassesDict() { static NSMutableDictionary *swizzledClassesDict; static dispatch_once_t pred; dispatch_once(&amp;amp;pred, ^{ swizzledClassesDict = [NSMutableDictionary new]; }); return swizzledClassesDict;}判断是否有进行过类是否有 hook 过相同的方法：Class klass = [self class];NSMutableDictionary *swizzledClassesDict = aspect_getSwizzledClassesDict();Class currentClass = [self class];AspectTracker *tracker = swizzledClassesDict[currentClass];if ([tracker subclassHasHookedSelectorName:selectorName]) { NSSet *subclassTracker = [tracker subclassTrackersHookingSelectorName:selectorName]; NSSet *subclassNames = [subclassTracker valueForKey:@&quot;trackedClassName&quot;]; NSString *errorDescription = [NSString stringWithFormat:@&quot;Error: %@ already hooked subclasses: %@. A method can only be hooked once per class hierarchy.&quot;, selectorName, subclassNames]; AspectError(AspectErrorSelectorAlreadyHookedInClassHierarchy, errorDescription); return NO;}首先获取对应的 AspectTracker ，然后通过 subclassHasHookedSelectorName: 方法判断子类是否有进行过 hook ，如果有，则返回 NO ，并输出对应的方法名和子类名，如果没有，则继续以下操作：do { tracker = swizzledClassesDict[currentClass]; if ([tracker.selectorNames containsObject:selectorName]) { if (klass == currentClass) { // Already modified and topmost! return YES; } NSString *errorDescription = [NSString stringWithFormat:@“Error: %@ already hooked in %@. A method can only be hooked once per class hierarchy.&quot;, selectorName, NSStringFromClass(currentClass)]; AspectError(AspectErrorSelectorAlreadyHookedInClassHierarchy, errorDescription); return NO; }} while ((currentClass = class_getSuperclass(currentClass)));之前已经检查过子类是否有 hook 过对应的方法，这里进行的是父类的检查，不断向上获取 superclass ，如果父类有 hook 过对应的方法，就返回 NO 。// Add the selector as being modified.currentClass = klass;AspectTracker *subclassTracker = nil;do { tracker = swizzledClassesDict[currentClass]; if (!tracker) { tracker = [[AspectTracker alloc] initWithTrackedClass:currentClass]; swizzledClassesDict[(id&amp;lt;NSCopying&amp;gt;)currentClass] = tracker; } if (subclassTracker) { [tracker addSubclassTracker:subclassTracker hookingSelectorName:selectorName]; } else { [tracker.selectorNames addObject:selectorName]; } // All superclasses get marked as having a subclass that is modified. subclassTracker = tracker;}while ((currentClass = class_getSuperclass(currentClass)));// …return YES;如果子类和父类都没有 hook 过对应的方法，那么就可以进行记录，需要遍历所有父类对应的 tracker ，在循环过程中，将上一次获取子类的 tracker 添加到父类的 subclassTracker 中。aspect_getContainerForObject在完成 hook 方法的合法性检测后，就需要获取到 AspectsContainer 。AspectIdentifier由于 AspectsContainer 会包含 AspectIdentifier ，所以先来说下 AspectIdentifier :// Tracks a single aspect.@interface AspectIdentifier : NSObject+ (instancetype)identifierWithSelector:(SEL)selector object:(id)object options:(AspectOptions)options block:(id)block error:(NSError **)error;- (BOOL)invokeWithInfo:(id&amp;lt;AspectInfo&amp;gt;)info;@property (nonatomic, assign) SEL selector;@property (nonatomic, strong) id block;@property (nonatomic, strong) NSMethodSignature *blockSignature;@property (nonatomic, weak) id object;@property (nonatomic, assign) AspectOptions options;@endAspectIdentifier 通过以下方法来初始化：+ (instancetype)identifierWithSelector:(SEL)selector object:(id)object options:(AspectOptions)options block:(id)block error:(NSError **)error { NSCParameterAssert(block); NSCParameterAssert(selector); NSMethodSignature *blockSignature = aspect_blockMethodSignature(block, error); // TODO: check signature compatibility, etc. if (!aspect_isCompatibleBlockSignature(blockSignature, object, selector, error)) { return nil; } AspectIdentifier *identifier = nil; if (blockSignature) { identifier = [AspectIdentifier new]; identifier.selector = selector; identifier.block = block; identifier.blockSignature = blockSignature; identifier.options = options; identifier.object = object; // weak } return identifier;}aspect_blockMethodSignaturestatic NSMethodSignature *aspect_blockMethodSignature(id block, NSError **error) { AspectBlockRef layout = (__bridge void *)block; // 首先判断根据 flags 判断是否包含有方法签名，如果没有则报错 if (!(layout-&amp;gt;flags &amp;amp; AspectBlockFlagsHasSignature)) { NSString *description = [NSString stringWithFormat:@“The block %@ doesn’t contain a type signature.”, block]; AspectError(AspectErrorMissingBlockSignature, description); return nil; } void *desc = layout-&amp;gt;descriptor; // 根据 block 结构体做位置上的迁移 desc += 2 * sizeof(unsigned long int); if (layout-&amp;gt;flags &amp;amp; AspectBlockFlagsHasCopyDisposeHelpers) { desc += 2 * sizeof(void *); } // 判断是否有指向 signature if (!desc) { NSString *description = [NSString stringWithFormat:@&quot;The block %@ doesn&#39;t has a type signature.&quot;, block]; AspectError(AspectErrorMissingBlockSignature, description); return nil; } const char *signature = (*(const char **)desc); return [NSMethodSignature signatureWithObjCTypes:signature];}通过 aspect_blockMethodSignature 可以将 block 转换为 NSMethodSignature 。方法的第一行将 block 显示声明为 AspectBlockRef 结构体， AspectBlockRef 结构体的则是根据苹果公开的 block 结构来定义的， compiler-rt/Block_private.h ，所以可以显式地将 block 转换为结构体 AspectBlockRef 。// Block internals.typedef NS_OPTIONS(int, AspectBlockFlags) { AspectBlockFlagsHasCopyDisposeHelpers = (1 &amp;lt;&amp;lt; 25), AspectBlockFlagsHasSignature = (1 &amp;lt;&amp;lt; 30)};typedef struct _AspectBlock { __unused Class isa; AspectBlockFlags flags; __unused int reserved; void (__unused *invoke)(struct _AspectBlock *block, ...); struct { unsigned long int reserved; unsigned long int size; // requires AspectBlockFlagsHasCopyDisposeHelpers void (*copy)(void *dst, const void *src); void (*dispose)(const void *); // requires AspectBlockFlagsHasSignature const char *signature; const char *layout; } *descriptor; // imported variables} *;AspectBlockRefaspect_isCompatibleBlockSignature在获取到 block 的 NSMethodSignature 后，则需要判断是否合法，于是又调用了 aspect_isCompatibleBlockSignature ：static BOOL aspect_isCompatibleBlockSignature(NSMethodSignature *blockSignature, id object, SEL selector, NSError **error) { NSCParameterAssert(blockSignature); NSCParameterAssert(object); NSCParameterAssert(selector); BOOL signaturesMatch = YES; // 先根据 selector 生成 NSMethodSignature NSMethodSignature *methodSignature = [[object class] instanceMethodSignatureForSelector:selector]; // 在判断 blockSignature 的参数数量是否大于 methodSignature 的参数数量 // 因为 Aspect 并没有限制 block 一定要有参数，因此 methodSignature 的参数数量是可以大于 blockSignature 的参数数量 // 这给予了 Aspect 充分的灵活性 if (blockSignature.numberOfArguments &amp;gt; methodSignature.numberOfArguments) { signaturesMatch = NO; }else { if (blockSignature.numberOfArguments &amp;gt; 1) { // blockSignature 参数必定包含 block ，如果 &amp;gt; 1 ，则第一个参数必须为 id&amp;lt;AspectInfo&amp;gt; // 对应的 typeCode 为 &#39;@&#39; const char *blockType = [blockSignature getArgumentTypeAtIndex:1]; if (blockType[0] != &#39;@&#39;) { signaturesMatch = NO; } } // 逐个比较参数的类型是否相同 if (signaturesMatch) { for (NSUInteger idx = 2; idx &amp;lt; blockSignature.numberOfArguments; idx++) { const char *methodType = [methodSignature getArgumentTypeAtIndex:idx]; const char *blockType = [blockSignature getArgumentTypeAtIndex:idx]; // Only compare parameter, not the optional type data. if (!methodType || !blockType || methodType[0] != blockType[0]) { signaturesMatch = NO; break; } } } } if (!signaturesMatch) { NSString *description = [NSString stringWithFormat:@&quot;Block signature %@ doesn&#39;t match %@.&quot;, blockSignature, methodSignature]; AspectError(AspectErrorIncompatibleBlockSignature, description); return NO; } return YES;}在进行完所有检测之后，就可以生成对应的 AspectIdentifier 。AspectsContainerAsepectsContainer 包含一个对象或者类的所有 AspectIdentifier ，负责管理 AspectIdentifier 。// Tracks all aspects for an object/class.@interface AspectsContainer : NSObject- (void)addAspect:(AspectIdentifier *)aspect withOptions:(AspectOptions)injectPosition;- (BOOL)removeAspect:(id)aspect;- (BOOL)hasAspects;@property (atomic, copy) NSArray *beforeAspects;@property (atomic, copy) NSArray *insteadAspects;@property (atomic, copy) NSArray *afterAspects;@end每次生成 AspectsContainer 都是通过 aspect_getContainerForObject 方法来获取：static AspectsContainer *aspect_getContainerForObject(NSObject *self, SEL selector) { NSCParameterAssert(self); // 生成一个带有 “aspects_” 前缀的 selector SEL aliasSelector = aspect_aliasForSelector(selector); // 根据生成的 selector 获取对应的 container ，如果 container 为空，则生成一个新的，并设置到对应的对象中 AspectsContainer *aspectContainer = objc_getAssociatedObject(self, aliasSelector); if (!aspectContainer) { aspectContainer = [AspectsContainer new]; objc_setAssociatedObject(self, aliasSelector, aspectContainer, OBJC_ASSOCIATION_RETAIN); } return aspectContainer;}最后再将生成的 AspectIdentifier 添加到 AspectsContainer 中：identifier = [AspectIdentifier identifierWithSelector:selector object:self options:options block:block error:error];if (identifier) { [aspectContainer addAspect:identifier withOptions:options]; // Modify the class to allow message interception. aspect_prepareClassAndHookSelector(self, selector, error);}aspect_prepareClassAndHookSelector接下来开始进行一些准备工作和 hook 操作：static void aspect_prepareClassAndHookSelector(NSObject *self, SEL selector, NSError **error) { NSCParameterAssert(selector); Class klass = aspect_hookClass(self, error); Method targetMethod = class_getInstanceMethod(klass, selector); IMP targetMethodIMP = method_getImplementation(targetMethod); if (!aspect_isMsgForwardIMP(targetMethodIMP)) { // Make a method alias for the existing method implementation, it not already copied. const char *typeEncoding = method_getTypeEncoding(targetMethod); SEL aliasSelector = aspect_aliasForSelector(selector); if (![klass instancesRespondToSelector:aliasSelector]) { __unused BOOL addedAlias = class_addMethod(klass, aliasSelector, method_getImplementation(targetMethod), typeEncoding); NSCAssert(addedAlias, @&quot;Original implementation for %@ is already copied to %@ on %@&quot;, NSStringFromSelector(selector), NSStringFromSelector(aliasSelector), klass); } // We use forwardInvocation to hook in. class_replaceMethod(klass, selector, aspect_getMsgForwardIMP(self, selector), typeEncoding); AspectLog(@&quot;Aspects: Installed hook for -[%@ %@].&quot;, klass, NSStringFromSelector(selector)); }}同样地， aspect_prepareClassAndHookSelector 方法也没有太多自己的实现逻辑，只是负责调用其它方法。aspect_hookClassstatic Class aspect_hookClass(NSObject *self, NSError **error) { NSCParameterAssert(self); // statedClass 是类对象 // baseClass 是类的 isa Class statedClass = self.class; Class baseClass = object_getClass(self); // 获取类 isa 的类名 NSString *className = NSStringFromClass(baseClass); // 如果 className 包含 “_Aspects_&quot; ，则表示它已经被 hook 处理过，直接返回即可 if ([className hasSuffix:AspectsSubclassSuffix]) { return baseClass; }else if (class_isMetaClass(baseClass)) { // 如果 baseClass 是isa，则表示是在 Class 层面进行 hook ，需要进行 aspect_swizzleClassInPlace return aspect_swizzleClassInPlace((Class)self); }else if (statedClass != baseClass) { // 如果 statedClass 与 baseClass 不相等，则说明有可能是 KVO 过的对象，因为 KVO 对象会生成一个中间类 // 也进行 aspect_swizzleClassInPlace return aspect_swizzleClassInPlace(baseClass); } // 这里往下是在实例对象层面进行 hook 方法操作，会参考 KVO 的实现原理，动态生成一个新的子类 // 子类包含后缀 “_Aspects_” const char *subclassName = [className stringByAppendingString:AspectsSubclassSuffix].UTF8String; Class subclass = objc_getClass(subclassName); if (subclass == nil) { subclass = objc_allocateClassPair(baseClass, subclassName, 0); if (subclass == nil) { NSString *errrorDesc = [NSString stringWithFormat:@&quot;objc_allocateClassPair failed to allocate class %s.&quot;, subclassName]; AspectError(AspectErrorFailedToAllocateClassPair, errrorDesc); return nil; } // hook 转发方法 aspect_swizzleForwardInvocation(subclass); // 将 class 方法指回给原来的类 aspect_hookedGetClass(subclass, statedClass); aspect_hookedGetClass(object_getClass(subclass), statedClass); // 生成新的类 objc_registerClassPair(subclass); } // 设置 self 为新生成的子类 object_setClass(self, subclass); return subclass;}aspect_swizzleClassInPlacestatic Class aspect_swizzleClassInPlace(Class klass) { NSCParameterAssert(klass); NSString *className = NSStringFromClass(klass); _aspect_modifySwizzledClasses(^(NSMutableSet *swizzledClasses) { if (![swizzledClasses containsObject:className]) { aspect_swizzleForwardInvocation(klass); [swizzledClasses addObject:className]; } }); return klass;}aspect_swizzleClassInPlace 做重复性判断，防止重复 hook 相同的类。_aspect_modifySwizzledClassesstatic void _aspect_modifySwizzledClasses(void (^block)(NSMutableSet *swizzledClasses)) { // 维护一个全局的 NSMutableSet ，用来记录进行过 swizzle 的 Class static NSMutableSet *swizzledClasses; static dispatch_once_t pred; // dispatch_once 保证只执行一次 dispatch_once(&amp;amp;pred, ^{ swizzledClasses = [NSMutableSet new]; }); // @synchronized 线程安全 @synchronized(swizzledClasses) { block(swizzledClasses); }}aspect_swizzleForwardInvocationstatic NSString *const AspectsForwardInvocationSelectorName = @&quot;__aspects_forwardInvocation:”;static void aspect_swizzleForwardInvocation(Class klass) { NSCParameterAssert(klass); // If there is no method, replace will act like class_addMethod. IMP originalImplementation = class_replaceMethod(klass, @selector(forwardInvocation:), (IMP)__ASPECTS_ARE_BEING_CALLED__, “v@:@“); if (originalImplementation) { class_addMethod(klass, NSSelectorFromString(AspectsForwardInvocationSelectorName), originalImplementation, &quot;v@:@&quot;); } AspectLog(@&quot;Aspects: %@ is now aspect aware.&quot;, NSStringFromClass(klass));}对 Class 的 forwardInvocation: 方法进行 hook ，替换成自己的 __ASPECTS_ARE_BEING_CALLED__ 方法。aspect_hookedGetClassstatic void aspect_hookedGetClass(Class class, Class statedClass) { NSCParameterAssert(class); NSCParameterAssert(statedClass); Method method = class_getInstanceMethod(class, @selector(class)); IMP newIMP = imp_implementationWithBlock(^(id self) { return statedClass; }); class_replaceMethod(class, @selector(class), newIMP, method_getTypeEncoding(method));}因为在 hook 对象层面的方法时，我们动态生成了一个子类，所以需要将子类和子类 isa 的 class 方法指回给原来的类。aspect_hookedGetClass(subclass, statedClass);aspect_hookedGetClass(object_getClass(subclass), statedClass);aspect_prepareClassAndHookSelector做完以上准备后回到 aspect_prepareClassAndHookSelector 接着走完剩下的流程static void aspect_prepareClassAndHookSelector(NSObject *self, SEL selector, NSError **error) { NSCParameterAssert(selector); // kClass 是需要进行操作的类 Class klass = aspect_hookClass(self, error); Method targetMethod = class_getInstanceMethod(klass, selector); IMP targetMethodIMP = method_getImplementation(targetMethod); if (!aspect_isMsgForwardIMP(targetMethodIMP)) { // Make a method alias for the existing method implementation, it not already copied. const char *typeEncoding = method_getTypeEncoding(targetMethod); // 生成带前缀 “aspects_” 的 selector SEL aliasSelector = aspect_aliasForSelector(selector); if (![klass instancesRespondToSelector:aliasSelector]) { // 添加 aliasSelector ，IMP 为原来的方法 IMP 。 __unused BOOL addedAlias = class_addMethod(klass, aliasSelector, method_getImplementation(targetMethod), typeEncoding); NSCAssert(addedAlias, @&quot;Original implementation for %@ is already copied to %@ on %@&quot;, NSStringFromSelector(selector), NSStringFromSelector(aliasSelector), klass); } // 将 selector 指向 aspect_getMsgForwardIMP 即 _objc_msgForward class_replaceMethod(klass, selector, aspect_getMsgForwardIMP(self, selector), typeEncoding); AspectLog(@&quot;Aspects: Installed hook for -[%@ %@].&quot;, klass, NSStringFromSelector(selector)); }}// 判断是否为消息转发的 IMP 。static BOOL aspect_isMsgForwardIMP(IMP impl) { return impl == _objc_msgForward#if !defined(__arm64__) || impl == (IMP)_objc_msgForward_stret#endif ;}ASPECTS_ARE_BEING_CALLED__ASPECTS_ARE_BEING_CALLED__ 是 Aspect hook 后提供的 forwardInvocation: 方法：SEL originalSelector = invocation.selector;SEL aliasSelector = aspect_aliasForSelector(invocation.selector);invocation.selector = aliasSelector;invocation.selector 为原有的 selector ，但是经过 hook 后已经指向了 _objc_msgForward ， aliasSelector 才是指向原有 IMP 的 selector 。AspectsContainer *objectContainer = objc_getAssociatedObject(self, aliasSelector);AspectsContainer *classContainer = aspect_getContainerForClass(object_getClass(self), aliasSelector);AspectInfo *info = [[AspectInfo alloc] initWithInstance:self invocation:invocation];NSArray *aspectsToRemove = nil;获取对应的 container ，同时生成对应的 AspectInfo 。// Before hooks.aspect_invoke(classContainer.beforeAspects, info);aspect_invoke(objectContainer.beforeAspects, info);运行 hook 前的 beforeAspectsBOOL respondsToAlias = YES;// 判断是否需要运行替代 hook ，检查 `insteadAspects` 是否为空if (objectContainer.insteadAspects.count || classContainer.insteadAspects.count) { aspect_invoke(classContainer.insteadAspects, info); aspect_invoke(objectContainer.insteadAspects, info);}else { Class klass = object_getClass(invocation.target); do { if ((respondsToAlias = [klass instancesRespondToSelector:aliasSelector])) { // invocation 的 selector 在前面已经被替换 aliasSelector ，对应的是原始方法的 IMP 。 [invocation invoke]; break; } }while (!respondsToAlias &amp;amp;&amp;amp; (klass = class_getSuperclass(klass)));}aspect_invoke(classContainer.afterAspects, info);aspect_invoke(objectContainer.afterAspects, info);运行 hook 后的 afterAspectsif (!respondsToAlias) { invocation.selector = originalSelector; SEL originalForwardInvocationSEL = NSSelectorFromString(AspectsForwardInvocationSelectorName); if ([self respondsToSelector:originalForwardInvocationSEL]) { ((void( *)(id, SEL, NSInvocation *))objc_msgSend)(self, originalForwardInvocationSEL, invocation); }else { [self doesNotRecognizeSelector:invocation.selector]; }}[aspectsToRemove makeObjectsPerformSelector:@selector(remove)];没有成功 hook ，调用原有的 forwardInvocation: 对应的 IMP ，如果没有 forwardInvocation: 对应的 IMP ，则报 doesNotRecognizeSelector 的错。最后判断是否需要 remove 当前的 hook 。#define aspect_invoke(aspects, info) \\for (AspectIdentifier *aspect in aspects) {\\ [aspect invokeWithInfo:info];\\ if (aspect.options &amp;amp; AspectOptionAutomaticRemoval) { \\ aspectsToRemove = [aspectsToRemove?:@[] arrayByAddingObject:aspect]; \\ } \\}为了使调用栈更清晰，这里的 aspect_invoke 采用宏定义的方式。invokeWithInfo:看看 AspectIdentifier 的 invokeWithInfo 具体实现。NSInvocation *blockInvocation = [NSInvocation invocationWithMethodSignature:self.blockSignature];NSInvocation *originalInvocation = info.originalInvocation;首先根据 AspectIdentifier 的 blockSignature 方法来获取 block 对应的 blockInvocation 。NSUInteger numberOfArguments = self.blockSignature.numberOfArguments;// Be extra paranoid. We already check that on hook registration.if (numberOfArguments &amp;gt; originalInvocation.methodSignature.numberOfArguments) { AspectLogError(@“Block has too many arguments. Not calling %@“, info); return NO;}上面已经说过为了保持 Aspects 的灵活性， block 的参数数量是可以小于原有方法的参数数量的，这里只需要确认 block 参数数量是否不大于原有方法的参数数量。其实这里注释说了这是一种强迫症行为，之前已经检测过参数数量了。// The `self` of the block will be the AspectInfo. Optional.if (numberOfArguments &amp;gt; 1) { [blockInvocation setArgument:&amp;amp;info atIndex:1];}如果 block 有参数，则第一个参数必须为 AspectInfo 。void *argBuf = NULL;for (NSUInteger idx = 2; idx &amp;lt; numberOfArguments; idx++) { const char *type = [originalInvocation.methodSignature getArgumentTypeAtIndex:idx]; NSUInteger argSize; NSGetSizeAndAlignment(type, &amp;amp;argSize, NULL); if (!(argBuf = reallocf(argBuf, argSize))) { AspectLogError(@“Failed to allocate memory for block invocation.”); return NO; } [originalInvocation getArgument:argBuf atIndex:idx]; [blockInvocation setArgument:argBuf atIndex:idx];}[blockInvocation invokeWithTarget:self.block];从 originalInvocation 获取原有方法的参数，然后设置给 blockInvocation ，最后通过 [blockInvocation invokeWithTarget:self.block] 调用 block 。if (argBuf != NULL) { free(argBuf);}return YES;释放 argBuf ，返回 YES 。移除 hookAspects 支持在 hook 后移除的操作：[aspectsToRemove makeObjectsPerformSelector:@selector(remove)];移除的入口为 AspectIdentifier 的 remove 方法：- (BOOL)remove { return aspect_remove(self, NULL);}aspect_removestatic BOOL aspect_remove(AspectIdentifier *aspect, NSError **error) { NSCAssert([aspect isKindOfClass:AspectIdentifier.class], @“Must have correct type.”); __block BOOL success = NO; aspect_performLocked(^{ id self = aspect.object; // strongify if (self) { // 获取对应的 container AspectsContainer *aspectContainer = aspect_getContainerForObject(self, aspect.selector); success = [aspectContainer removeAspect:aspect]; aspect_cleanupHookedClassAndSelector(self, aspect.selector); // destroy token aspect.object = nil; aspect.block = nil; aspect.selector = NULL; }else { NSString *errrorDesc = [NSString stringWithFormat:@&quot;Unable to deregister hook. Object already deallocated: %@&quot;, aspect]; AspectError(AspectErrorRemoveObjectAlreadyDeallocated, errrorDesc); } }); return success;}调用 container 的 removeAspect: 方法来从 container 中移除对应的 Aspect ：- (BOOL)removeAspect:(id)aspect { for (NSString *aspectArrayName in @[NSStringFromSelector(@selector(beforeAspects)), NSStringFromSelector(@selector(insteadAspects)), NSStringFromSelector(@selector(afterAspects))]) { NSArray *array = [self valueForKey:aspectArrayName]; NSUInteger index = [array indexOfObjectIdenticalTo:aspect]; if (array &amp;amp;&amp;amp; index != NSNotFound) { NSMutableArray *newArray = [NSMutableArray arrayWithArray:array]; [newArray removeObjectAtIndex:index]; [self setValue:newArray forKey:aspectArrayName]; return YES; } } return NO;}从 beforeAspects ， insteadAspects 和 afterAspects 中排查是否包含有对应的 aspect ，如果有则移除，返回 YES ，否则返回 NO 。aspect_cleanupHookedClassAndSelector从 container 移除 aspect 后，接下来要复原对 runtime 的处理：Class klass = object_getClass(self);BOOL isMetaClass = class_isMetaClass(klass);if (isMetaClass) { klass = (Class)self;}首先需要根据是否为 metaClass 做下处理。Method targetMethod = class_getInstanceMethod(klass, selector);IMP targetMethodIMP = method_getImplementation(targetMethod);if (aspect_isMsgForwardIMP(targetMethodIMP)) { // Restore the original method implementation. const char *typeEncoding = method_getTypeEncoding(targetMethod); SEL aliasSelector = aspect_aliasForSelector(selector); Method originalMethod = class_getInstanceMethod(klass, aliasSelector); IMP originalIMP = method_getImplementation(originalMethod); NSCAssert(originalMethod, @&quot;Original implementation for %@ not found %@ on %@&quot;, NSStringFromSelector(selector), NSStringFromSelector(aliasSelector), klass); class_replaceMethod(klass, selector, originalIMP, typeEncoding); AspectLog(@&quot;Aspects: Removed hook for -[%@ %@].&quot;, klass, NSStringFromSelector(selector));}如果我们已经成功 hook ，则原有的 selector 指向的 IMP 为 _objc_msgForward 的 IMP ，再获取 aliasSelector ， aliasSelector 指向的 IMP 为原有方法的 IMP ，通过 class_replaceMethod 将原有的 selector 指向原有的 IMP 。aspect_deregisterTrackedSelectorstatic void aspect_deregisterTrackedSelector(id self, SEL selector) { if (!class_isMetaClass(object_getClass(self))) return; NSMutableDictionary *swizzledClassesDict = aspect_getSwizzledClassesDict(); NSString *selectorName = NSStringFromSelector(selector); Class currentClass = [self class]; AspectTracker *subclassTracker = nil; do { AspectTracker *tracker = swizzledClassesDict[currentClass]; if (subclassTracker) { [tracker removeSubclassTracker:subclassTracker hookingSelectorName:selectorName]; } else { [tracker.selectorNames removeObject:selectorName]; } if (tracker.selectorNames.count == 0 &amp;amp;&amp;amp; tracker.selectorNamesToSubclassTrackers) { [swizzledClassesDict removeObjectForKey:currentClass]; } subclassTracker = tracker; }while ((currentClass = class_getSuperclass(currentClass)));}从全局的 trackers 记录中清除对应的 selectorName ，同时向上递归，从父类中也移除响应的 selectorName ，如果 selectorNames 为空，则从全局的 trackers 记录中清除对应的 tracker 。清除对应的 containerAspectsContainer *container = aspect_getContainerForObject(self, selector);首先根据 selector 获取对应的 container ，判断 container 是否还包含有 AspectIdentifier ，如果没有，就销毁 container ，复原 forwardInvocation: 方法的 hook ：if (!container.hasAspects) { ……}aspect_destroyContainerForObjectstatic void aspect_destroyContainerForObject(id&amp;lt;NSObject&amp;gt; self, SEL selector) { NSCParameterAssert(self); SEL aliasSelector = aspect_aliasForSelector(selector); objc_setAssociatedObject(self, aliasSelector, nil, OBJC_ASSOCIATION_RETAIN);}aspect_destroyContainerForObject 的实现很简单，根据对应的 selector 调用 objc_setAssociatedObject 方法把 container 设为 nil 即可。对 Class 做处理NSString *className = NSStringFromClass(klass);if ([className hasSuffix:AspectsSubclassSuffix]) { Class originalClass = NSClassFromString([className stringByReplacingOccurrencesOfString:AspectsSubclassSuffix withString:@“”]); NSCAssert(originalClass != nil, @&quot;Original class must exist”); object_setClass(self, originalClass); AspectLog(@“Aspects: %@ has been restored.”, NSStringFromClass(originalClass)); // 我们只有在能确定没有实例对象使用我们动态生成的子类时才可以调用 objc_disposeClassPair 来释放掉生成的子类 // 但是我们没有进行全局的记录，所以无法确认，即使保持生成的子类也不会造成太大的性能影响。 //objc_disposeClassPair(object.class);}else { // Class is most likely swizzled in place. Undo that. if (isMetaClass) { aspect_undoSwizzleClassInPlace((Class)self); }else if (self.class != klass) { aspect_undoSwizzleClassInPlace(klass); }}首先判断 className 是否有后缀，如果有，则表示是 KVO 生成的子类，只需要将 self 设置回原有的 originalClass 即可。aspect_undoSwizzleClassInPlacestatic void aspect_undoSwizzleClassInPlace(Class klass) { NSCParameterAssert(klass); NSString *className = NSStringFromClass(klass); _aspect_modifySwizzledClasses(^(NSMutableSet *swizzledClasses) { if ([swizzledClasses containsObject:className]) { aspect_undoSwizzleForwardInvocation(klass); [swizzledClasses removeObject:className]; } });}同样地，我们需要对 forwardInvocation: 方法做还原处理， aspect_undoSwizzleClassInPlace 只是通过全局的 swizzledClasses 来判断是否要进行还原，真正的还原操作还是通过 aspect_undoSwizzleForwardInvocation 来处理。aspect_undoSwizzleForwardInvocationstatic void aspect_undoSwizzleForwardInvocation(Class klass) { NSCParameterAssert(klass); Method originalMethod = class_getInstanceMethod(klass, NSSelectorFromString(AspectsForwardInvocationSelectorName)); Method objectMethod = class_getInstanceMethod(NSObject.class, @selector(forwardInvocation:)); // 这里做多一层防御，如果 originalMethod 为空，就使用 NSObject 的 forwardInvocation: 代替 IMP originalImplementation = method_getImplementation(originalMethod ?: objectMethod); class_replaceMethod(klass, @selector(forwardInvocation:), originalImplementation, &quot;v@:@&quot;); AspectLog(@&quot;Aspects: %@ has been restored.&quot;, NSStringFromClass(klass));}由于前面已经 hook 了 forwardInvocation: ，所以这里通过 NSSelectorFromString(AspectsForwardInvocationSelectorName) 获取的 SEL 是原有的 SEL ，将 forwardInvocation: 指向 originalImplementation 即可还原。总结Aspects 作为一个提供 AOP 功能的库，全部代码不到一千行，且非常简单易用，就我看来，它有以下优点：入口简单Aspects 的入口只有两个方法：@interface NSObject (Aspects)+ (id&amp;lt;AspectToken&amp;gt;)aspect_hookSelector:(SEL)selector withOptions:(AspectOptions)options usingBlock:(id)block error:(NSError **)error;- (id&amp;lt;AspectToken&amp;gt;)aspect_hookSelector:(SEL)selector withOptions:(AspectOptions)options usingBlock:(id)block error:(NSError **)error;@end对使用者来说，使用成本非常低，只需要根据自己的需求调用对应的方法即可，不再需要关心其它设置，拿来即用。灵活Aspects 不仅支持 metaClass 的 hook ，也支持实例对象的 hook ，且 hook 之后还可以进行移除 ，同时，对 block 进行了处理，使得 block 的参数数量可以小于方法的参数数量，更提高了灵活性，基本可满足一些常见的需求。健壮性由于 Aspects 是通过 runtime 进行操作，可能会影响整个 app ，对健壮性要求较高， Aspects 对各种情况都做了预防性编程，有些地方还做了些强迫症的检测，包括原有 selector 是否存在，block 结构是否正常等。当然，除非是只能采取 hook 方案的需求，否则还是不要使用比较好，另外就是必须要假设 hook 失效的情况下，app 也可以正常运行，毕竟苹果爸爸说不定哪天就改了内部 block 的实现。但是 Aspects 也有缺点，由于是通过消息转发流程来处理，性能上不如传统的 Method Swizzling 方式，同时由于对 forwardInvocation: 做了替换，如果其它一些库也对 forwardInvocation: 做了类似的操作，就有可能导致一些奇奇怪怪的问题。参考NSInvocation - Foundation | Apple Developer Documentation [NSMethodSignature - Foundation Apple Developer Documentation](https://developer.apple.com/documentation/foundation/nsmethodsignature) [面向切面编程之 Aspects 源码解析及应用 WeRead团队博客](https://wereadteam.github.io/2016/06/30/Aspects/) " }, { "title": "《数据结构与算法之美》学习笔记三", "url": "/posts/beauty-of-data-structures-and-algorithms-third/", "categories": "", "tags": "阅读笔记, Algorithm", "date": "2020-02-04 20:32:19 +0800", "snippet": "计数排序、桶排序和基数排序三种线性排序算法 计数排序、桶排序与基数排序 - BYVoid 这篇也说得比较好。基于比较的排序有快排，插入排序和选择排序等，基于比较的排序算法是不能突破 O(nlogn) 的。 N个数有N!个可能的排列情况，也就是说基于比较的排序算法的判定树有N!个叶子结点，比较次数至少为log(N!)=O(NlogN)(斯特林公式)。非基于比较的排序，如计数排序，桶排序和基数排序，则有严格的条件限制。 从整体上来说，计数排序，桶排序都是非基于比较的排序算法，而其时间复杂度依赖于数据的范围，桶排序还依赖于空间的开销和数据的分布。而基数排序是一种对多元组排序的有效方法，具体实现要用到计数排序或桶排序。相对于快速排序、堆排序等基于比较的排序算法，计数排序、桶排序和基数排序限制较多，不如快速排序、堆排序等算法灵活性好。但反过来讲，这三种线性排序算法之所以能够达到线性时间，是因为充分利用了待排序数据的特性，如果生硬得使用快速排序、堆排序等算法，就相当于浪费了这些特性，因而达不到更高的效率。在实际应用中，基数排序可以用于后缀数组的倍增算法，使时间复杂度从O(NlogNlogN)降到O(N*logN)。线性排序算法使用最重要的是，充分利用数据特殊的性质，以达到最佳效果。— BYVoidSwift 使用的排序算法swift/Sort.swift at master · apple/swift · GitHubSwift 使用 Timsort - Wikipedia排序算法，Timsort 排序是插入排序和归并排序一起混用的排序算法。归并排序最好，最坏和平均情况下的时间复杂度都是 O(nlogn) 。而 Timsort 在最好情况下可以达到 O(n) 。Timsort 具体的原理可以看这里 Timsort原理学习 · Sika二分查找Binary Search - LeetCodeRedis 的跳表实现为了提高链表的遍历速度，跳表使用了多级索引来协助查找数据，使得链表查找数据的时间复杂度为 O(n) 。同时链表天生支持高效的插入，删除。为了防止跳表退化成单链表，会在插入时会随机插入部分索引层中。散列表散列表是数组的变型，支持数组按照下标随机访问数据的特性，下标就是散列表的 key ，key 通过散列函数 hash(key) 转换成数组下标，再通过下标得到对应的值。散列函数得到的值叫做 Hash 值。散列函数的设计不能太复杂。过于复杂的散列函数，势必会消耗很多计算时间，也就间接的影响到散列表的性能。其次，散列函数生成的值要尽可能随机并且均匀分布，这样才能避免或者最小化散列冲突，而且即便出现冲突，散列到每个槽里的数据也会比较平均，不会出现某个槽内数据特别多的情况。装载因子用表示已占据位置的百分比：散列表的装载因子=填入表中的元素个数/散列表的长度当散列表的元素越多，装载因子就越大，需要进行动态扩容。与数组的扩容不同，散列表的扩容，数据搬移操作需要重新计算每个数据的存储位置。但是可以均摊到每次插入操作里，使得插入操作的时间成本为 O(1) 。如果内存紧张，还可以使用动态收缩，同时也可以根据情况调整装载因子的大小。为了避免一次性扩容时耗时过多，可以讲数据搬移操作分摊到后续的插入操作中，每次插入数据时都对旧的数据进行一次搬移操作。解决冲突开放寻址法开放寻址法的核心思想是，如果出现了散列冲突，就重新探测一个空闲位置，将其插入。探测方法有线性探测，二次探测和双重探测等。优点： 所有数据都在数组中，有效利用 CPU 缓存加快查询呢速度； 序列化比较简单缺点： 处理冲突的代价更高，所以装载因子的上限不能太大，导致需要更多的内存工具；链表法链表法是一种更加常用的散列冲突解决办法，在散列表中，每个“桶（bucket）”或者“槽（slot）”会对应一条链表，所有散列值相同的元素我们都放到相同槽位对应的链表中。链表需要存储指针，会消耗额外的内存，且不是连续的内存分布，对 CPU 缓存不友好。基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表。使用 Swift 来实现 Hash Table ，采用的是链表法，Hash Table 。散列表和链表结合一起可以使增删改查操作都在 O(1) 时间内完成。" }, { "title": "下一个十年", "url": "/posts/2019/", "categories": "", "tags": "summary", "date": "2020-01-05 19:28:40 +0800", "snippet": "工作今年十一月份的时候换了份工作，来到了大公司。为什么要换工作呢？从17年4月份加入前司到现在差不多过了两年半，所有东西都非常熟悉了，跟大家也都聊得很开，进入了一个舒适区，但是因为业务上的东西都太熟悉了，日常任务感觉上都是一些比较重复的东西。加上快到年底了，也想出去看看机会，看看自己的技术水平。刚好接到了一个比较不错的 Offer ，也想尝试一下，然后开始重新使用 Objective-C 。为什么要加入创业公司呢？就我个人来说有以下几点优点： 从 0 到 1 搭建一款产品，你可以经历到一款产品从无到有的完整历程，如果是做社交，产品早期的 KOL 你应该都认识的，整个社区对你来说都是有血有肉的，而不是冷冰冰的数据。 没有大公司的条条框框，小团队内大家都比较熟悉，也互相信任，知道对方的工作是什么，不需要各种规则去限制。 成功后的财务自由，这个老实说概率比较低。在两年多以后，我个人感觉以上几点优点都快荡然无存了，而且也没有一些技术上的挑战。于是决定去大公司尝试下。学习算法今年 7 月份开始重学算法，看书，在 LeetCode 上做题，虽然有一部分原因是为了找工作，但是算法和计算机原理这些算是普适性比较强的知识，不过以后做前端，后端还是什么，这些知识都可以对你有一定的帮助。换了工作后比较忙，明年希望可以坚持下来，打打周赛。英文今年也开始重学英文，使用墨墨背单词来背单词。到现在进展还算不错，也有坚持下来，虽然有时候每天签到会断。编程学了一下 Ruby ，主要是刷题用，iOS 上有比较多的工具链都会使用 Ruby 来编写，如 fastlane，cocoapods ，目前还没碰到在工作中实际运用的机会，希望后面机会运用。老本行 iOS 的话，学习了戴铭老师的 iOS开发高手课_iOS_移动开发-极客时间 ，这个课程的每一章都值得去深入研究，希望自己下年可以开源一个框架或者再做一款 App 。阅读银河帝国：基地银河帝国2：基地与帝国银河帝国3：第二基地银河帝国4：基地前奏银河帝国5：迈向基地银河帝国6：基地边缘银河帝国7：基地与地球银河帝国8：我，机器人年初有段时间通勤时间非常长，于是在地铁上把银河帝国的几部都看完了。前面 7 本属于基地部分，哈里·谢顿在发现现有的文明已不可避免地走向堕落的情况下，希望通过自己的计划将三万年的黑暗洪荒时期缩短为一千年。心理史学只能预测群体的发展，对于个体则不可预测，而计划却又依赖部分突出的个体，所以谢顿建立了第二基地来做那只看不见的手，适当地对群体做调整。万历十五年道德是个好武器，无论是谁，都能从道德上找到点瑕疵。从里面也可以看到现在社会的一些影子。奈飞文化手册一个好的公司文化应该是怎样的。但是普通员工看了没有什么用，关键还是要老板看和执行。解读基金今年开始入门投资，先从基金开始，这本算是基金入门指南，虽然里面有些内容已经过期。指数基金投资指南前面部分还算不错，讲述各个指数基金，指标计算方法，操作方式等，后面就有点滥竽充数了，可跳过。香港第一课香港问题从何而来。无人生还高中时看过一次了，前段时间看了《利刃出鞘》，于是重温下，依旧好看。Effective Objective-C 2.0Objective-C高级编程禅与 Objective-C 编程艺术再次重度使用 Objective-C ，上面三本都是值得一读再读的好书。李志今年没有李志的跨年演唱会，2019年4月12日李志因为不可抗力因素被封杀了。 11 年的主题是 IMAGINE ，取自列侬的 IMAGINE 歌曲，在南京创意中央，嘉宾是 声音玩具，声音碎片。这场的视频我现在还存在电脑里，有时候也会拿出来看看，就我个人来看，我比较喜欢那场演唱会中的李志，够原始，舞台和团队都比不上后来的几年，但是很多歌曲都可以唱，一些改编也很不错。也是我看的第一个李志的跨年演唱会（视频）。从里面你可以看到后来一些歌曲改编的影子，《结婚》，《她+鹿港小镇》等。那会李志在台上还会抽烟，想抽烟地时候就比个二，然后就有个人跑上来递烟。你可以在维基上看到历届跨年的演出主题，地点和嘉宾。李志 - 维基百科，自由的百科全书我从 12 年开始经常听李志，看他的微博，看维权历程，叁叁肆的巡演。看他教导大家去为正版付费，努力工作，为自己热爱的东西付出，这些都不是说空话，而是身体力行地做这些事。在这七八年了，我一直在受他影响。如果要选一个一生唯一的偶像，我也大概率会选他。可是今年开始你不可能再在国内看到李志的跨年了，这个世界还会好吗？最后2019 年过去了，就我个人来说它算是不错的一年，可是这世界上有太多不好的事件发生，这个国家也是，只希望接下来的十年会好一点。" }, { "title": "《数据结构与算法之美》笔记二", "url": "/posts/beauty-of-data-structures-and-algorithms-second/", "categories": "", "tags": "阅读笔记, Algorithm", "date": "2020-01-04 21:59:56 +0800", "snippet": "递归Recursion - LeetCode对于重复子问题，可以使用备忘录优化。排序冒泡排序原地排序，稳定的排序算法。冒泡排序算法的运作如下： 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。class Array def bubble_sort! (0...(size - 1)).each do |i| (0...(size - i - 1)).each do |j| self[j], self[j + 1] = self[j + 1], self[j] if self[j] &amp;gt; self[j + 1] end end self endend最坏时间复杂度 O(n^2)最优时间复杂度 O(n^2)平均时间复杂度 O(n^2)最坏空间复杂度 O(n) 需要辅助空间 O(1)插入排序核心：通过构建有序序列，对于未排序序列，从后向前扫描(对于单向链表则只能从前往后遍历)，找到相应位置并插入。实现上通常使用in-place排序(需用到O(1)的额外空间) 从第一个元素开始，该元素可认为已排序 取下一个元素，对已排序数组从后往前扫描 若从排序数组中取出的元素大于新元素，则移至下一位置 重复步骤3，直至找到已排序元素小于或等于新元素的位置 插入新元素至该位置 重复2~5性质： 交换操作和数组中导致的数量相同 比较次数&amp;gt;=倒置数量，&amp;lt;=倒置的数量加上数组的大小减一 每次交换都改变了两个顺序颠倒的元素的位置，即减少了一对倒置，倒置数量为0时即完成排序。 每次交换对应着一次比较，且1到N-1之间的每个i都可能需要一次额外的记录(a[i]未到达数组左端时) 最坏情况下需要 ~N^2/2 次比较和 ~N^2/2次交换，最好情况下需要N-1次比较和0次交换。 平均情况下需要 ~N^2/4 次比较 和 ~N^2/4次交换 class Array def insert_sort! n = size return self if n &amp;lt;= 1 (1...n).each do |i| i.downto(1).each do |j| if self[j] &amp;lt; self[j - 1] self[j], self[j - 1] = self[j - 1], self[j] else break end end end self endend如果目标是把n个元素的序列升序排列，那么采用插入排序存在最好情况和最坏情况。最好情况就是，序列已经是升序排列了，在这种情况下，需要进行的比较操作需 n - 1 次即可。最坏情况就是，序列是降序排列，那么此时需要进行的比较共有 n(n -1) / 2 次。插入排序的赋值操作是比较操作的次数减去 n - 1 次，（因为 n - 1 次循环中，每一次循环的比较都比赋值多一个，多在最后那一次比较并不带来赋值）。平均来说插入排序算法复杂度为 O(n^2) 。因而，插入排序不适合对于数据量比较大的排序应用。但是，如果需要排序的数据量很小，例如，量级小于千；或者若已知输入元素大致上按照顺序排列，那么插入排序还是一个不错的选择。 插入排序在工业级库中也有着广泛的应用，在STL的sort算法和stdlib的qsort算法中，都将插入排序作为快速排序的补充，用于少量元素的排序（通常为8个或以下）。选择排序选择排序（Selection sort）是一种简单直观的 排序算法 。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上，因此对 n 个元素的表进行排序总共进行至多 n - 1 次交换。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。class Array def selection_sort! (0...(size - 1)).each do |i| min_index = i (i...(size - 1)).each do |j| min_index = j if self[j] &amp;lt; self[min_index] end self[min_index], self[i] = self[i], self[min_index] end self endend选择排序的交换操作介于 0 和 n - 1 次之间。选择排序的比较操作为 n(n - 1)/2 次。选择排序的赋值操作介于 0 和 3(n - 1) 次之间。比较次数 O(n^2) ，比较次数与关键字的初始状态无关，总的比较次数 N = (n - 1) + (n - 2) + … + 1 = n * (n - 1)/2。交换次数 O(n)，最好情况是，已经有序，交换0次；最坏情况是，逆序，交换 n - 1次。交换次数比冒泡排序较少，由于交换所需CPU时间比比较所需的CPU时间多，n 值较小时，选择排序比冒泡排序快。原地操作几乎是选择排序的唯一优点，当空间复杂度要求较高时，可以考虑选择排序；实际适用的场合非常罕见。最坏时间复杂度：О(n²)最优时间复杂度：О(n²)平均时间复杂度：О(n²)归并排序归并排序（英语：Merge sort，或mergesort），是创建在归并操作上的一种有效的 排序算法 ， 效率 为 O(n log n)（ 大O符号 ）。1945年由 约翰·冯·诺伊曼 首次提出。该算法是采用 分治法 （Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。采用分治法: 分割：递归地把当前序列平均分割成两半。 集成：在保持元素顺序的同时将上一步得到的子序列集成到一起（归并）。def merge(array, low, mid, high) i = low j = mid + 1 aux = [] (low..high).each do |k| aux[k] = array[k] end (low..high).each do |k| if i &amp;gt; mid # low 到 mid 部分已完全插入到 array 中 array[k] = aux[j] j += 1 elsif j &amp;gt; high # mid + 1 到 high 部分已完全插入到 array 中 array[k] = aux[i] i += 1 elsif aux[j] &amp;lt; aux[i] # 两者比较取最小值 array[k] = aux[j] j += 1 else array[k] = aux[i] i += 1 end endend归并操作（merge），也叫归并算法，指的是将两个已经排序的序列合并成一个序列的操作。归并排序算法依赖归并操作。递归法（Top-down） 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列 设定两个指针，最初位置分别为两个已经排序序列的起始位置 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置 重复步骤3直到某一指针到达序列尾 将另一序列剩下的所有元素直接复制到合并序列尾# Top - Downdef merge_sort_recursive(array, low, high) return if high &amp;lt;= low mid = low + (high - low) / 2 merge_sort_recursive(array, low, mid) merge_sort_recursive(array, mid + 1, high) merge(array, low, mid, high) arrayend迭代法（Bottom-up）原理如下（假设序列共有 n 个元素）： 将序列每相邻两个数字进行归并操作，形成 ceil(n/2) 个序列，排序后每个序列包含两/一个元素 若此时序列数不是1个则将上述序列再次归并，形成 ceil(n/4) 个序列，每个序列包含四/三个元素 重复步骤2，直到所有元素排序完毕，即序列数为1def merge_sort(array) sub_size = 1 size = array.size while sub_size &amp;lt; size low = 0 while low &amp;lt; size - sub_size merge(array, low, low + sub_size - 1, [low + sub_size * 2 - 1, size - 1].min) low += sub_size * 2 end sub_size += sub_size end arrayend最坏时间复杂度：О(n log n)最优时间复杂度：О(n log n)平均时间复杂度：О(n log n)最坏空间复杂度：О(n)快速排序快速排序使用 分治法 （Divide and conquer）策略来把一个 序列 （list）分为较小和较大的2个子序列，然后递归地排序两个子序列。步骤为： 挑选基准值：从数列中挑出一个元素，称为“基准”（pivot）， 分割：重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（与基准值相等的数可以到任何一边）。在这个分割结束之后，对基准值的排序就已经完成， 递归排序子序列： 递归 地将小于基准值元素的子序列和大于基准值元素的子序列排序。递归到最底部的判断条件是数列的大小是零或一，此时该数列显然已经有序。 function quicksort(q) { var list less, pivotList, greater if length(q) ≤ 1 return q else { select a pivot value pivot from q for each x in q except the pivot element { if x &amp;lt; pivot then add x to less if x ≥ pivot then add x to greater } add pivot to pivotList return concatenate(quicksort(less), pivotList, quicksort(greater)) } }原地分割 （in-place）版本上面简单版本的缺点是，它需要 O(n) 的额外存储空间，也就跟 归并排序 一样不好。额外需要的 存储器 空间配置，在实际上的实现，也会极度影响速度和 缓存 的性能。有一个比较复杂使用 原地 （in-place）分割 算法 的版本，且在好的基准选择上，平均可以达到 O(log n) 空间的使用复杂度。function partition(a, left, right, pivotIndex){ pivotValue = a[pivotIndex] swap(a[pivotIndex], a[right]) // 把pivot移到結尾 storeIndex = left for I from left to right-1 { if a[I] &amp;lt; pivotValue { swap(a[storeIndex], a[I]) storeIndex = storeIndex + 1 } } swap(a[right], a[storeIndex]) // 把pivot移到它最後的地方 return storeIndex }这是原地分割算法，它分割了标示为”左边（left）”和”右边（right）”的序列部分，借由移动小于a[pivotIndex]的所有元素到子序列的开头，留下所有大于或等于的元素接在他们后面。在这个过程它也为基准元素找寻最后摆放的位置，也就是它回传的值。它暂时地把基准元素移到子序列的结尾，而不会被前述方式影响到。由于算法只使用交换，因此最后的数列与原先的数列拥有一样的元素。要注意的是，一个元素在到达它的最后位置前，可能会被交换很多次。 归并排序将数组分成两个子数组分别排序，并将有序的子数组归并以将整个数组排序。递归调用发生在处理整个数组之前。 快速排序将一个数组分成两个子数组并对这两个子数组独立地排序，两个子数组有序时整个数组也就有序了。递归调用发生在处理整个数组之后。归并排序与快速排序比较归并排序是由下到上，先处理子问题，然后再合并。快排则是由上到下，先分区，再处理子问题。归并排序虽然是稳定的排序算法，但是不是原地排序算法，需要 O(n) 的空间。快排则是原地，不稳定的算法。快排找第 K 大的数。Kth Largest Element in an Array - LeetCodeSort - LeetCode" }, { "title": "《数据结构与算法之美》笔记一", "url": "/posts/beauty-of-data-structures-and-algorithms-first/", "categories": "", "tags": "阅读笔记, Algorithm", "date": "2019-12-29 16:18:47 +0800", "snippet": "链表与 LRU 缓存淘汰算法数组与链表在内存分布上的不同之处，数组需要连续的内存空间，链表则不需要。数组与链表的性能比较：LeetCode 上也有对应的题目，146. LRU Cache 。LRU 算法在 iOS 上的应用YYCache 算是一例，通过双向链表结合 NSDictionary 使得增、删、改、查、清空的时间复杂度都是 O(1) 。具体实现代码在 YYMemoryCache.m 这个类里面。练习题：判断链表是否为回文链表Palindrome Linked List - LeetCode如何写出正确的链表代码重点留意边界情况。Linked List - LeetCode栈经典应用场景：函数调用栈。int main() { int a = 1; int ret = 0; int res = 0; ret = add(3, 5); res = a + ret; printf(&quot;%d&quot;, res); reuturn 0;}int add(int x, int y) { int sum = 0; sum = x + y; return sum;}还有表达式求值，括号匹配，浏览器的前进后退等。Stack - LeetCode队列使用循环队列来避免数据搬移。public class CircularQueue { // 数组：items，数组大小：n private String[] items; private int n = 0; // head表示队头下标，tail表示队尾下标 private int head = 0; private int tail = 0; // 申请一个大小为capacity的数组 public CircularQueue(int capacity) { items = new String[capacity]; n = capacity; } // 入队 public boolean enqueue(String item) { // 队列满了 if ((tail + 1) % n == head) return false; items[tail] = item; tail = (tail + 1) % n; return true; } // 出队 public String dequeue() { // 如果head == tail 表示队列为空 if (head == tail) return null; String ret = items[head]; head = (head + 1) % n; return ret; }}阻塞队列和并发队列阻塞队列其实就是在队列基础上增加了阻塞操作。简单来说，就是在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过“队列”这种数据结构来实现请求排队。Queue - LeetCode" }, { "title": "URL-loading-system", "url": "/posts/url-loading-system/", "categories": "", "tags": "iOS, 翻译", "date": "2019-11-30 16:24:54 +0800", "snippet": " 原文：[URL Loading System Apple Developer Documentation](https://developer.apple.com/documentation/foundation/url_loading_system) 通过标准的互联网协议来与 URL 交流和与服务器通讯。概览URL Loading System 可以获取通过 URL 来辨别的资源，使用如 https 的标准协议或者一些你创造的自定义协议。加载是异步执行的，所以你的应用可以继续响应操作和在返回数据或者错误时进行处理。你可以使用 URLSession 对象来创建一个或者多个 URLSessionTask 对象，URLSessionTask 可以抓取和返回数据，下载文件，或者上传数据和文件到服务器。你可以使用 URLSessionConfiguration 来配置会话（session），它可以控制像如何使用缓存和 cookies ，是否允许在蜂窝网络下进行连接等行为。你可以使用一个会话来重复创建任务（tasks）。举个例子，一个浏览器可以有不同的会话提供给标准模式和隐私模式使用，隐私模式的会话不缓存数据。下图表示了两个会话如何通过 configuration 来创建多个任务。每个会话都与一个 delegate 相关联，通过 delegate 来接收时而出现的更新（或者错误）。默认的 delegate 会调用你提供的 completion handler block，如果你选择提供自定义的 delegate，那么 block 就不会执行。你可以配置一个会话在后台运行，所以当你的 app 退到后台时，系统可以下载数据并唤醒 app 来接收数据。获取网络数据到内存中URL session 通过创建一个数据任务来获取数据到内存中。概览当与服务器进行一些较轻量的连接时，你可以使用 URLSessionDataTask 来获取数据到内存中（URLSessionDownloadTask 则是用来存取数据到文件系统中）。URLSessionDataTask 非常适用于调用 Web 服务。你可以使用一个 URLSession 对象来创建一个 任务 。如果你的需求很简单，你可以使用 shared 对象。如果你想通过 delegate 回调和传输进行交互，那么你需要创建一个 URLSession 对象，而不是使用 shared 对象。当创建 URLSession 时，你可以使用 URLSessionConfiguration 对象来进行配置，同时也可以给 URLSession 设置遵循了 URLSessionDelegate 协议或者它的子协议的类作为 delegate 。可以重复使用 URLSession 来创建多个 任务 ，因此对于所需的每个唯一配置，请创建一个 URLSession ，并将其存储为属性。 注意不要创建多余的 URLSession 。举个例子，如果你的 app 不同的部分需要一个相似配置的 URLSession ，创建一个 URLSession 并进行共享。当你已有一个 URLSession ，你可以通过一个 dataTask() 方法来创建一个数据任务。 任务被创建时是处于被挂起状态，可以通过调用 resume() 来启动任务。通过 Completion Handler 来接收结果获取数据最简单的方法是创建一个使用 completion handler 的数据任务。通过这种安排，任务将服务器的响应，数据以及可能的错误传递到你提供的 completion handler。下图显示了会话和任务之间的关系，以及如何将结果传递到 completion handler。通过调用 URLSession 的 dataTask(with:) 方法可以创建一个使用 completion handler 的数据任务。你的 completion handler 需要处理以下3件事： 验证错误参数是否为空。如果不是，则说明发生了传输错误，处理错误并退出。 检查响应参数以验证状态码是否为成功的状态码，且MIME类型是期望值。如果不是，处理服务器错误并退出。 根据需要使用数据对象以下代码展示了如何使用 startLoad() 方法来获取一个 URL 的内容。首先使用URLSession 的 shared 对象创建一个数据任务，将其结果传递给 completion handler 。在检查本地和服务器错误后，将数据转换为字符串，并使用 WKWebView 来进行加载。当然，你的应用程序可能还有其他用途来获取数据，例如将其解析为数据模型。func startLoad() { let url = URL(string: &quot;https://www.example.com/&quot;)! let task = URLSession.shared.dataTask(with: url) { data, response, error in if let error = error { self.handleClientError(error) return } guard let httpResponse = response as? HTTPURLResponse, (200...299).contains(httpResponse.statusCode) else { self.handleServerError(response) return } if let mimeType = httpResponse.mimeType, mimeType == &quot;text/html&quot;, let data = data, let string = String(data: data, encoding: .utf8) { DispatchQueue.main.async { self.webView.loadHTMLString(string, baseURL: url) } } } task.resume()} 重要completion handler 是在不同的 GCD 队列中调用。因此如果需要更新 UI ，则需要明确地指出是在主队列中调用。通过 delegate 来接收详细信息和结果为了在执行任务活动时获得更高级别的访问权限，在创建数据任务时，您可以在会话上设置 delegate ，而不是提供 completion handler 。下图展示了这种做法。通过这种方法，部分数据在到达时会调用 URLSessionDataDelegate 的urlSession(_:dataTask:didReceive:) 方法，直到传输完成或出现错误。随着任务的进行，delegate 还接收其他类型的事件。使用 delgate 模式时，您需要创建自己的 URLSession 对象，而不是使用 URLSession 的 shared 对象。创建一个新的会话允许你将自己的类设置为会话的 delegate ，如下面代码所示。private lazy var session: URLSession = { let configuration = URLSessionConfiguration.default configuration.waitsForConnectivity = true return URLSession(configuration: configuration, delegate: self, delegateQueue: nil)}()声明你的类实现了一个或多个委托协议（URLSessionDelegate ，URLSessionTaskDelegate ，URLSessionDataDelegate 和URLSessionDownloadDelegate ）。然后通过 init(configuration:delegate:delegateQueue:) 创建 URL 会话对象。你可以定制对应的配置对象。例如，将 waitsForConnectivity 设置为 true 是个好想法。这样，会话将等待适当的连接，而不是在所需的连接不可用时立即失败。下面代码展示了 startLoad() 方法是如何使用会话来启动数据任务，和使用 delegate 的回调方法来处理接收到的数据和错误。下面代码实现了三个 delegate 的回调方法： urlSession(_:dataTask:didReceive:completionHandler:) 验证响应是否具有成功的 HTTP 状态代码，且 MIME 类型为 text/html 或 text/plain。如果这两种情况都不是，则取消任务，否则可以继续进行任务。 urlSession(_:dataTask:didReceive:) 处理任务接收到的每个数据对象，并将其添加 receivedData 的缓冲区中。 urlSession(_:task:didCompleteWithError:) 首先查看是否发生了传输级的错误。如果没有错误，就尝试将 receivedData 缓冲区转换为字符串并设置为 webView 的内容。var receivedData: Data?func startLoad() { loadButton.isEnabled = false let url = URL(string: &quot;https://www.example.com/&quot;)! receivedData = Data() let task = session.dataTask(with: url) task.resume()}// delegate methodsfunc urlSession(_ session: URLSession, dataTask: URLSessionDataTask, didReceive response: URLResponse, completionHandler: @escaping (URLSession.ResponseDisposition) -&amp;gt; Void) { guard let response = response as? HTTPURLResponse, (200...299).contains(response.statusCode), let mimeType = response.mimeType, mimeType == &quot;text/html&quot; else { completionHandler(.cancel) return } completionHandler(.allow)}func urlSession(_ session: URLSession, dataTask: URLSessionDataTask, didReceive data: Data) { self.receivedData?.append(data)}func urlSession(_ session: URLSession, task: URLSessionTask, didCompleteWithError error: Error?) { DispatchQueue.main.async { self.loadButton.isEnabled = true if let error = error { handleClientError(error) } else if let receivedData = self.receivedData, let string = String(data: receivedData, encoding: .utf8) { self.webView.loadHTMLString(string, baseURL: task.currentRequest?.url) } }}各种 delegate 提供的方法除了上述代码中所示的方法之外，还用于处理身份验证挑战，重定向和其他特殊情况。在 URLSession 讨论中，使用 URL 会话描述了在传输过程中可能发生的各种回调。NSURLSession负责协调组织一组相关的网络数据传输任务NSURLSession 类和相关类提供了一个 API ，用于从 URL 指示的链接下载数据或将数据上传 。该 API 还可以使你的应用在后台或处于暂停状态时执行后台下载。丰富的 delegate 方法支持身份验证，并允许你的应用收到有关重定向等事件的通知。会话类型拥有相同会话的任务会分享一个共同的会话配置，配置定义了连接的行为，如最大连接数，是否允许使用蜂窝网络等。NSURLSession 有用于基本请求的单例 sharedSession （没有配置对象）。它不像你创建的会话那样可进行自定义，如果你的要求不多，可以尝试下使用它。也可以通过下面三种配置来进行初始化： default session ： 跟 sharedSession 非常相似，但是允许你设置更多配置，并且可以通过 delegate 来增量获取数据。 ephemeral session ：临时会话，跟 sharedSession 的不同之处在于它不会将缓存，cookie或者认证凭证存储到硬盘中。 Background session ：允许你在后台执行上传或者下载任务任务类型在会话中，你创建的任务可以有选择地将数据上传到服务器，然后可以选择将接收到的数据转为文件存放到硬盘中还是转为 NSData 对象存放到内存中。 NSURLSession API 提供三种类型的任务： data task ：使用 NSData 对象来接收和发送数据。通常用于执行一些数据较小的，可与服务器进行交互的请求 upload task ：跟 data task 类似，但是通常用于上传文件形式的数据，支持后台上传 Download task ：以文件形式下载数据，支持后台下载使用会话 delegate会话的任务会共享 delegate ，delegate 允许你在各种事件发生时（如认证失败，接收到来自服务的数据，数据准备好缓存等）进行处理和获取信息。如果你不需要设置 delegate ，可以在创建会话时传递 nil 参数。 重要会话对象会强引用 delegate ，直到你的 app 退出或者显式终止会话。所以如果你不显式中止会话，那么就会有内存泄露。会话和异步跟大多数网络 API 一样， NSURLSession也是高度异步的。它可以通过以下两种方式返回数据： 通过在传输成功完成或出现错误时调用 completion handler。 在接收数据和传输完成时调用会话 delegate 的方法。同时 NSURLSession API 还提供了状态和进度属性，你可以根据任务当前的状态来进行决策（状态随时有可能改变）。NSURLSession 同时还是支持取消，重启，恢复和挂起任务，并提供从被中断处恢复已被挂起，取消或者下载失败的任务。支持的协议NSURLSession 支持 data ， file ， ftp ， http ， 和 https 协议，并可以根据用户的系统偏好设置支持代理服务器和 socks 网关。NSURLSession支持 HTTP/1.1 和 HTTP/2 协议。如 RFC 7540 所述，HTTP/2 支持需要服务器支持应用程序层协议协商（ALPN）。还可以通过将 NSURLProtocol 子类化，添加对自己的自定义网络协议和 URL 方案的支持（应用私有）。App Transport Security (ATS)从 iOS 9.0 和 OS X 10.11 开始，默认情况下为使用 NSURLSession 建立的 HTTP 连接都启用 HTTPS (RFC 2818)。更多信息可以查看 Information Property List Key Reference 的 NSAppTransportSecurityNSCopying 相关行为会话和任务对象都遵循 NSCopying 协议： 当你复制一个会话或者任务对象时，你得到的是相同的对象 当你复制一个配置对象时，你得到的是一个新的可以独立修改的对象线程安全URLSession 的 API 都是线程安全的，你可以在不同的线程中创建会话和任务。当你的 delegate 调用对应的方法时，任务会自动安排在正确的 delegate 队列上。NSURLRequestNSURLRequest 封装了加载请求的两个必要属性：加载所需要的 URL 和加载策略。同时，URLRequest 还包括 HTTP 方法（GET ， POST 等）和 HTTP 头。最后，可以通过自定义属性来实现自定义协议。预留的 HTTP 头部属性URL Loading System 会为你处理 HTTP 协议各个方面的配置（HTTP 1.1 持久连接，代理，身份验证等）。作为这个支持的一部分，URL Loading System 会预留以下 HTTP 头部属性： Content-Length Authorization Connection Host Proxy-Authenticate Proxy-Authorization WWW-Authenticate如果你设置了其中一个的属性，系统可以会忽略掉你设置的值，或者重写它，或者只是不进行发送。此外，确切的行为可能会随着时间而改变。为避免此类问题，请勿直接设置这些头部属性。URL Loading System 会根据请求正文是否具有已知长度来判断是否需要设置 Content-Length ： 如果已经知道长度，它就会使用身份传输编码并将 Content-Length 设置为已知长度。你可以在设置请求正文为 data 对象时看到这种效果 如果不知道长度，则使用分块传输编码，并省略 Content-Length 。将请求正文设置为流时会看到这种效果。上传数据到网站很多 app 都与服务器一起工作并支持上传图片或者文档或者上传一些结构化的数据如 JSON 。你可以使用 NSURLSession 对象来创建 NSURLSessionUploadTask 对象。上传任务会使用 URLRequest 来展示如何执行上传任务。准备好需要上传的数据上传的数据可以是文件的一部分，流，data 。很多 Web 服务都支持 JSON 格式的数据，你可以使用 JSONEncoder 来 Encodable 如数组，字典类型。如下面代码所示，你可以声明一个遵循 Codable 协议的结构体，创建一个对象，然后使用 JSONEncoder 来将其编码成 JSON 数据。struct Order: Codable { let customerId: String let items: [String]}// ...let order = Order(customerId: &quot;12345&quot;, items: [&quot;Cheese pizza&quot;, &quot;Diet soda&quot;])guard let uploadData = try? JSONEncoder().encode(order) else { return}还有其他很多方式来创建数据对象，如将图片编码成 JPEG 或者 PNG 数据，或者将字符串编码成 UTF-8 数据。配置上传请求上传任务需要一个 URLRequest 对象，需要根据服务器的支持和要求将设置 httpMethod 为 POST 或 PUT 。使用 setValue(_:forHTTPHeaderField:) 方法可以设置 HTTP 头部任何属性，除了 Content-Length 。会话会根据你的数据大小自动计算出 Content-Length 。let url = URL(string: &quot;https://example.com/post&quot;)!var request = URLRequest(url: url)request.httpMethod = &quot;POST&quot;request.setValue(&quot;application/json&quot;, forHTTPHeaderField: &quot;Content-Type&quot;)创建和启动上传任务结合配置好的数据和请求，调用会话的 uploadTaskWithRequest:fromData:completionHandler: 方法来创建上传任务对象 NSURLSessionTask 。任务开始时是挂起状态，所以需要调用 resume 方法来启动任务。let task = URLSession.shared.uploadTask(with: request, from: uploadData) { data, response, error in if let error = error { print (&quot;error: \\(error)&quot;) return } guard let response = response as? HTTPURLResponse, (200...299).contains(response.statusCode) else { print (&quot;server error&quot;) return } if let mimeType = response.mimeType, mimeType == &quot;application/json&quot;, let data = data, let dataString = String(data: data, encoding: .utf8) { print (&quot;got data: \\(dataString)&quot;) }}task.resume()替代方案：设置 delegate可以通过给会话设置 delegate ，然后接入 NSURLSessionDelegate 和 NSURLSessionTaskDelegate 协议的方法来处理服务器返回的数据或者传输错误。上传流数据流媒体和长期运行的 app 使用持续流来上传数据，而不是发送单个数据或者文件。你可以配置一个 NSURLSessionUploadTask 对象（ NSURLSessionTask 子类）来与你提供的流进行工作，然后不定地填充流。任务通过会话的 delegate 来获取流，所以你需要创建会话和设置会话的 delegate 。创建会话创建会话时设置 delegate 和配置。lazy var session: URLSession = URLSession(configuration: .default, delegate: self, delegateQueue: .main)创建流上传任务调用 NSURLSession 的 uploadTaskWithStreamedRequest: 来创建流上传任务。let url = URL(string: &quot;http://127.0.0.1:12345&quot;)!var request = URLRequest(url: url, cachePolicy: .reloadIgnoringLocalCacheData, timeoutInterval: 10)request.httpMethod = &quot;POST&quot;let uploadTask = session.uploadTask(withStreamedRequest: request)uploadTask.resume()使用流的绑定对来提供输入流你可以使用 NSInputStream 来提供上传任务所需要的流数据。任务读取来自这个流的数据和上传到服务器。一个提供数据给输入流的方式是使用流的绑定对。绑定对包含了 NSOutputStream ，你可以输入数据到 NSOutputStream 中。由于绑定对的关系，你输入到 NSOutputStream 的数据可以在 NSInputStream 中获取。下面代码展示了一个持有 NSIntputStream 和 NSOutputStream 的结构体 Streams ，使用 getBoundStreamsWithBufferSize:inputStream:outputStream: 方法来配置 NSInputStream 和 NSOutputStream 。struct Streams { let input: InputStream let output: OutputStream}lazy var boundStreams: Streams = { var inputOrNil: InputStream? = nil var outputOrNil: OutputStream? = nil Stream.getBoundStreams(withBufferSize: 4096, inputStream: &amp;amp;inputOrNil, outputStream: &amp;amp;outputOrNil) guard let input = inputOrNil, let output = outputOrNil else { fatalError(&quot;On return of `getBoundStreams`, both `inputStream` and `outputStream` will contain non-nil streams.&quot;) } // configure and open output stream output.delegate = self output.schedule(in: .current, forMode: .default) output.open() return Streams(input: input, output: output)}()在创建绑定对时，确保在从输入流读取数据之前，需要指定足够大的缓存区大小，以容纳所有要写入输出流的数据。设置 NSOutputStream 对应的 delegate，可以指示接收输出流何时可以接收新数据。提供流给上传任务通过 NSURLSessionTaskDelegate 的 urlSession:task:needNewBodyStream: 方法可以提供流给上传任务：func urlSession(_ session: URLSession, task: URLSessionTask, needNewBodyStream completionHandler: @escaping (InputStream?) -&amp;gt; Void) { completionHandler(boundStreams.input)}当流准备好时写入数据当输出流准备好时写入数据到其中。当流准备就绪时，会调用 NSStreamDelegate 的方法 stream:handleEvent: ，当 eventCode 参数包含 NSStreamEventHasSpaceAvailable 时，表示流准备好接收更多数据。如果你未准备好写入数据，或者想在自己的周期内写入数据。可以自定义标志来判断是否写入到流中。当时处理流时，还需要坚持 eventCode 参数是否包含 NSStreamEventErrorOccurred ，这意味着流任务失败，需要关闭流和禁止上传。func stream(_ aStream: Stream, handle eventCode: Stream.Event) { guard aStream == boundStreams.output else { return } if eventCode.contains(.hasSpaceAvailable) { canWrite = true } if eventCode.contains(.errorOccurred) { // Close the streams and alert the user that the upload failed. }}当你处理 NSStreamEventHasSpaceAvailable 事件时，你可以在已经准备好接收更多数据时写入数据到流中。你可以通过调用 write:maxLength: 方法来写入数据，需要提供原始数据的引用和可以写入的最大字节数。下面代码使用了一个计时器来等待 canWrite 属性为 true 。如果 canWrite 为 true 那么就可以创建一个记录当前日期的字符串，并将其转化成原始字节。然后调用 write:maxLength: 方法写入到输出流中。因为输出流已经跟输入流绑定，所以上传任务会自动读取这些字节并发送到目标 URL 中。timer = Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) { [weak self] timer in guard let self = self else { return } if self.canWrite { let message = &quot;*** \\(Date())\\r\\n&quot; guard let messageData = message.data(using: .utf8) else { return } let messageCount = messageData.count let bytesWritten: Int = messageData.withUnsafeBytes() { (buffer: UnsafePointer&amp;lt;UInt8&amp;gt;) in self.canWrite = false return self.boundStreams.output.write(buffer, maxLength: messageCount) } if bytesWritten &amp;lt; messageCount { // Handle writing less data than expected. } }} 提示如果你的数据来自于一个异步处理的流程，例如一个媒体设备的回调，你还是需要等待输出流准备才可以进行写入。在这种情况下，你可以使用一个缓存区来存取你的数据。下载来自网站的文件一些以文件形式存储的网络资源，例如图片，文档，你可以使用下载任务来下载它们到本地的文件系统中。使用 Completion Handler 来创建简单的下载任务你可以使用 NSURLSession 创建 NSURLSessionDownloadTask 来下载文件。如果你在下载时不在乎下载进度或者其它 delegate 回调，你可以使用 completion handler 。不管是完成下载还是发生错误，下载完成时都会调用 completion handler 。Completion handler 有可能接收到错误，如无法连接网络。如果没有错误，你有可能接收到 NSURLResponse ，你需要检查它来确认接收到的是一个成功的来自服务器的响应。如果成功下载，你会接收到一个指示出已下载文件在本地文件系统位置的 URL 。它是临时的，如果你需要永久保存它，在 completion handler 返回前你需要复制或者移动它到其它位置。下面代码展示了如何使用通过 completion handler 来创建下载任务，以及如何验证错误，保存结果。let downloadTask = URLSession.shared.downloadTask(with: url) { urlOrNil, responseOrNil, errorOrNil in // check for and handle errors: // * errorOrNil should be nil // * responseOrNil should be an HTTPURLResponse with statusCode in 200..&amp;lt;299 guard let fileURL = urlOrNil else { return } do { let documentsURL = try FileManager.default.url(for: .documentDirectory, in: .userDomainMask, appropriateFor: nil, create: false) let savedURL = documentsURL.appendingPathComponent( fileUrl.lastPathComponent) try FileManager.default.moveItem(at: fileUrl, to: savedURL) } catch { print (&quot;file error: \\(error)&quot;) }}downloadTask.resume()使用 delegate 来接收进度更新使用 delegate 可以接收下载进度更新，你可以接入 NSURLSessionTaskDelegate 和 NSURLSessionDownloadDelegate 协议的方法。private lazy var urlSession = URLSession(configuration: .default, delegate: self, delegateQueue: nil)private func startDownload(url: URL) { let downloadTask = urlSession.downloadTask(with: url) downloadTask.resume() self.downloadTask = downloadTask}接收进度更新当下载开始执行后，你可以通过 URLSession:downloadTask:didWriteData:totalBytesWritten:totalBytesExpectedToWrite: 定期接收到进度更新。你可以通过字节计数来更新 app 中的进度 UI 。下面代码展示了如何计算下载进度，因为回调是在不确定的 GCD 队列中执行的，所以你需要明确指定在主队列中执行 UI 更新。func urlSession(_ session: URLSession, downloadTask: URLSessionDownloadTask, didWriteData bytesWritten: Int64, totalBytesWritten: Int64, totalBytesExpectedToWrite: Int64) { if downloadTask == self.downloadTask { let calculatedProgress = Float(totalBytesWritten) / Float(totalBytesExpectedToWrite) DispatchQueue.main.async { self.progressLabel.text = self.percentFormatter.string(from: NSNumber(value: calculatedProgress)) }} 提示如果你只是使用 UIProgressView 来更新进度 UI ，那么你可以将任务的 progress 属性设置给 UIProgressView 的 observedProgress 属性即可，不需要自己计算进度。在 delegate中处理下载错误在 URLSession:downloadTask:didFinishDownloadingToURL: 方法中需要进行判断文件是否存在，响应码是否正确，和对文件进行移动。func urlSession(_ session: URLSession, downloadTask: URLSessionDownloadTask, didFinishDownloadingTo location: URL) { // check for and handle errors: // * downloadTask.response should be an HTTPURLResponse with statusCode in 200..&amp;lt;299 do { let documentsURL = try FileManager.default.url(for: .documentDirectory, in: .userDomainMask, appropriateFor: nil, create: false) let savedURL = documentsURL.appendingPathComponent( location.lastPathComponent) try FileManager.default.moveItem(at: location, to: savedURL) } catch { // handle filesystem error }}如果有错误产生，就会调用 delegate 的 URLSession:task:didCompleteWithError: 方法。暂停和重启下载应用或者用户有时候可能需要取消正在进行的下载，然后再继续进行下载，通过支持断点续传下载，你可以节省用户的时间和流量。同样可以借助这个技术来恢复因失去连接而被中断的下载任务。取消下载时存储恢复时需要的数据你可以通过调用 NSURLSessionDownloadTask 的 cancelByProducingResumeData: 方法来取消任务，当完成取消时会调用 completion handler ，而 completion handler 会接收到一个 resumeData 参数。如果它不为空，它就是你恢复下载时所需要用的 token ，需要将它存储起来。downloadTask.cancel { resumeDataOrNil in guard let resumeData = resumeDataOrNil else { // download can&#39;t be resumed; remove from UI if necessary return } self.resumeData = resumeData}只有以下几种形式的任务可以恢复： 从你第一次请求起，资源没有做任何改动 任务是 HTTP 或者 HTTPS 的 GET 请求 服务器提供 ETag 或者 Last-Modified 在响应头重 服务器支持指定字节范围的请求 临时文件未被系统删除下载失败时存储恢复时需要的数据你还可以恢复由于暂时失去网络连接而失败的下载任务，如用户离开 WiFi 范围。当下载失败时，会话会调用 delegate 的 URLSession:task:didCompleteWithError: 方法，如果 error 不为空，那么就检查 userInfo 中 NSURLSessionDownloadTaskResumeData 字段是否有数据，如果有，就把对应的数据存储起来，用于恢复下载任务，如果没有，则表示下载任务是不可恢复的。func urlSession(_ session: URLSession, task: URLSessionTask, didCompleteWithError error: Error?) { guard let error = error else { // Handle success case. return } let userInfo = (error as NSError).userInfo if let resumeData = userInfo[NSURLSessionDownloadTaskResumeData] as? Data { self.resumeData = resumeData } // Perform any other error handling.}使用已保存的恢复用的数据来恢复下载任务当需要恢复下载任务时，使用 NSURLSession 的 downloadTaskWithResumeData:completionHandler: 或者 downloadTaskWithResumeData: 方法来创建一个新的 NSURLSessionDownloadTask ，同时需要使用之前存储的 resumeData 作为初始化参数。guard let resumeData = resumeData else { // inform the user the download can&#39;t be resumed return}let downloadTask = urlSession.downloadTask(withResumeData: resumeData)downloadTask.resume()self.downloadTask = downloadTask如果下载任务成功恢复，任务会调用 delegate 的 URLSession:downloadTask:didResumeAtOffset:expectedTotalBytes: 方法。你可以使用 offset 和 byte 计数参数来通知用户下载已经恢复，而且有保存之前的进度。在后台下载文件在你的 app 不活跃时创建任务来下载文件。对于那些需要较长时间和不紧急的传输任务，你可以使用 background 创建和运行。任务会在 app 被退到后台时运行，在 app 变为活跃时可以获取已下载的文件。创建后台会话为了执行后台下载，需要使用 background 操作来配置 NSURLSession 。 通过 NSURLSession 的类方法 backgroundSessionConfigurationWithIdentifier: 创建一个后台 NSURLSessionConfiguration 对象，会话 ID 在 app 里是唯一的。但是大多数 app 只需要很少的后台会话（通常只有一个），你可以把会话 ID 写死。 为了在任务完成时让系统唤醒你的 app，需要设置 sessionSendsLaunchEvents 为 true 。 对于一些不需要立即完成的任务，可以设置 discretionary 为 true ，这样系统可以等待到最佳状态来执行传输，如等到设备充电或者连接到 Wi-Fi 。 使用 NSURLSessionConfiguration 对象来创建 NSURLSession 对象。private lazy var urlSession: URLSession = { let config = URLSessionConfiguration.background(withIdentifier: &quot;MySession&quot;) config.isDiscretionary = true config.sessionSendsLaunchEvents = true return URLSession(configuration: config, delegate: self, delegateQueue: nil)}()创建和调用下载任务你可以通过 downloadTaskWithURL: 或者 downloadTaskWithRequest: 方法来创建下载任务。 使用 downloadTaskWithURL: 来创建下载任务。 也可以通过设置 earliestBeginDate 来在未来某个时间启动下载任务。设置了之后，下载任务并不是一定会在这个时间启动，只是不会早于这个时间。 为了使得系统的网络调度更有效率，可以设置 countOfBytesClientExpectsToSend 和 countOfBytesClientExpectsToReceive 属性。通过设置这些属性，可以设置请求的字节数的上限。 调用 resume 来启动任务。let backgroundTask = urlSession.downloadTask(with: url)backgroundTask.earliestBeginDate = Date().addingTimeInterval(60 * 60)backgroundTask.countOfBytesClientExpectsToSend = 200backgroundTask.countOfBytesClientExpectsToReceive = 500 * 1024backgroundTask.resume()处理 App 被暂停的情况App 不同的状态会影响 app 跟后台下载任务的交互。在 iOS ，app 有前台，挂起和被系统终止几种状态， Managing Your App’s Life Cycle 有更详细的介绍。当 app 在后台，下载是在另外一个进程执行时，系统可能会挂起 app 。下载完成后，系统恢复 app ，然后调用 UIApplicationDelegate 的 application:handleEventsForBackgroundURLSession:completionHandler: 方法。这个方法会传一个 completion handler 作为最后的参数。你需要把这个 handler 存储到 app 中。func application(_ application: UIApplication, handleEventsForBackgroundURLSession identifier: String, completionHandler: @escaping () -&amp;gt; Void) { backgroundCompletionHandler = completionHandler}当所有项目都完成传送，系统会调用 NSURLSessionDelegate 的 URLSessionDidFinishEventsForBackgroundURLSession: 方法，在这个例子中，我们需要调用之前存储的 backgroundCompletionHandler 。URLSessionDidFinishEventsForBackgroundURLSession: 有可能在子队列中调用，所以需要在主队列中调用：func urlSessionDidFinishEvents(forBackgroundURLSession session: URLSession) { DispatchQueue.main.async { guard let appDelegate = UIApplication.shared.delegate as? AppDelegate, let backgroundCompletionHandler = appDelegate.backgroundCompletionHandler else { return } backgroundCompletionHandler() }}获取文件，或者移动到永久的地址一旦你的 app 调用 completion handler ，下载任务就已经完成它的工作，然后调用 delegate 的 URLSession:downloadTask:didFinishDownloadingToURL: 方法。在这个例子中，文件是已经完全下载了，在你的 delegate 方法返回前都可以获取到。如果你只需要一次读取它，你可以直接通过临时地址直接获取文件。如果你想要保存文件，就需要把它移动到永久的地址。比如 Documents 目录，像 Downloading Files from Websites 描述那样。App 被杀死后重新创建任务如果系统在 app 被挂起时杀死 app ，系统会在后台重启 app 。作为你启动时步骤的一部分，使用相同的会话 ID 重新创建后台会话，这样使得系统可以通过你的任务来重新连接任务。不管 app 是通过用户还是系统登录都可以进行此操作。一旦 app 重新启动，这一系列的任务跟 app 被挂起然后恢复时一样，像之前讨论的处理 App 被暂停的情况类似。遵守后台的传输限制在后台会话中，实际的转移是通过与你 app 的流程不同的流程执行的。由于重新启动应用程序的流程相当昂贵，因此某些功能不可用，因此受到以下限制： 必须要提供 delegate 给会话来传递事件。 只支持 HTTP 和 HTTPS 协议（不支持自定义协议）。 始终遵循重定向。即使你引入 URLSession:task:willPerformHTTPRedirection:newRequest:completionHandler: 方法，也不会进行调用。 只支持文件的上传任务（data 对象的上传或者流会在 app 退出时失败）。高效地使用后台会话当系统恢复或者重新启动你的 app 时，它会使用速率限制器来防止滥用后台下载。当你的 app 在后台开启一个新的下载任务时，任务会等到延迟到期才开始。每当系统恢复或重新启动你的 app 时，延迟的时间都会增加。因此，如果你的 app 开始一次后台下载任务，然后在下载完成时恢复 app ，启动一个新的下载任务，它会大大增加延迟时间。一个有效的替代方案时是使用一小部分的后台会话（最好是一个），然后使用这些会话来一次性启动多个下载任务。这样使得系统可以一次执行多个下载任务，且在下载完成后恢复 app 。请记住每个任务都有它自己的开销。如果你发现你在启动时需要执行几千个下载任务，请考虑修改你的设计来执行次数更少，数据更大的传输。 当用户将你的 app 切换到前台时，延迟时间会被重置为 0 。如果延迟时间过去后系统仍没有恢复或者重启你的 app ，延迟时间也会被重置。获取缓存数据控制 URL 请求来如何使用缓存数据URL Loading System 缓存响应的数据到内存和硬盘中，借此来提升性能和减少网络传输时间。可以使用 NSURLCache 类来缓存网络响应的资源。你可以通过 URLCache 的 sharedURLCache 来获取缓存的单例，也可以创建自己需要的缓存，给你的 NSURLSessionConfiguration 对象设置特定的缓存。设置 URL 请求的缓存策略每个 URLRequest 都包含一个 URLRequest.CachePolicy 来指示如何执行缓存。你可以通过改变这个策略来控制请求的缓存。为了方便， NSURLSessionConfiguration 提供了一个 requestCachePolicy 属性，所有通过这个配置发起的请求都会继承这个请求策略。只缓存 HTTP 和 HTTPS 的响应数据。直接获取缓存你可以通过 URLSession 对象的 configuration 属性的 URLCache 属性来获取或者设置 URLSession 的缓存对象。通过 cachedResponseForRequest: 方法可以查找 Request 对应的缓存。如果有对应的缓存数据，就会返回 NSCachedURLResponse ，否则返回 nil 。你可以通过缓存来查询资源的占用情况。 currentDiskUsage 和 diskCapacity 表示缓存使用的文件系统资源，而 currentMemoryUsage 和 memoryCapacity 则表示了内存占用。你可以通过 removeCachedResponseForRequest: 方法来移除特定的缓存，也可以通过 removeCachedResponsesSinceDate: 来移除指定日期之后的缓存，也可以使用 removeAllCachedResponses 方法来移除所有缓存。通过代码管理缓存你可以通过调用 storeCachedResponse:forRequest: 方法，提供 CachedURLResponse和 URLRequest 对象来直接写入缓存中。通常情况下，你可以在 URLSessionTask 对象处理响应时管理响应的缓存。为了在每个响应的基础上管理缓存，需要实现 NSURLSessionDataDelegate 协议的 URLSession:dataTask:willCacheResponse:completionHandler: 方法。这个方法只在上传和数据任务时调用，后台会话和临时配置不会调用。这个方法提供了两个参数，CachedURLResponse 对象和 completion handler ，你必须在方法中直接调用 completion handler ： 可以直接使用提供的 CachedURLResponse 对象进行缓存； nil ，不进行缓存； 重新创建一个 CachedURLResponse 对象，结合提供的 CachedURLResponse 对象，同时也可以指定 storagePolicy 和 userInfofunc urlSession(_ session: URLSession, dataTask: URLSessionDataTask, willCacheResponse proposedResponse: CachedURLResponse, completionHandler: @escaping (CachedURLResponse?) -&amp;gt; Void) { if proposedResponse.response.url?.scheme == “https” { let updatedResponse = CachedURLResponse(response: proposedResponse.response, data: proposedResponse.data, userInfo: proposedResponse.userInfo, storagePolicy: .allowedInMemoryOnly) completionHandler(updatedResponse) } else { completionHandler(proposedResponse) }}处理身份认证当服务器对某个 URL 请求需要进行身份证验证时，做出适当的响应。当你的 app 通过 NSURLSessionTask 发起请求时，服务器可能会在继续前以一个或者多个的验证要求进行响应。会话任务会尝试处理。如果处理不了，则会调用会话的 delegate 来进行处理。为了处理服务器发起的验证请求，你需要实现本文中描述的 delegate 方法。如果你未实现 delegate 对应的方法，那么服务器可能会拒绝你的请求，并且你收到的响应将带有 401 HTTP 状态码（禁止），而不是你期望的数据。确定适当的 delegate 方法接入 delegate 两个或者其中一个验证方法，取决于你接收到的验证要求的性质。 接入 NSURLSessionDelegate 的 URLSession:didReceiveChallenge:completionHandler: 的方法来处理会话层级的验证要求。它跟 TLS 验证类似。一旦你成功处理这些验证要求，就会影响到所有通过这个会话 NSURLSession 创建的任务 接入 NSURLSessionTaskDelegate URLSession:task:didReceiveChallenge:completionHandler: 的方法来处理任务特定的验证要求。这些要求跟输入用户名/密码验证类似。每个会话都有可能需要进行验证请求。 NSURLProtectionSpace Authentication Method Constants 中有说明用于会话或者任务认证的方法。作为一个简单的例子，想象一下当你请求一个受到 HTTP 的基础认证保护的 URL 请求时（像 RFC 7617 定义的那样）。因为它是任务层级的认证挑战，所以你需要引入 URLSession:task:didReceiveChallenge:completionHandler: 方法来进行处理。 如果你使用 HTTPS 进行连接，你还会接受到服务器信任的挑战。 Performing Manual Server Trust Authentication 有提供更多信息来处理这种会话层级的挑战判断认证挑战的类型当你接收到一个认证挑战，使用你的 delegate 方法来判断挑战的类型。delegate 方法会接收一个 NSURLAuthenticationChallenge 对象。它描述了正在使用的认证挑战。它包含一个 protectionSpace 属性，而 protectionSpace 属性又包含一个 authenticationMethod 属性来指明认证挑战的类型（如一个需要用户名和密码的请求，或者客户端证书）。你可以使用这个值来判断你是否可以处理这个认证挑战。你可以通过调用传递过来的 completion handler 来响应认证挑战。你需要传递一个 NSURLSessionAuthChallengeDisposition 参数来表示你如何处理这个认证挑战的。你可以使用这个 disposition 参数来提供证书，取消请求或者进行默认的处理方式。 下面代码展示了如何根据 authMethod 来处理认证挑战，如果是 NSURLAuthenticationMethodHTTPBasic ，就使用默认的处理方法。let authMethod = challenge.protectionSpace.authenticationMethodguard authMethod == NSURLAuthenticationMethodHTTPBasic else { completionHandler(.performDefaultHandling, nil) return}创建证书对象为了成功响应认证挑战，你需要根据认证挑战的类型来提交一个合适的证书。对于 HTTP 基础和 HTTP 摘要的认证挑战，你需要提供用户名和密码。下面代码展示了一个辅助类如何生成一个由用户输入的 NSURLCredential 对象。func credentialsFromUI() -&amp;gt; URLCredential? { guard let username = usernameField.text, !username.isEmpty, let password = passwordField.text, !password.isEmpty else { return nil } return URLCredential(user: username, password: password, persistence: .forSession)}在这个例子中，返回的 NSURLCredential 包含 NSURLCredentialPersistenceForSession 的持久化属性，所以它只存储在 NSURLSession 对象中，由这个对象创建的任务也包含对应的 URLCredential 。调用 Completion handler一旦你创建了证书对象，你需要调用 completion handler 来响应挑战。 如果你无法创建证书，或者用户明确地取消了，调用 completion handler 和传递 NSURLSessionAuthChallengeCancelAuthenticationChallenge 参数。 如果你创建了证书对象，调用 completion handler 和传递 NSURLSessionAuthChallengeUseCredential 参数。guard let credential = credentialOrNil else { completionHandler(.cancelAuthenticationChallenge, nil) return}completionHandler(.useCredential, credential)如果你创建的证书被服务器接受，任务就会开始上传和下载数据。优雅地处理错误当服务器拒绝你的证书时，系统会再次调用你的 delegate 方法。NSURLAuthenticationChallenge 的 proposedCredential 属性即所提供的证书，同时 previousFailureCount 表示证书请求失败的次数。你可以根据这些属性来判断下一步怎么处理。" }, { "title": "Xcode 11 与 iOS 13 适配", "url": "/posts/xcode-11-adapts-to-ios-13/", "categories": "", "tags": "iOS, Xcode", "date": "2019-10-13 20:00:41 +0800", "snippet": "启动白屏在 iOS 13 以下的版本中，如果你在 App 中替换了 window.rootViewController 那么会有一个 UITransitionView 的界面遗留在 window 上无法释放，苹果并不推荐我们在 App 运行时替换 window.rootViewController 。但是有时业务确实需要我们怎么做，比如只有登录后可以使用 App ，我们可以在登录后替换 window.rootViewController 。但是到了 iOS 13 情况变得不一样了，iOS 13 可能调整了流程，如果移除了 UITransitionView 应用就会白屏，所以需要调整下代码逻辑，添加判断是否为 iOS 13。func setRootViewController(_ newRootViewController: UIViewController, withTransition transition: CATransition? = nil) { rootViewController?.dismiss(animated: false, completion: { [weak self] in self?.rootViewController?.view.removeFromSuperview() }) if let transition = transition { layer.add(transition, forKey: kCATransition) } rootViewController = newRootViewController if UIView.areAnimationsEnabled { UIView.animate(withDuration: CATransaction.animationDuration()) { newRootViewController.setNeedsStatusBarAppearanceUpdate() } } else { newRootViewController.setNeedsStatusBarAppearanceUpdate() } if #available(iOS 13.0, *) { } else { if let transitionViewClass = NSClassFromString(&quot;UITransitionView&quot;) { for subview in subviews where subview.isKind(of: transitionViewClass) { subview.removeFromSuperview() } } } }}UIModalPresentationStyle在 iOS 13 上，使用 presentViewController 弹出 ViewController 时，默认样式如下：大部分情况下我们需要的还是原来的样式，需要将 viewController 的 modalPresentationStyle 改为 overFullScreen ，但是一个个手动去改，工作量也比较大，此时就需要用到 method swizzle 了，Referencing the Objective-C selector of property getters and setters 这份提案有说到 Swift 是支持获取 getter 和 setter 对应的 selector ，然后我们需要替换 modalPresentationStyle 的默认值，改为 overFullScreen ，这样可以在需要的时候设置为 autoMatic 。首先，需要在 UIViewController 的 extension 中新增 swizzledModalPresentationStyle 属性，默认值为 .overFullScreen ：// MARK: - ModalPresentationStyleprivate var modalPresentationStyleKey: UInt8 = 0extension UIViewController { var swizzledModalPresentationStyle: UIModalPresentationStyle { set { objc_setAssociatedObject(self, &amp;amp;modalPresentationStyleKey, newValue, .OBJC_ASSOCIATION_RETAIN_NONATOMIC) } get { if let presentationStyle = (objc_getAssociatedObject(self, &amp;amp;modalPresentationStyleKey)) as? UIModalPresentationStyle { return presentationStyle } else { return .overFullScreen } } }}然后再对 modalPresentationStyle 的 setter 和 getter 方法进行 swizzle：private static var hasSwizzled = falsestatic func swizzleMethods() { guard !hasSwizzled else { return } hasSwizzled = true [ (#selector(self.viewDidLoad), #selector(cbViewDidLoad)), (#selector(self.viewDidAppear(_:)), #selector(cbViewDidAppear(_:))), (#selector(self.viewWillAppear(_:)), #selector(cbViewWillAppear(_:))), (#selector(getter: self.preferredStatusBarStyle), #selector(getter: cbPreferredStatusBarStyle)), (#selector(getter: self.modalPresentationStyle), #selector(getter: swizzledModalPresentationStyle)), (#selector(setter: self.modalPresentationStyle), #selector(setter: swizzledModalPresentationStyle)) ].forEach { (original, swizzled) in guard let originalMethod = class_getInstanceMethod(self, original), let swizzledMethod = class_getInstanceMethod(self, swizzled) else { return } if class_addMethod(self, original, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)) { class_replaceMethod(self, swizzled, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)) } else { method_exchangeImplementations(originalMethod, swizzledMethod) } }}Cocoapods 与 Xcode New Build System如果你有至少一个 Pods 包含 Assets.xcassets ，那么在打包的时候就会生成重复的图片到 App 的根路径下的 Assets.car 中，在使用 Xcode 11 build 时，那么就会报错，显示你有 duplicate output file 。如果你的 Pods 包含 Assets.xcassets ，那么应该在 Input File 列表中，具体讨论可以看这里 Xcode 10 new build system makes asset catalog invalid specified by podspec’sresource(s) ，里面也有说到具体的解决方案。" }, { "title": "slow-motion-video", "url": "/posts/slow-motion-video/", "categories": "", "tags": "iOS", "date": "2019-09-08 19:21:37 +0800", "snippet": "起因有用户反馈上传慢动作视频后，视频为正常状态的视频，而不是慢动作视频，在视频列表界面中显示的视频时间长度也不正确。打开系统相处进行查看时，显示的视频时间长度也是正常状态的视频时间长度，而不是慢动作状态下的视频时间长度，但是打开播放后就是慢动作视频。系统提供了编辑慢动作视频的功能，可以选择慢动作区域，由此可以推测出，系统存取在相册中的是正常状态下的视频，在播放时在通过视频的对应信息来控制播放的速度。那么如何导出正确的视频资源和显示正确的视频时间呢？播放对应的视频和显示正确的时间播放对应的视频无论播放的视频是什么类型，都是通过 PHAsset 获取到对应的 AVAsset ，然后通过 AVAsset 进行播放。在通过 PHAsset 获取 AVAsset 时，是通过以下方法来获取：let imageManager = PHCachingImageManager()let requestOptions = PHVideoRequestOptions()requestOptions.version = .originalimageManager.requestAVAsset(forVideo: asset, options: requestOptions, resultHandler: { (asset, audioMix, info) in})PHVideoRequestOptions 有个 version 的属性，可用于设置获取到的 AVAsset 对应的资源是哪个，再结合相册里面的是正常的视频，可以得出如果设置 version 为 original ，获取的 AVAsset 对应的是正常的视频资源。version 还可以设置 current ，再设置为 current 后，使用 AVPlayer 播放的就是慢动作的视频了。显示正确的时间PHAsset 有个 duration 属性，一般情况下使用 PHAsset 的 duration 既可，系统相册估计也是直接使用 duration 来表示时间。但是，在遇到慢动作视频的时候，duration 显示的则是正常状态的视频时间长度，那么如何获取慢动作视频时间长度呢？我们从上面的代码已经可以获取到慢动作视频对应的 AVAsset ，直接使用 AVAsset 的 duration 属性，再转化为秒，就是慢动作视频的时间长度了：let seconds = lround(CMTimeGetSeconds(avAsset.duration))但是普通的视频是可以直接使用 PHAsset 的 duration ，大多数视频也都是正常视频，是否可以通过 PHAsset 判断是否为慢动作视频，从而选择不同的方式来获取视频时间。其实慢动作视频也是通过普通视频以慢动作方式播放出来，其本质还是普通视频，只是帧率比较高。而 PHAsset 有个 mediaSubtypes 属性，它是 PHAssetMediaSubtype 类型，而 PHAssetMediaSubtype 则有 videoHighFrameRate 这个选项，说明如下： High-frame-rate videos are created by the Slow-Mo feature in the Camera app on an iOS device.可见 PHAsset 如果对应的是慢动作视频，那么它的 mediaSubtype 就会包含 videoHighFrameRate ，所以可以得出判断方式：extension PHAsset { var isSlowMotionVideo: Bool { return mediaSubtypes.contains(PHAssetMediaSubtype.videoHighFrameRate) }}如何导出慢动作视频有文章说到慢动作视频获取到的 AVAsset 为 AVComposition ，我在 iOS 13.1 和 iOS 12.4.1 上获取的都是 AVURLAsset 类，或许其它版本获取到的是 AVComposition 类，无论获取到的是 AVURLAsset 还是 AVComposition 类，我们在编辑视频时都以 video tracks 的最后一条 track 为依据即可。参考文章Optimizing for Slow Motion Video in iOS" }, { "title": "现有工程逐步使用 RxSwift 和 MVVM", "url": "/posts/migrate-to-rxswift-and-mvvm/", "categories": "", "tags": "iOS, RxSwift, MVVM", "date": "2019-09-03 22:32:44 +0800", "snippet": "现状目前项目采用的是 MVC 结构，UIViewController 包含大量代码，包括网络请求，数据处理，布局代码等，难于测试（虽然也不写测试）。随着项目发展，这部分内容会越来越多，越来越复杂，导致 UIViewController 中的代码越来越难维护。为了项目的可持续发展，决定开始开始使用 RxSwift 和 MVVM 。ViewModelViewModel 扮演的是处理业务逻辑的角色，负责处理数据和为 ViewController 提供数据源。一般来说有几下几点要求： 可测试的，这样可以直接为 ViewModel 编写单元测试。 不知道 ViewController 或者 View 的存在，只负责自己处理数据。 团队编写 ViewModel 时需要严格按照现有规范来编写。 配合 RxSwift 食用更佳如何将 ViewModel 与数据源绑定一般来说 ViewModel 与数据源绑定，指的是如何将用户的操作，网络状态绑定到 ViewModel 上，再将 ViewModel 的数据源绑定到 UI 上。第一种绑定方式— protocol 与转换首先定义一个 ViewModelType 协议，协议中包含 Input，Output 和一个将 Input 转换为 Output 的方法。RxSwift + MVVM: how to feed ViewModels 的 First approach — without Subjects 和 CleanArchitectureRxSwift/ViewModelType.swift at 55c852bbd7b4e5f9ee30426e2acdb7b038e848be · sergdort/CleanArchitectureRxSwift · GitHub 都是采用了这种写法。这种写法，一看之下非常好用，也很干净，没有用到 Subject ，所有的处理都经由 transform 方法完成，但是有些情况下并不适用，可以看到转换的机会只有一次，你必须在一开始就获取到所有 input 的数据源，通过 transform 方法将 input 转化为 output 。How to feed ViewModels 这篇文章里面也有提到，有些时候我们并不能一次过获取到所有的数据源，不同的数据源需要分开获取，这就需要使用第二种绑定方式。第二种绑定方式 — 将 Input 和 Output 抽出来在某些情况下，可能需要分开获取不同的数据源，这时候就需要借用 Subject ，但是我们可以不将 Subject 暴露出来。具体写法参考：RxSwift + MVVM: how to feed ViewModels 的 Second approach — with Subjects 。Subject 属性是私有的，它为 input 提供了绑定来源，结构体 Input 有多少个属性就需要提供多少个 Subject 。同时 Subject 也可以作为 output 的数据来源，它是 input 和 output 两者之间的数据桥梁。KickStarter 也是通过类似的方法将 Subject 隐藏起来，只不过 KickStarter 使用的是 ReactiveCocoa ，而且是通过方法来进行更新 Property(Subject)，而不是通过 Struct 来进行转换。 在 vm-structure.md 中有提到所有 inputs 都提供对应的 MutableProperty （Property 相当于 RxSwift 的 Subject ），然后在 inputs 函数中更新对应的 Property 。是否使用 Subject在任何情况下，ViewModel 在处理数据时都是单向流动的，即 Input 接受数据输入，Output 输出处理后的数据，上面两种写法都满足这个要求。但是如果 Output 里包含了 Subject ，ViewController 就可以通过调用 Ouput 相关 Subject 的 onNext 方法来达到输出数据的目的，这样数据流动就没有经过 ViewModel 进行处理了，这显然违背了 ViewModel 的设计原则，所以如果要使用 Subject ，那对应的属性则应该是私有的。Cell，View 等控件是否有需要添加 ViewModel如果 Cell，View 等 UI 控件的逻辑比较简单，可以先不添加 ViewModel ，对于比较复杂的 Cell 和 View 等 UI 控件，可以考虑添加 ViewModel 。Network 层与 JSON 转换现有项目使用的 Moya 来组织网络层，使用 ObjectMapper 来进行 JSON 和 Model 层的转换。由于要将不同类别的接口分到不同的 enum 类中，创建一个 MultiMoyaProdider 类，可执行 TargetType 的请求。class MultiMoyaProvider: MoyaProvider&amp;lt;MultiTarget&amp;gt; { typealias Target = MultiTarget init() { let plugins: [PluginType] #if DEBUG plugins = [NetworkLoggerPlugin(verbose: true)] #else plugins = [] #endif let endpointClosure = { (target: Target) -&amp;gt; Endpoint in let endpoint: Endpoint = Endpoint(url: target.baseURL.absoluteString + target.path, sampleResponseClosure: { .networkResponse(200, target.sampleData)}, method: target.method, task: target.task, httpHeaderFields: target.headers) return endpoint } super.init(endpointClosure: endpointClosure, plugins: plugins) } @discardableResult func multiRequest&amp;lt;T: TargetType&amp;gt;(_ target: T, completion: @escaping Completion) -&amp;gt; Cancellable { return request(MultiTarget(target), completion: completion) }}有了 MultiMoyaProvider 后可以进行 Rx 化的改造，Moya 本身就提供了对于 RxSwift 的支持：Moya/RxSwift.md at master · Moya/Moya · GitHub。通过 MultiMoyaProvider ，可以提供三种方法来返回 Observable。typealias JSONDictionary = [String: Any]// 1. 直接返回 Observable&amp;lt;JSONDictionary&amp;gt;func jsonObservable(target: TargetType) -&amp;gt; Observable&amp;lt;JSONDictionary&amp;gt; { return Observable.create { observer in return provider.rx.request(MultiTarget(target)) .subscribe(onSuccess: { (response) in // 验证 response 格式 if let error = valid(response) { observer.onError(error) return } guard let dictionary = try? response.mapJSON() as? JSONDictionary else { observer.onError(MoyaError.jsonMapping(response)) return } observer.onNext(dictionary) }, onError: { (error) in observer.onError(error) }) }}// 2. 返回单个 Model 类型func objectObservable&amp;lt;T: Mappable&amp;gt;(target: TargetType, objectType: T.Type) -&amp;gt; Observable&amp;lt;T&amp;gt; { return Observable.create { observer in return provider.rx.request(MultiTarget(target)) .subscribe(onSuccess: { (response) in if let error = valid(response) { observer.onError(error) return } guard let object = try? response.mapObject(objectType.self) else { observer.onError(MoyaError.jsonMapping(response)) return } observer.onNext(object) }, onError: { (error) in observer.onError(error) }) } }// 3. 返回 Model 数组func objectArrayObservable&amp;lt;T: Mappable&amp;gt;(target: TargetType, objectType: T.Type) -&amp;gt; Observable&amp;lt;[T]&amp;gt; { return Observable.create { observer in return provider.rx.request(MultiTarget(target)) .subscribe(onSuccess: { (response) in if let error = valid(response) { observer.onError(error) return } guard let objectArray = try? response.mapArray(objectType.self) else { observer.onError(MoyaError.jsonMapping(response)) return } observer.onNext(objectArray) }, onError: { (error) in observer.onError(error) }) } }为了方便 Response 与 Model 间的转换，给 Response 新增两个方法：extension Response { /// Maps data received from the signal into an object which implements the Mappable protocol. /// If the conversion fails, the signal errors. func mapObject&amp;lt;T: BaseMappable&amp;gt;(_ type: T.Type, context: MapContext? = nil) throws -&amp;gt; T { guard let object = Mapper&amp;lt;T&amp;gt;(context: context).map(JSONObject: try mapJSON()) else { throw MoyaError.jsonMapping(self) } return object } /// Maps data received from the signal into an array of objects which implement the Mappable /// protocol. /// If the conversion fails, the signal errors. func mapArray&amp;lt;T: BaseMappable&amp;gt;(_ type: T.Type, context: MapContext? = nil) throws -&amp;gt; [T] { guard let array = try mapJSON() as? [[String: Any]] else { throw MoyaError.jsonMapping(self) } return Mapper&amp;lt;T&amp;gt;(context: context).mapArray(JSONArray: array) }}然后在 ViewModel 具体的 input 中通过 flatMap 来调用网络请求： input.flatMap { jsonObservable... } .subscribe ...相关资源 http://community.rxswift.org/ https://github.com/kickstarter/native-docs/blob/master/vm-structure.md native-docs/inputs-outputs.md at master · kickstarter/native-docs · GitHubKickStarter 重度使用 MVVM 和 ViewModel ，上文阐述了他们关于 ViewModel 的设计理念。 RxSwift 中文文档 · RxSwift 中文文档 http://davesexton.com/blog/post/To-Use-Subject-Or-Not-To-Use-Subject.aspx RxSwift + MVVM: how to feed ViewModels GitHub - sergdort/CleanArchitectureRxSwift: Example of Clean Architecture of iOS app using RxSwift 是时候学习 RxSwift 了 - Limboy’s HQ" }, { "title": "回字的几种写法 - Pull To Dismiss", "url": "/posts/Pull-To-Dismiss/", "categories": "", "tags": "iOS", "date": "2019-07-13 20:59:48 +0800", "snippet": "有些 App 在弹出评论列表，或者其它界面时，是从底部弹出的，且下拉对应的 ScrollView 也可以触发 dismiss 的动画，不需要去点击按钮，在交互上来说也是连续的。在实现这个需求的过程，我发现这个需求有几种写法，这几种写法都需要先给对应的 ViewController 添加 UIPanGestureRecognizer 手势，只是对手势的处理方法不同，添加手势的方法如下： let panGestureRecognizer = UIPanGestureRecognizer(target: self, action: #selector(handleDismissPanGesture(_:))) view.addGestureRecognizer(panGestureRecognizer)下面说说这几种写法的具体实现。（文中的 UITableView 可以替换成 UICollectionView 或者 UIScrollView）不继承 UITableView不继承 UITableView 有两种写法，由手势是否连续进行区分。连续的手势操作这种写法不把 UITableView 的滑动手势和自己添加的手势分隔开来，在 UITableView 滑动到顶部时，如果再接着滑动，就会触发 ViewController 的消失动画。首先给手势设置 delegate 和对应的 delegate 方法，使它可以接受其它手势，从而不影响 UITableView 的滑动：func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldRecognizeSimultaneouslyWith otherGestureRecognizer: UIGestureRecognizer) -&amp;gt; Bool { return true}接着，需要防止在 dismiss 过程中 UITableView 滑动：func scrollViewDidScroll(_ scrollView: UIScrollView) { /// 防止在 dismiss 过程中 tableView 滑动 if scrollView.contentOffset.y &amp;lt; 0 { scrollView.setContentOffset(.zero, animated: false) } else if let currentTableViewOffset = currentTableViewOffset { scrollView.setContentOffset(currentTableViewOffset, animated: false) }}接下来对自己添加的手势进行处理：@objc private func handleDismissPanGesture(_ gestureRecognizer: UIPanGestureRecognizer) { let velocity = gestureRecognizer.velocity(in: gestureRecognizer.view) let translation = gestureRecognizer.translation(in: gestureRecognizer.view) if velocity.y &amp;gt; 0 &amp;amp;&amp;amp; tableView.contentOffset.y &amp;lt;= -tableView.contentInset.top { if needToResetTranslation { /// 开始进行 dismiss ，且需要对 translation 进行复原，防止位置错乱 dismiss(animated: true) needToResetTranslation = false gestureRecognizer.setTranslation(.zero, in: gestureRecognizer.view) currentTableViewOffset = tableView.contentOffset } } /// 如果已回滚到顶部，且在 dismiss 过程中，则复位 needToResetTranslation 和 currentTableViewOffset if translation.y &amp;lt; 0 &amp;amp;&amp;amp; !needToResetTranslation { needToResetTranslation = true currentTableViewOffset = nil } /// 如果是在 dismiss 过程中，则进行 dismiss 的交互动画 if !needToResetTranslation { interactiveDismissTransition?.didPan(with: gestureRecognizer) } /// 如果手势结束，则复位 needToResetTranslation if gestureRecognizer.state != .began &amp;amp;&amp;amp; gestureRecognizer.state != .changed { needToResetTranslation = true currentTableViewOffset = nil }}优点： 用户对 TableView 的滑动手势跟触发 dismiss 的手势是连续的，滚动到顶部时，再往上滑动即可触发 dismiss 的效果。 不需要继承 UITableView缺点： 需要处理的边界情况较多 用户在滑动到顶部时容易误触发 dismiss 的效果不连续的手势操作在添加手势后，需要设置在手势生效时，不触发 UITableView 的 panGestureRecognizer ：tableView.panGestureRecognizer.require(toFail: panGestureRecognizer)然后在手势是否开始设置条件，只有是上下滚动且 UITableView 已滚动到顶部时才开始：func gestureRecognizerShouldBegin(_ gestureRecognizer: UIGestureRecognizer) -&amp;gt; Bool { guard let panGestureRecognizer = gestureRecognizer as? UIPanGestureRecognizer else { return false } let translation = panGestureRecognizer.translation(in: view) let velocityPoint = panGestureRecognizer.velocity(in: view) let isVerticalDrag = abs(velocityPoint.y) &amp;gt; abs(velocityPoint.x) if translation.y &amp;gt; 0 &amp;amp;&amp;amp; tableView.contentOffset.y &amp;lt;= -tableView.contentInset.top { return true } return !isVerticalDrag}这种情况下手势的处理则比较简单了：@objc private func handleDismissPanGesture(_ gesture: UIPanGestureRecognizer) { switch gesture.state { case .began: dismiss(animated: true) default: break } interactiveDismissTransition?.didPan(with: gesture)}优点： 不需要继承 UITableView ； 不需要处理较多的边界情况缺点： 用户对 UITableView 的滑动手势跟触发 dismiss 的手势不是连续的，滚动到顶部时，需要松开后然后再次向上滑动；继承 UITableView继承 UITableView 的写法比较简单，不需要对自己添加的手势进行处理，唯一的缺点就是需要继承对应的类。比如如果需要对 UITableView 进行处理，首先需要继承自 UITableView ，然后在子类中对 UITableView 的手势进行处理：class TableView: UITableView { override func gestureRecognizerShouldBegin(_ gestureRecognizer: UIGestureRecognizer) -&amp;gt; Bool { /// 在手势开始时判断是否需要开始滑动 if gestureRecognizer.state == .possible { let translation = panGestureRecognizer.translation(in: self) if translation.y &amp;gt; 0 &amp;amp;&amp;amp; contentOffset.y &amp;lt;= -contentInset.top { return false } } return true }}总结上面几种写法各有各的优点，可以根据具体的业务需求或者框架限制选择不同的写法。Demo 也放到了 github 上，PullToDismiss" }, { "title": "PhotoKit-使用", "url": "/posts/photoKit-usage/", "categories": "", "tags": "iOS", "date": "2019-06-09 22:37:23 +0800", "snippet": "相机胶卷一般情况下我们都希望自定义相册界面时获取到的数据跟系统的相机胶卷数据是一致的。PHAsset 中 有个 fetchAssets(with:options:) 的方法，可以获取到手机中全部的 PHAsset ，但是排序不对，而且系统的相机胶卷其实也是一个相册，所以还是要获取到对应的 PHAssetCollection 。 PHAssetCollection 中有 ` fetchAssetCollections(with:subtype:options:) 方法来获取相册。需要指定 PHAssetCollectionType 和 PHAssetCollectionSubtype 。先看第一个 PHAssetCollectionType ` 参数，分为 album ，smartAlbum 和 moment 。相机胶卷在系统中属于智能相册，所以选择 smartAlbum 。再看第二个 PHAssetCollectionSubtype 参数，这里需要结合[官方文档]([PHAssetCollectionSubtype - Photos Apple Developer Documentation](https://developer.apple.com/documentation/photokit/phassetcollectionsubtype))来选择，从里面发现一个 smartAlbumUserLibrary 类型，它的描述如下： A smart album that groups all assets that originate in the user’s own library (as opposed to assets from iCloud Shared Albums).包含了所有 assets ，这个参数获取到的就是相机胶卷相册。调用如下：PHAssetCollection.fetchAssetCollections(with: .smartAlbum, subtype: .smartAlbumUserLibrary, options: nil)相册的标题如果没有在 项目的 Info -&amp;gt; Localizations 中添加 Chinese 选项，则获取到的相册标题还是英文的。在 UICollectionView 中显示缩略图在 UICollectionView 中显示缩略图的时候也需要考虑缩略图在本机中是不存在的，要从 iCloud 上下载下来，这样就需要设置 PHImageRequestOptions 的 isNetworkAccessAllowed 为 true 。相册中的 GIF需要获取到相册中的 GIF 并显示出来也是有讲究的，下面代码环境为 iOS 13 beta 。如何判断是否为 GIF 通过 KeyValue 形式访问 uniformTypeIdentifier 属性，再判断是否等于 kUTTypeGIF 。extension PHAsset { var isGIF: Bool { if let imageType = value(forKey: &quot;uniformTypeIdentifier&quot;) as? String, imageType == kUTTypeGIF as String { return true } return false }} 获取 PHAsset 对应的 PHAssetResource ，通过 uniformTypeIdentifier 或者 originalFilename 来判断是否为 GIF 。通过 originalFilename 的文件后缀判断，文件后缀判断一个不好的地方是有 GIF 也有 gif ，可能是因为 iOS 13 beta 版的关系。extension PHAsset { var isGIF: Bool { guard let filename = PHAssetResource.assetResources(for: self).first?.originalFilename, filename(&quot;GIF&quot;) || filename(&quot;gif&quot;) else { return false } return true }}通过 uniformTypeIdentifier 判断。extension PHAsset { var isGIF: Bool { guard let assetResources = PHAssetResource.assetResources(for: self).first, assetResources.uniformTypeIdentifier == kUTTypeGIF as String else { return false } return true }} 通过获取 PHAsset 的元数据来判断，但是由于 requestImageData(for:options:resultHandler:) 获取的是整张原图的数据，消耗较大，不建议使用这个方法来判断是否为 GIF 。let requestOptions = PHImageRequestOptions()requestOptions.version = .originalPHImageManager.default().requestImageData(for: asset, options: requestOptions) { (data, type, _, _) in guard let type = type, type == kUTTypeGIF as String else { return } // This is GIF print(&quot;This is GIF&quot;)}性能测试：在 iOS 13 beta 1 ，iPhone 8P 上进行 2000 次判断是否为 GIF ，得到的时间消耗如下（单位为 s ）： KeyValue 获取对应的属性进行比较 0.010032176971435547 PHAssetResource 的 originalFilename 的后缀判断 3.440941095352173 PHAssetResource 的 uniformTypeIdentifier 判断 3.4876623153686523可以看到 PHAssetResource 的方法均消耗较大，所以采用第一种方法来判断是否为 GIF 。如何显示 GIFGIF 跟普通的照片不同，我们需要获取的是 GIF 的原始 data ，再由原始 data 生成 UIImage 。在获取 data 时需要注意 GIF 有可能编辑过，如果有编辑过，则需要指定 PHImageRequestOptions 的 version 为 .original ，否则获取到有可能不是 GIF 的 data ，而是普通照片的 data 。" }, { "title": "PhotoKit-概览", "url": "/posts/photokit-overview/", "categories": "", "tags": "iOS", "date": "2019-04-23 14:07:23 +0800", "snippet": "iOS 8 开始提供，分为 Photos 和 Photos UI 两部分。作用： 从用户照片库中获取照片和视频资源，相册 添加，删除和修改资源或相册 编辑照片或者视频的内容或者元数据PhotoKit 对象模型PHObject ，PhotoKit 中的基类，PHAsset ，PHAssetCollection ，PHCollectionList 和 PHObjectPlaceholder 都继承于它，只包含 localIdentifier 这个属性，用于判断是否相等和进行 hash 。PHAsset，PhotoKit 中表示图片或者视频资源的模型，包含了媒体的元数据，如 isFavorite ，location ，pixelWidth 和 pixelHeight 等。通过 PHAsset 可以获取对应的图片或者视频。PHCollection ，PHAssetCollection 和 PHCollectionList 继承的父类。PHAssetCollection ，PHAsset 的集合，可以是相册，时刻或者智能相册。PHCollectionList ，PHCollection 的集合，例如照片库中的时刻列表，年份列表或者用户创建的相册。获取资源获取对应资源的方法都由对应的类的类方法提供，它们都是以 fetchXXX 形式命名。PhotoKit 提供了一个 PHFetchOptions 类给我们设置提取时的排序和过滤方式。基本上完整的流程如下：首先生成 PHFetchOptions 对象（也可以不设置），对应的 options 参数设为 nil ，然后通过 PHAsset 的 fetch 方法获取所有资源或者单独视频类型：let options = PHFetchOptions() allPhotosOptions.sortDescriptors = [NSSortDescriptor(key: &quot;creationDate&quot;, ascending: true)]let medias = PHAsset.fetchAssets(with: options)let videos = PHAsset.fetchAssets(with: .video, options: nil)也可以获取相册 PHAssetCollection 或者 PHCollectionList 的 fetch 方法先获取 PHAssetCollection ，然后通过 PHAsset 的 fetch 方法获取对应的 assets：let smartAlbums = PHAssetCollection.fetchAssetCollections(with: .smartAlbum, subtype: .albumRegular, options: nil)let userCollections = PHCollectionList.fetchTopLevelUserCollections(with: nil)let assets = PHAsset.fetchAssets(in: collection, options: nil)这些获取方法都是同步的，但是官方文档中有说明 PHFetchResult 对象会从照片库中动态加载需要资源，即使处理大量的数据时也可以提供良好的性能。 Unlike an NSArray object, however, a PHFetchResult object dynamically loads its contents from the Photos library as needed, providing optimal performance even when handling a large number of results.Transient CollectionsPhotoKit 提供了一些方法让我们可以创建临时的资源集合，但是它们不会存储到用户照片库，它只会保存在当前的运行时中。可以用于搜索结果，用户选择图片，获取内容，复用 View Controller 等。获取照片或者视频不同于获取资源时的同步方法，这里的方法大部分都是异步的，因为它们有可能是存在 iCloud ，需要下载至本地，有可能是极大的图片，处理需要一定的时间。PhotoKit 提供了 PHImageManager 类来获取照片或者视频。PHImageManager 针对照片和视频提供了不同的获取方法： 获取照片 func requestImage(for: PHAsset, targetSize: CGSize, contentMode: PHImageContentMode, options: PHImageRequestOptions?, resultHandler: (UIImage?, [AnyHashable : Any]?) -&amp;gt; Void) -&amp;gt; PHImageRequestID直接获取 UIImage ，提供了 targetSize 和 contentMode 参数，targetSize 指明请求获取到的照片大小，如果我们用一个 CollectionView 来展示图片，就需要根据 cellSize 来指定图片的大小，以免图片过大造成卡顿和占用内存过多。contentMode (PHImageContentMode) 的用法跟 UIView 的 contentMode 类似，指定图片是按比例缩放还是按比例填充至 targetSize 。func requestImageData(for: PHAsset, options: PHImageRequestOptions?, resultHandler: (Data?, String?, UIImage.Orientation, [AnyHashable : Any]?) -&amp;gt; Void) -&amp;gt; PHImageRequestID获取图片的 Data ，无法指定目标 Data 的图片来源的大小。resultHandler 中的第二个属性表示 Data 的格式，在 iOS 12 上有可能是 public.jpeg ，public.png ， public.heic 或者com.compuserve.gif。PHImageRequestOptions 对象决定了怎么获取图像，它有这些属性： deliveryMode ：PHImageRequestOptionsDeliveryMode ，分以下几种模式： .opportunistic ，图片管理器会提供多次的结果来平衡图片质量和响应速度，也就是说有可能多次调用 resultHandler ，在准备好高质量的图片以前先返回一个较低质量的图片给你用于展示。 .highQualityFormat ，只返回高质量的图片。 .fastFormat ，如果高质量的图片无法快速加载，resultHandler 则提供低质量的图片，可以通过检查 info dictionary 中的 PHImageResultIsDegradedKey 值来判断图片的质量。 resizeMode : PHImageRequestOptionsResizeMode ，图片管理器如何设置图像大小： none ：不重新设置图像大小 .fast ：比 .exact 效率更高，但是有可能跟 targetSize 大小不一样 .exact ：返回图像必须和目标大小相匹配 normalizedCropRect ：裁剪图片的部分区域，如果需要进行裁剪，resizeMode 必须为 .exact 模式。 `` 如果 isSynchronous 设为 true ，则 deliveryMode 不起作用。iCloud 相关属性： isNetworkAccessAllowed ：Bool ，如果图片没有存储在本地，且 isNetworkAccessAllowed 为 true ，图片管理器则从 iCloud 中下载。如果 isNetworkAccessAllowed 为 false ，则 image 为 nil ，且可以通过 info dictionary 中 PHImageResultIsInCloudKey 值来判断是否存储于 iCloud 中。 progressHandler ：`(Double, Error?, UnsafeMutablePointer, [AnyHashable : Any]?) -&amp;gt; Void progress ：表示下载进度，从 0.0 到 1.0 error ：当下载图片出错时 error 有值，否则为 nil stop ：如果需要取消下载，则在 block 里进行设置 *stop info ：提供这次图片请求的额外信息 获取视频func requestPlayerItem(forVideo: PHAsset, options: PHVideoRequestOptions?, resultHandler: (AVPlayerItem?, [AnyHashable : Any]?) -&amp;gt; Void) -&amp;gt; PHImageRequestID获取视频对应的 AVPlayerItem 对象，用于播放视频，异步加载。func requestExportSession(forVideo: PHAsset,options: PHVideoRequestOptions?,exportPreset: String,resultHandler: (AVAssetExportSession?, [AnyHashable : Any]?) -&amp;gt; Void) -&amp;gt; PHImageRequestID获取视频对应的 AVAssetExportSession 对象，用于将视频数据保存到文件中，exportPreset 表示视频质量。func requestAVAsset(forVideo: PHAsset,options: PHVideoRequestOptions?,resultHandler: (AVAsset?, AVAudioMix?, [AnyHashable : Any]?) -&amp;gt; Void) -&amp;gt; PHImageRequestID返回视频对应的 AVFoundation 的相关对象。PHVideoRequestOptions 的用法跟 PHImageRequestOptions 类似。 iOS 9.1 后，新增了获取 Live Photo 的方法：func requestLivePhoto(for: PHAsset, targetSize: CGSize, contentMode: PHImageContentMode, options: PHLivePhotoRequestOptions?, resultHandler: (PHLivePhoto?, [AnyHashable : Any]?) -&amp;gt; Void) -&amp;gt; PHImageRequestIDLive Photo 是一张图片，会捕获拍照前后的声音和动作。就像 UIImage 对象如何表示图像的即用形式一样，Live Photo 对象也准备好了声音，图片和动作用于表示 Live Photo 。显示 Live Photo 需要用到 PHLivePhotoView 。也可以使用 requestImage(for:targetSize:contentMode:options:resultHandler:) 方法来直接获取 PHLivePhoto 的图片。滑动性能当在 Collection View 上展示照片时，可以使用 PHImageCachingManager 来预先加载一些图像和将一些图像从缓存中移除。滚动式预先加载有可能显示的 PHAssets ：func startCachingImages(for: [PHAsset], targetSize: CGSize, contentMode: PHImageContentMode, options: PHImageRequestOptions?)退出当前显示范围的 PHAssets 则停止缓存：func stopCachingImages(for: [PHAsset],targetSize: CGSize,contentMode: PHImageContentMode,options: PHImageRequestOptions?)也可以停止所有缓存：func stopCachingImagesForAllAssets()PHImageCachingManager 有个 allowsCachingHighQualityImages 属性，默认为 true ，用于是否缓存高质量图片。我在 iPhone 8P ，iOS 12 上测试了下，是否使用 startCaching 和 stopCaching 对滚动流畅性影响不大。PHCachingImageManger 应该有自己一套管理 PHAsset 相关内存的办法，因为我观察到在滑动停止后，内存会逐渐下降至一个稳定值。观察相册变化在打开用户照片相关界面后，用户有可能切换至其它 app ，并对相册进行修改，对此，我们需要监听相册变化变化的通知，作出对应的处理。PHPhotoLibrary.shared().register(self)然后在遵循 PHPhotoLibraryChangeObserver 协议，在相册变化时会调用 photoLibraryDidChange 方法，我们需要在里面对相册内容进行处理，注意：photoLibraryDidChange 有可能是在后台线程中调用，所以需要手动切换为主线程。extension Class: PHPhotoLibraryChangeObserver { func photoLibraryDidChange(_ changeInstance: PHChange) { }}PHChange 提供了两个方法用于获取变化的数据：func changeDetails&amp;lt;T&amp;gt;(for object: T) -&amp;gt; PHObjectChangeDetails&amp;lt;T&amp;gt;? where T : PHObjectfunc changeDetails&amp;lt;T&amp;gt;(for fetchResult: PHFetchResult&amp;lt;T&amp;gt;) -&amp;gt; PHFetchResultChangeDetails&amp;lt;T&amp;gt;? where T : PHObject这里用到了泛型。第一个方法可用于获取 PHAsset 对象相关的变化。第二个方法可用于获取 PHFetchResult 的变化，主要应用于 UICollectionView/UITableView ，PHFetchResultChangeDetails 提供了 removedIndexes ， insertedIndexes ， changedIndexes 和 enumerateMoves 用于配合 UICollectionView/UITableView 的相关刷新方法。参考 https://objccn.io/issue-21-4/#Photo-metadata PHImageManager - NSHipster https://developer.apple.com/videos/play/wwdc2014/511/" }, { "title": "Texture-Layout", "url": "/posts/texture-layout/", "categories": "", "tags": "iOS, Texture, 翻译", "date": "2019-03-03 00:28:40 +0800", "snippet": "原文链接：Layout原因和收益Auto Layout 在处理复杂的 View 时，消耗会指数级上升，Texture 布局在以下几方面比 Auto Layout 好： 快，明显比 Auto Layout 快，基本上跟手动布局差不多 异步和并发，布局可以在后台线程进行计算，所以不会打断用户交互 声明式布局，不可变的数据结构，这使得布局代码易于开发，编写文档，code review ，测试，debug ，描述和维护 可缓存，得益于不可变的数据结构，布局可以在后台预先计算和缓存起来 可扩展的，代码易于复用受到 CSS Flexbox 的启发这两个系统有非常多相似的属性。也有不同的地方，Texture | Web Flexbox Differences基本概念Texture 的布局以以下两个基本概念为中心： Layout Specs Layout ElementsLayout SpecsLayout Spec 不包含具体的控价，它相当于一个定义了 Layout Elements 的子 Layout Elements 如何布局的容器。 [Texture Layout Specs](http://texturegroup.org/docs/layout2-layoutspec-types.html) Layout ElementsLayout Spec 包含和排列 Layout Elements 。ASDisplayNode 和 ASLayoutSpec 都遵循了 协议，这意味着你可以使用 `ASDisplayNode` 和 `ASLayoutSpec ` 来组成 `ASLayoutSpec ` 。某些 Node 需要设置 size一些 Node 可以根据它们可直接获取的内容自动设置 intrinsic size ： ASImageNode ASTextNode ASbuttonNode一些 Node 不具有 intrinsic size ，或者说需要等到外部资源加载完成后才有 intrinsic size ，这些 Node 在初始化时需要设置大小： ASVideoNode ASVideoPlayerNode ASNetworkImageNode ASEditableTextNodeLayout Debuggingdebug 时调用 ASDisplayNode 或者 ASLayoutSpec 的 -asciiArtString 方法可以打印出 ascii 码形式的布局信息：-----------------------ASStackLayoutSpec----------------------| -----ASStackLayoutSpec----- -----ASStackLayoutSpec----- || | ASImageNode | | ASImageNode | || | ASImageNode | | ASImageNode | || --------------------------- --------------------------- |--------------------------------------------------------------也可以打印 ASLayoutElement 的 style 属性：(lldb) po _photoImageNode.styleLayout Size = min {414pt, 414pt} &amp;lt;= preferred {20%, 50%} &amp;lt;= max {414pt, 414pt}Layout API 大小调整值(CGFloat, ASDimension)ASDimension 本质上是 CGFloat ，支持表示百分比，字符串，符点值。// dimension returned is relative (%)**ASDimensionMake(&quot;50%&quot;)ASDimensionMakeWithFraction(0.5)// dimension returned in points**ASDimensionMake(&quot;70pt&quot;)ASDimensionMake(70)ASDimensionMakeWithPoints(70)Sizes(CGSize, ASLayoutSize)ASLayoutSize 跟 CGSize 类似，但是它的宽高可以用浮点值或者百分比来表示，宽高的类型是相互独立的。// Dimension type &quot;Auto&quot; indicates that the layout element may // be resolved in whatever way makes most sense given the circumstanceslet width = ASDimensionMake(.auto, 0)let height = ASDimensionMake(&quot;50%&quot;) layoutElement.style.preferredLayoutSize = ASLayoutSizeMake(width, height)layoutElement.style.preferredSize = CGSize(width: 30, height: 60)Size Range(ASSizeRange)UIKit 没有提供一种包含最大 CGSize 和最小 CGSize 的数据结构，为此创建了 ASSizeRange 类型。Layout Transition APILayout Transition API 为了 Texture 更易地制造动画效果而设计的。整个过程中，用户只需要定义目标 Layout ，Texture 会自动分辨出它跟当前 Layout 的不同之处。会自动添加新的元素，移除不需要的元素，和更新其它存在的元素的位置。 如果要使用 Layout Transition API ，则必须要用 [Texture Automatic Subnode Management](http://texturegroup.org/docs/automatic-subnode-mgmt.html) Animating between Layouts我们可以在 layoutSpecThatFits: 中通过不同的状态进行不同的布局，然后通过 transitionLayoutWithAnimation: 开始转换。调用 transitionLayoutWithAnimation: 后，它会调用 transitionLayoutWithAnimation: 方法，我们可以在这个方法里面调用动画。override func animateLayoutTransition(_ context: ASContextTransitioning) { if fieldState == .signupNodeName { let initialNameFrame = context.initialFrame(for: ageField) nameField.frame = initialNameFrame nameField.alpha = 0 var finalAgeFrame = context.finalFrame(for: nameField) finalAgeFrame.origin.x -= finalAgeFrame.size.width UIView.animate(withDuration: 0.4, animations: { self.nameField.frame = context.finalFrame(for: self.nameField) self.nameField.alpha = 1 self.ageField.frame = finalAgeFrame self.ageField.alpha = 0 }, completion: { finished in context.completeTransition(finished) }) } else { var initialAgeFrame = context.initialFrame(for: nameField) initialAgeFrame.origin.x += initialAgeFrame.size.width ageField.frame = initialAgeFrame ageField.alpha = 0 var finalNameFrame = context.finalFrame(for: ageField) finalNameFrame.origin.x -= finalNameFrame.size.width UIView.animate(withDuration: 0.4, animations: { self.ageField.frame = context.finalFrame(for: self.ageField) self.ageField.alpha = 1 self.nameField.frame = finalNameFrame self.nameField.alpha = 0 }, completion: { finished in context.completeTransition(finished) }) }}context 参数提供了转换前后的信息，包括新旧的 constrained size ，插入和移除的 nodes ，新旧的 ASLayout 对象。Animating constrainedSize Changes当 node 的 bounds 发生变化时，可以调用 transitionLayoutWithSizeRange:animated: 方法。" }, { "title": "Texture-基本概念", "url": "/posts/texture-basic-concepts/", "categories": "", "tags": "iOS, Texture, 翻译", "date": "2019-02-19 11:44:10 +0800", "snippet": "原文：Core ConceptsTexture 基本单位为 node ， ASDisplayNode 是建立在 UIView 上的抽象层，如同 UIView 与 CALayer 的关系。ASDiplayNode 是线程安全的，你可以在后台线程进行初始化和配置。NodesNode 的用法跟 UIView 类似，且 Node 提供了 UIView 和 CALayer 属性。Texture 提供了丰富的 Node 子类 ，用于取代 UIKit 组建。 ASDipslayNode -&amp;gt; UIView ASCellNode -&amp;gt; UITableViewCell/UICollectionViewCell ASScrollNode -&amp;gt; UIScrollView ASEditableTextNode -&amp;gt; UITextView ASTextNode, ASTextNode2 -&amp;gt; UILabel ASImageNode, ASNetworkImageNode, ASMultiplexImageNode -&amp;gt; UIImageView ASVideoNode -&amp;gt; AVPlayerLayer ASVideoPlayerNode -&amp;gt; UIMoviePlayer ASControlNode -&amp;gt; UIControl ASButtonNode -&amp;gt; UIButton ASMapNode -&amp;gt; MKMapViewNode Containers推荐使用 Node Container 来包含 Nodes，Texture 提供以下 Node Containers： ASCollectionNode -&amp;gt; UICollectionView ASPagerNode -&amp;gt; UIPageViewController ASTableNode -&amp;gt; UITableView ASViewController -&amp;gt; UIViewController ASNavigationController -&amp;gt; UINavigationController ASTabBarController -&amp;gt; UITabBarControllerNode Containers 好处都有啥？智能预加载。这意味所有 Node 相关的布局计算，数据获取，解码和渲染都可以异步完成。SubclassingASDisplayNode -initASDisplayNode 的 -init 方法可以在后台线程中调用，所以不要在该方法中获取或者初始化任何 UIKit 的相关对象，例如 添加手势。 -didLoad该方法跟 UIViewController -viewDidLoad 方法类似，当后台 View 加载完成时就会调用，且只会在主线程中调用，用于进行与 UIKit 相关的操作 -layoutSpecThatFits:用于生成 ASLayoutSpec 对象，在后台线程中运行，而 ASLayoutSpec 则包含了 Node 的大小 以及所有 subnodes 的位置及大小。除非你明确知道你正在做什么，否则不要在该方法中创建 Node -layout-layout 与 UIViewController -viewWillLayoutSubviews 类似。可以设置 view 的一些不需要进行布局的基础属性。如果在 Node 使用了 UIView，则可以在该方法中设置 frame 。该方法在主线程中调用，但是如果你正在使用 ASLayoutSpec ，则不应该太过依赖该方法。一个很好的用法是你想要设置 subnode 为确切的 size ，则可以在 -layout 中直接设置。 subnode.frame = self.bounds; ASViewController -init该方法中不要过早访问 self.view 或者 self.node.view ，这会强制 view 提早生成。ASViewController 的指定初始化方法是 -initWithNode: -loadView不建议使用该方法 -viewDidLoad用法与 UIViewController 的类似 -viewWillLayoutSubviews用于进行布局计算。 智能预加载Node 的能力是异步并行地进行渲染和计算，与此同样要的是智能预加载Node 对于它们当前的界面状态都有标志来说明。interfaceState 属性由创建和维护 containers 的 ASRangeController 负责更新。Interface State Ranges当 scrollView 滚动时，scrollView 中的 node 就会更新至对应状态 Preload: 距离屏幕较远，准备所需要的数据 Display：即将进入屏幕，文字渲染，图片解码渲染等 Visible：至少有 1 像素进入屏幕ASRangeTuningParameterstypedef struct { CGFloat leadingBufferScreenfuls; CGFloat trailingBufferScreenfuls;} ASRangeTuningParameters;ASRangeTuningParameters 定义了各个区域大小，一般来说即将进入的区域比离开的区域要大一些Interface State Callbacks通过以下可以在相关的状态中进行不同的操作： Visible Range : -didEnterVisibleState-didExitVisibleState Display Range -didEnterDisplayState-didExitDisplayState Preload Range -didEnterPreloadState-didExitPreloadState FAQTexture | FAQ" }, { "title": "2018", "url": "/posts/2018/", "categories": "", "tags": "summary", "date": "2019-02-10 21:03:10 +0800", "snippet": "工作小程序带来的变化18年上半年公司重点放在小程序上，也因为小程序本身的特性：更新快，无遗留版本的包袱），导致整个开发节奏特别快，当时小程序一般两三天发一个版本，就导致 iOS 这边也必须加快开发节奏，当时也是一直在加班。而且小程序那边有两个开发人员，iOS 这边就我一个，整体感觉就是一个人在干着两个人的活。虽然小程序获客成本比较低，基本上微信用户点一下就成了我们的用户了，但是这样拉过来的用户质量比较低，一般随便看一下就不会再打开了，这也是小程序普遍都是做工具，不是做社区的原因。后来公司也意识到这个问题，逐渐也转移重心到开发原生应用上。大环境的变化上半年一直在找投资，6月份的时候投资人还过来公司这边参考了一下。同时公司的体量也在逐渐扩大，招了不少人，其中还招了一个 iOS 应届生进来，我也开始尝试带人。7月份的时候整个环境开始突变，原来有意向的投资人也不投资了。公司也裁了不少人，那段时间我刚好去台湾旅游，回来发现走了差不多一半的人，招的应届生也走了，想想挺对不起他的，办公室都冷清了不少。为了活下去，公司开始尝试转换方向，尝试自己养活自己。整个业务分为两个方向，一个是 To B ，由北京的同事负责，接一些车企的广告，一个是 To C ，是我们自己的线上商城，由广州这边的同事负责，主要是卖一些我们自己设计的产品或者跟其它品牌合作的产品。从 App 日活开始提升后，这两个业务的走向都非常不错，目前来说还可以养活自己App 的变化iOS App 这一年基本就我一个人负责，老大偶尔会过来帮忙写一下代码。App 基本上还是在使用 Texture 这个框架，但是这个框架有个比较严重的问题，就是 TableNode/CollectionNode 的 CellNode 没有复用，如果加载 CellNode 过多时，会导致 OOM ，今年计划优化一下。App 的日活从年初的不到 1k 到年底 5k，稳步增长，社区也逐渐活跃，有用户在社区上提问题，我也会上去回答。回想以前第一次突破 1k 时我还跟老大说了一下，感觉都过去好久了。App 的体量上来以后，写的代码也更加需要认真考虑边界情况。跟以前不同，以前是自己写好，测试一下没什么问题就可以上了。现在要上功能我都预留多几天出来测试，尽量先发 TestFligth 版本给同事们先测试。生活的变化18 年女朋友毕业了，我们两个也住在了一起。她在佛山上班，于是在广州租了一个靠近佛山的房子。这样导致的一个问题就是我通勤时间差不多要一个半小时，不过地铁上可以看书，也就还好。10 月份的时候开始交房贷，压力一下上来了，不过还好是女朋友负责管钱，这里要感谢一下她。如无意外的话，今年就可以入住，也不用交两份租了，省点钱去日本旅游。学习年初的时候说过要学习一门新的语言，也没有实现，主要问题是没想到什么要尝试的。由于通勤时间的变长，开始在地铁上阅读一些文章，也订阅了不少 RSS ，后面记录当月阅读的文章，方便以后自己查阅。iOS 技术栈上也有不少成长，但是都是跟业务相关的。自己也开发了一个应用，但是反映不是很好，比较悲观，希望今年能再开发出一个应用来。阅读《程序员的职业素养》《晚清之后是民国》《沸腾十五年》《我是猫》《杜洛兹的虚荣》读的比较杂，也比较少，今年应该能读不少书。总结今年即将进入毕业的第五个年头，自己的感觉是技术成长的太慢了，时间都不够用，希望今年在技术方面有更多的成长。完。" }, { "title": "2018-11-ReadingList", "url": "/posts/2018-11-ReadingList/", "categories": "", "tags": "阅读笔记", "date": "2018-12-05 23:19:27 +0800", "snippet": "A Better MVC, Part 1: The Problems | Dave DeLong问题： 违反封装，充斥着大量面条代码 Massview View Controller解决办法：开发者为了解决上面两个问题通常会使用其它架构方式。但是会增加团队成员的学习成本。系统更新时也有可能需要更多时间来进行适配，同样地，如果你依赖了其它第三库，还需要等得第三库的更新。A Better MVC, Part 2: Fixing Encapsulation | Dave DeLong对 View Controller 进行解耦，View Controller 不需要知道其它 View Controller ，做法是生成一个更高层 View Controller，这个 View Controller 不包含其它逻辑，只负责对 View Controller 的跳转进行处理。所有子 View Controller 都通过它来进行跳转。A Better MVC, Part 3: Fixing Massive View Controller | Dave DeLong1 View Controller ≠ 1 screen of content开始写 app 时，我们都会使用一个 View Controller 来表示一个屏幕的内容，但是当 app 变得复杂时，我们可以将某些比较复杂的界面分成多个小的 View Controller。A Better MVC, Part 4: Future Directions | Dave DeLong承接上面所说的 1 View Controller ≠ 1 screen of content，单个 cell 也可以使用单个 ViewController 来管理，将 cell 中的逻辑分离出来。总结： 使用 View Controllers 来分解 UI 使用 View Controllers 来管理列表控件 View Controllers 不一定要填充屏幕A Better MVC, Part 5: An Evolution | Dave DeLong作者在五个月后又写了一篇关于 MVC 的文章。MVC 不是一种设计模式，是一种思想，它追求封装，将不同的东西分隔开来。View Controller 其实不是 Controller，而是 View，它负责的其实是 View 相关的逻辑。View Controller 应该只负责处理业务逻辑或者传递数据给它包含的 UIViews，不应该两者都包含。UIViewControllers 应该只负责下面的其中一个部分： 组合 Child View Controller 给自己拥有的 UIViews 填充数据 So instead of saying a UIViewController should “manage either sequence or UI”, perhaps a better way of saying it would be that a UIViewController should either compose children or put stuff in to UIViews (with the understanding that this is a guideline, and not a rule). https://www.avanderlee.com/optimization/measure-performance-code/检测代码性能: Xcode unit test，playground 和 terminal，playground 因为涉及到 UI 的更新，所以检测到的代码执行时间会其它两个大，其它两个的结果比较接近。Result&amp;lt;T&amp;gt; 还是 Result&amp;lt;T, E: Error&amp;gt;Result&amp;lt;T, E: Error&amp;gt; 和 Result&amp;lt;T&amp;gt; 的比较。 因为 Swift 并没有提供使用协议类型作为泛型中特化的具体类型的支持，这导致在 API 的强类型严谨性和灵活性上无法取得两端都完美的做法。硬要对比的话，可能 Result&amp;lt;T, E: Error&amp;gt; 对使用者更加友好一些，因为它提供了一个定义错误类型的机会。但是相对地，如果创建者没有掌握好错误类型的程度，而将多层嵌套的错误传递时，反而会增加使用者的负担。同时，由于错误类型被限定，导致 API 的变更要比只定义了结果类型的 Result 困难得多。关于 Swift defer 的正确使用defer 的目的就是进行资源清理和避免重复的返回前需要执行的代码，而不是用来以取巧地实现某些功能。这样做只会让代码可读性降低。实用的可选项（Optional）扩展Optional 的一些扩展。Swift Tip: Custom Views Without Subclassing · objc.io如果只是创建一个 view 后不再进行改变，可以使用一个简单的 functino 来进行创建，而不是自定义一个 subView 。Swift Tip: Local Struct Definitions · objc.io为避免占用命名空间，可将只使用一次的类或者结构体放到函数中。Custom Operators in Swift with considerations for readability - SwiftLee如果是在频繁使用的可以考虑使用 custom operators，但是需要考虑代码的可读性。What’s .self, .Type and .Protocol? Understanding Swift Metatypes - SwiftRocksSwift 元类型，介绍了动态元类型 type(of:) 和静态元类型 .self以及协议的元类型用法。Avoiding race conditions in Swift避免竞态条件，讲述两种可能出现竞态条件的情况，多线程和多次请求导致一些不符合预期的情况出现。" }, { "title": "2018-10-ReadingList", "url": "/posts/2018-10-ReadingList/", "categories": "", "tags": "阅读笔记", "date": "2018-11-01 20:58:14 +0800", "snippet": "https://nshipster.cn/hashable/Hash在 swift 中的进化史https://www.appcoda.com/memory-management-swift/strong weak 与 unownedhttps://oleb.net/2018/photos-data-model/PhotoKit 是 iOS 提供给 app 进行相册相关操作的框架，作者从中发现了数据层部分是使用 CoreData 来编写的，讲述如何发现是使用 CreData 以及如何使用 Xcode 结合 .mom 文件来查看 Data Model 的结构https://swiftrocks.com/writing-cleaner-view-code-by-overriding-loadview.html如何通过 UIViewController 中的 loadView 方法来自义 ViewCtroller 的 view，从而达到将 ViewCtroller 中配置 view 的相关代码分离出来的目的，也可以结合 protocol 来减少要编写的模版代码，不过也有一些缺点。https://swiftrocks.com/swift-associated-types-with-default-values.html为 protocol 的关联类型提供默认值https://www.swiftbysundell.com/posts/lightweight-presenters-in-swift轻量的 Presenter 设计模式，套多一层中间层 Presenter 来分离各 ViewController ，各 ViewController 不直接调用其它 ViewController ，而是通过 Presenter 来进行调用。https://www.avanderlee.com/swift/updating-swift-4-2/Swift 4.2 一些变化可以使用 self 来替代 strongSelf使用 #warning 来替代 //MARK todo使用 allCases 获取 enum 类型的所有 cases使用 random 获取随机值或者 shuffled 获取打乱的数组https://www.avanderlee.com/optimization/analysing-build-performance-xcode-10/Xcode 10 中的 Build 性能分析，Xcode 10新增了一个 Build With Time Summary 的性能检测，可以分析 Build 的过程中具体过程所消耗的时间。改进办法：Type checking of functions and expressions类型判断有时会消耗很长的时间，可以通过设置 -Xfrontend -warn-long-expression-type-checking= 来检测那些超过 limit（时间限制，ms）的表达式，同样的，对于函数，可以使用 -Xfrontend -warn-long-function-bodies= 来开启检测。在 debug 中开启 Whole Module 也可以优化 Build 性能。https://www.avanderlee.com/xcode/optin-features-xcode-10/Xcode 10 中一些配置：Code folding ，Whole Module 等。https://www.swiftbysundell.com/posts/reusable-data-sources-in-swift将 dataSources 从 View Controller 中分离出来，进行复用。https://www.objc.io/blog/2018/09/18/imperative-or-functional/如何结合命令式和函数式编程的 tipshttps://www.swiftbysundell.com/posts/different-flavors-of-view-models-in-swift使用 View Model 将逻辑从 View Controller 中分离出来https://www.avanderlee.com/swift/performance-collections/集合中函数式操作的性能优化使用 contains 代替 first(where:) != nil使用 isEmpty 代替 count 与 0 比较使用 isEmpty 来检测 String 是否为空使用 first(where:) 来代替 filter 后面追加 first使用 max() 和 min() 开代替 sorted() 后的 first 和 last使用 allSatisfy(_:) 来代替 filter 结合 isEmpty 判断是否所有对象都符合某个条件https://nshipster.cn/ios-12/iOS 12的一些变化跟 app 开发有关的有：在 iOS 12 的新 API 里，你可以把 URLRequest 对象networkServiceType 设置为 NSURLNetworkServiceTypeResponsiveData，从而让一些时间敏感的操作优先请求。根据电话号码和邮件地址匹配联系人。新密码的自动输入与一次性验证码在文本框里的输入。https://nshipster.cn/cmmotionactivity/CMMotionActivityManager 处理设备中传感器的原始数据并告诉你（有多确定）用户是否正在移动，和用户是在行走、跑步、骑行或者开车https://swift.gg/2018/10/15/creating-and-modifying-nsurl-in-swift-4/Swift 中 URL 的相关方法" }, { "title": "《 App 架构》阅读笔记-笔记1", "url": "/posts/app-architecture-first/", "categories": "", "tags": "阅读笔记, Architecture", "date": "2018-10-29 21:52:04 +0800", "snippet": "由 objc.io 出版的关于 App架构的书，我阅读的是ObjC 中国翻译的中文版本。关于此书此书用一个 录音 app 来实现以下几种设计模式： Model-View-Controller (MVC) Model-View-ViewModel+Coordinator (MVVM-C) Model-View-Controller+ViewState (MVC+VS) ModelAdapter-ViewBinder (MAVB) Elm 架构 (The Elm Architecture, TEA)没有哪种设计模式可以在所有情况下都做到最好，需要根据团队和 app 来进行调整和选择。 App 的设计模式不仅仅只是一套技术 上的工具，它同时也是审美和社交的手段，可以让你，以及你的代码的其他读者，与你所设计 的程序产生交流。换言之，最好的模式就是对你来说最为清晰的模式。关于架构的思考一个架构并不是所选择之后就不用再去考量和讨论，随着 app 和团队的不断变化，我们需要不断思考和改进架构，诚如书本所言，这些东西事关程序员的幸福。为什么选择录音 app需要一个可以展示各个架构的不同之处而又不会湮没细节的 app 。应用架构架构关注的两个方面： 如何将 app 分解为不同的接口和概念层次部件 这些部件之间和自身的不同操作所使用的控制流和数据流路径Model 和 ViewModel Model 层是 app 最基础的部分，不依赖其他框架 为我们的程序提供一个表述事实的单一来源，这会让逻辑清晰，行为正确View View 层依赖于 app 框架的部分，使 model 层可见 允许用户交互App的本质App 的本质是反馈回路，根据用户的操作进行 UI 界面的刷新，即使是最简单的 scrollView 滚动，也是根据用户的滑动手势来改变 scrollView 的位移，从而更新 scrollView 的显示部分。所以每个 app 所要处理的问题其实都是如何串联 View 和 Model 之间的通讯。架构技术 Notification 支持将值从单一源广播 KVO 将某个对象上属性的改变报告给另一个对象 响应式编程 让逻辑可以在部件之间传 输信息的同时得以表达 （本文采用的是 RxSwift）App 任务 构建 — 谁负责构建 model 和 view，以及将两者连接起来？ 更新 model — 如何处理 view action？ 改变 view — 如何将 model 的数据应用到 view 上去？ view state — 如何处理导航和其他一些 model state 以外的状态？ 测试 — 为了达到一定程度的测试覆盖，要采取怎样的测试策略？MVC实现MVC 的核心思想是，controller 层负责将 model 层和 view 层撮合到一起工作。Controller 对 另外两层进行构建和配置，并对 model 对象和 view 对象之间的双向通讯进行协调。所以，在 一个 MVC app 中，controller 层是作为核心来参与形成 app 的反馈回路的。文章认为对 model 改变的行为不应该和 view 层级变更的行为放在同一个函数，view 的变更只发生在观察的回调中，这样可以维持 model 和 view 的分离。View state 可以按需要被 store 在 view 或者 controller 的属性中。相对于影响 model 的 view action，那些只影响 view 或 controller 状态的 action 则不需要通过 model 进行传递。测试Cocoa MVC 模式已经超过 20 年历史，创建的时候没有考虑过测试这件事。大部分情况下只能采取集成测试，需要构建一个自包含版本的 app，操作其中的某些部分，然后从其他部 分读取数据，确保结果在对象之间按照期望的方式传递。讨论优点 开发阻力最低的架构模式 Cocoa 每个类都是在 MVC 模式下进行测试的 代码量最少，设计开销最小缺点 Model 和 view 的同步可能失效，无论在修改 model 或者 view 时都有可能导致两者的状态没有同步 View Controller 过于臃肿，ViewController 需要处理 view 层，也复制观察 model 以及更新 view，同时也要对 model 的数据进行处理。这些都会使 ViewController 过于臃肿改进 使用观察者模式，可以使用 NotificationCenter 或者 KVO 来观察 model 的变化 将尽可能多的功能从 View Controller 移出来，如移到 model 层中，比如排序，数据获取和处理等方法。个人感觉判断某段代码是否适合放在 View Controller 的标准是这段代码是否在其它地方也有使用到，如果有，就可以考虑抽离 使用代码而不是 Storyboard ，不使用 Storyboard 可以在构建阶段有更多的控制力 在扩展中进行代码重用，在 Swift 中可以结合协议来实现 利用 Child ViewController 进行代码重用 区分 coordinating controller 和 mediating controller，一般来说 coordinating controller 是无法重用的，而 coordinating controller 是用来执行特定的任务，是可重用的 简化 View 配置代码，如果 view controller 需要构建和更新非常多的 view，那么将这部分 view 配置的代码提取出来会很有帮助总结 在一个程序员表达对某个不同架构模式的拥护时，他们有时候会贬低 MVC。对于 MVC 的负面 评论包括：无法测试的 view controller，view controller 会增⻓得过大而且无法控制，数据依 赖难以管理等。但是，在阅读本章后，我们希望你意识到，虽然 MVC 确实有它自己的挑战，但 是写出清晰简洁，并包含完整测试以及明确对数据依赖进行管理的 view controller，是完全可能的。MVVM-C实现Model-View-ViewModel+协调器 (MVVM-C) 是 MVC 的变种，它拥有单独的“view-model” (视图模型) 和一个用来管理 view controller 的协调器。MVVM 使用数据 绑定 (通常会和响应式编程一起使用) 来建立 view-model 层和 view 层之间的连接。MVVM 鼓励将 model 和 view 之间的关系构建为一系列的变形管道。（减少了 controller 所需要承担的责任），提供一套独立于 app 框架的接口，但是它在相当程度上代表了 view 应该展示的状态。和 MVC 不同，view controller 不监听 model 。View-model 将负责观察 model，并将 model 的通知转变为 view controller 可以理解的形式。View controller 订阅 view-model 的变更，这 通常通过一个响应式编程框架来完成，但也可以使用任意其他的观察机制。当一个 view-model 事件来到时，由 view controller 去更改 view 层级。测试在 MVVM 里，我们通常只使用接口测试来测试 view-model，而 controller 和 view 则依赖于 Xcode 的 UI 测试或者人工测试。 配置测试：构建输入，构建用来传递输入的接口，然后从接口中读取结果 展示测试：对可观察量的测试也遵循通用的模式：对 view-model 上所暴露的每一个可观察量，对初始值 进行测试，然后执行操作，并测试后续的条件 (还可以进行更多的操作并测试更多的条件) 行为测试：测试 初始条件，执行操作，然后测试接下来的条件较低的学习成本为了降低学习成本，可以使用较少响应式编程的 MVVM，可以通过 KVO 的形式来实现。协调器协调器是独立于 MVVM 架构之外的一种模式，用来减少 controller 的职责，并对它们解耦。controller 调用协调器上的代码来与其他 controller 进行联动。Cocoa MVC 中 controller 层的一个职责就是将 model 数据变形为所配置的 view 中所需要的显 示数据。通常这意味着将 model 对象上的字符串，数字或者日期转变为可以显示的形式。即使 在最简单的情况下，将这边部分代码抽离出来，也可以让 controller 更加整洁，同时易于测试。总结即使不使用 MVVM ，我们也可以从 MVVM 的架构学到一些东西。通过适当引入额外的层，可以使得代码更易维护，减少错误的发生，下面是一些在适当的情况下可以引入的层： App-model：获取 model 数据 (比如是否存在已经保存的用户凭证) 并将它与系统服务 的信息 (比如网络是否可用) 合并，将这个信息作为可观察量提供给其他 view-model 使 用 Session-model：追踪当前登录会话的细节，可能需要在 view-model 和 主 model 之间，或者 view-model 和其他接口之间，进行网络请求的处理 Flow-model：一个类似 model 版本的协调器，用来将导航状态作为数 据进行建模，并将导航状态和 model 数据合并，直接为 view-model 提供可观察的 model 数据 Use case：使用例指的是那些用来对主 model 进行切片准备，并且用来简化所 要执行的操作的任意类型的接口或者 model。使用例和 view-model 很像，但是它并不 被绑定在一个单独的 controller 上，而是可以在 view-model 之间进行传递或者共享， 来在多个 view-model 中提供可重用的功能。当一个 app 有多个 view 显示同样的底层 数据时，我们可以使用共通的使用例对象来对从 model 获取数据和将数据写回 model 的操作进行简化 大多数大型程序最终都会发展到包含这些抽象。我们建议你不要过早地引入额外的抽象层。你需要精心评估某个变更是否能让你的代码变得简单 (比如更容易被理解)，是否能减少错误发生 的可能，以及是否更容易维护。如果额外的抽象不能提升你写新代码的能力的话，那么我们就 没有理由添加它们。" }, { "title": "2018-09-ReadingList", "url": "/posts/2018-09-ReadingList/", "categories": "", "tags": "阅读笔记", "date": "2018-10-05 14:05:15 +0800", "snippet": "Swift 4 泛型：如何在你的代码或App里应用泛型如何在 Swift 中应用泛型，比较基础。Swift 中的属性Swift 属性相关说明，一些属性相关的基础用法。Defer usage in Swiftdefer 在 swift 中的运行机制，defer 的执行顺序是按照声明顺序倒序执行，介绍了几个在 swift 中使用 defer 的场景，可以预先设定在函数完成后需要执行的方法。我大部分用到 defer 的场景就是取消 tableView/collectionView 的选中效果。CompactMap vs flatMap: The differences explainedcompactmap 与 flatmap 的不同之处，如果数组为 optional ，想转换为 nonoptional，则使用 compactmap ，flatmap 则是将多维数组降为一维。Never介绍了 Never 这个无实例类型，以及如何使用 Never 来优化代码中的不可能情况。Private properties in protocols在 Swift 中，protocols 不支持定义属性的访问控制权，但是有时候你不想暴露这些属性。这篇文章介绍了如何使用一个嵌套类型和 fileprivate 来使得属性私有化。Switching with Associated Values如何在多重 switch 中优化代码。Design Patterns in Swift #1: Factory Method and SingletonDesign Patterns in Swift #2: Observer and MementoDesign Patterns in Swift #3: Facade and Adapter设计模式三连发。第一篇为工厂模式和单例模式，工厂模式结合 protocol 对类进行抽象。第二篇为观察者模式和备忘录模式，观察者模式结合了 protocol 和 enum 来讲述如何实现在 Swift 中实现观察者模式，备忘录模式则是 protocol 和 UserDefaults 相结合来实现数据持久化。第三篇为外观模式和适配器模式，外观模式还是通过 protocol 进行封装成统一的接口。适配器模式也是结合 protocol 来说明如何对接口进行调整。" }, { "title": "2017", "url": "/posts/2017/", "categories": "", "tags": "summary", "date": "2018-03-04 23:03:08 +0800", "snippet": "工作2017年在工作上的变动较大，3月初从原来的公司离职，到找了一个月都没有找到工作，到4月份的时候来到现在的一个创业公司。也差不多有一年的时间了。工作方式工作方式变化较大。原来的公司属于半国企那种性质，需求变化也不大，下班也基本上都不会找你聊工作的事，我觉得可能是因为大家可能对产品都不大在乎，做出来就行了。现在几乎将工作和生活完全融合在一起了。一般大家发现什么bug或者有什么需求都会直接在微信上提出来，就算周末也是一样。可能是因为之前太懒散了，我觉得现在还算不错。有点奇怪。而且现在也比较自由，对上下班的时间要求不太严格，能做完需求就行了。12月31号晚上我还在赶一个需求，也是比较独特的体验。问题因为是创业公司的关系，要快，快是第一标准，其它的都不是太重要。因为没产品就没用户，就融不到钱。在做产品的时候还要试错，尝试不同的方向。而且公司也没有太注重代码规范，后台给出来的接口虽然说可以用。但是非常乱，接口文档也经常缺少资料。经常在用的时候要去问一下，好在大家都在一个办公室，沟通起来比较方便。目前只有我一个在做iOS的app，这也是一个问题。因为只有自己一个人写代码，没有交流，很多地方都是有错漏，没考虑到的。而且因为赶需求的关系，很多地方的代码都没有考虑好，临时凑上去的。这样其实很不好，很多人都对自己说以后会改，其实不会。一定要记得提醒自己以后记得回来修改这部分，还有不要在这样临时凑代码了。产品公司的产品是汽车方向的垂直社交产品，最近刚推出社交部分，但是很多东西都还没完善，功能缺失比较严重。现在的办公室分为两部分，编辑部跟开发部。编辑部的同事感觉得都是比较热爱汽车的，平时听他们聊汽车的事也挺不错。产品在慢慢的一步步成长，功能也慢慢补全，希望可以越来越好。学习公司的产品除了第三方的框架，基本上全是用 Swift 写的，这年基本上没写过 Objective-C ，技术上成长也比较大，为了使信息流界面滑动流畅，使用了 Texture ，也学习了 Texture 那套布局方案，也开始尝试使用 RxSwift 。也有回馈开源社区，给自己使用的几个开源框架提了PR。希望今年技术上可以更近一步，写出更少bug的代码（代码是一定有bug的），学习一门新语言，更多的回馈开源社区。阅读《图解HTTP》年初读的，现在只记得一小部分了。《github入门与实践》说github的书，有时间可以读一下。《Swift tips》介绍Swift各种tips的书，比较分散，上下文无关联，适合通勤路上阅读。《神们自己》还可以吧。《美国众神》感觉烂尾了。《岛上书店》感觉没有网上评论的这么好，看完没啥感触。《1984》走进新时代。《仿生人会梦见电子羊吗》结尾很突然。" }, { "title": "Texture 开发笔记", "url": "/posts/texture-notes/", "categories": "", "tags": "iOS, Texture", "date": "2018-01-07 23:51:06 +0800", "snippet": "ASImageNodeASImageNode 不支持直接设置 tintColor ，如果需要设置 tintColor需要通过 imageModificationBlock 进行设置：imageNode.imageModificationBlock = ASImageNodeTintColorModificationBlock(UIColor.white)github上的相关讨论：https://github.com/facebookarchive/AsyncDisplayKit/issues/426还有就是如果需要改变ASButtonNode 的 imageNode 的 tintColor，是改不了的，需要通过设置不同状态的图片，然后通过改变buttonNode的状态来改变图片。buttonNode.setImage(image, for: .normal)buttonNode.setImage(image.tinted(with: UIColor.red), for: .selected)// https://gist.github.com/ImJCabus/3e6c80ca1a5dd23f8f9866c730e1f1c7 tintColor代码ASLayoutSpec当 spaceBetween 没有达到两端对齐的效果，尝试设置当前 layoutSpec 的 width（如注释）或它的上一级布局对象的 alignItems，在例子中就是 stackLayout.alignItems = .stretch。Texture 布局篇ASDisplayNode的高度计算如果在 UIView 或者UITableViewCell中添加ASDisplayNode，而且需要计算ASDisplayNode的高度，在 ASDisplayNode 实现了 - (ASLayoutSpec *)layoutSpecThatFits:(ASSizeRange)constrainedSize 情况下，可以调用 - (ASLayout *)layoutThatFits:(ASSizeRange)constrainedSize 方法计算出大小。_ = node.layoutThatFits(ASSizeRangeMake(CGSize.zero, CGSize(width: view.frame.width, height: CGFloat.greatestFiniteMagnitude)))print(node.calculatedSize.height)给 ASDisplayNode 的 View 添加手势 -didLoad This method is conceptually similar to UIViewController’s -viewDidLoad method; it’s called once and is the point where the backing view has been loaded. It is guaranteed to be called on the main thread and is the appropriate place to do any UIKit things (such as adding gesture recognizers, touching the view / layer, initializing UIKit objects).需要在didLoad中添加/** @name View Lifecycle */ /** * @abstract Called on the main thread immediately after self.view is created. * * @discussion This is the best time to add gesture recognizers to the view. */open func didLoad()ASDisplayNode 使用 initWithViewBlock 方法进行初始化需要注意 retain cycle 的问题，持有 self 变量要设置为 weak。另外ASDisplayNode 并不知道自己持有的View的大小，需要对 style.preferredSize 进行设置。ASTextNode2 attachment的问题ASTextNode2 目前尚未支持通过添加 NSTextAttachment 的方式在 NSAttributedString 后面添加图片，如果需要实现上面的需求要使用ASTextNode。ASCellNode里面再嵌套UITableViewCell为了复用一些布局，比如个人界面的设置Cell，采用了在ASCellNode使用viewBlock方法来复用Cell。let cellNode = ASCellNode(viewBlock: { () -&amp;gt; UIView in let cell = UITableViewCell(style: .default, reuseIdentifier: nil) // cell.isUserInteractionEnabled = false return cell })显示出来的布局是正常的，在iOS 11上点击也可以跳转，但是今天在iOS 10上测试的时候发现无法响应点击事件，如果是用UIView生成也可以响应点击事件，怀疑是UITableViewCell拦截了点击事件，但是为什么在iOS 11上可以，iOS 10上就不可以？不知道。加上 ：cell.isUserInteractionEnabled = false在iOS 10也可以响应点击事件了。ASEditableTextNodeASEditableTextNode 默认高度只能适应英文字母，如果输入中文会发现被裁了一截，所以在初始化时需要指定一下 ASEditableTextNode 的高度let editableTextNode = ASEditableTextNode()editableTextNode.style.height = ASDimensionMake(44)ASTableNode 和 ASCollectionNodeASTableNode，ASCollectionNode调用reloadData时闪烁的问题。在ASTableNode和ASCollectionNode需要刷新时不推荐直接使用 reloadData ，直接调用 reloadData 时会发现整个node都会闪一下。一个比较好的解决方法是每次刷新算出需要添加，删除或者刷新的 indexPath 或者 section，再对这部分调用对应的局部刷新方法。// indexPaths- (void)insertRowsAtIndexPaths:(NSArray *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation;- (void)deleteRowsAtIndexPaths:(NSArray *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation;- (void)reloadRowsAtIndexPaths:(NSArray *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation;// sections- (void)insertSections:(NSIndexSet *)sections withRowAnimation:(UITableViewRowAnimation)animation;- (void)deleteSections:(NSIndexSet *)sections withRowAnimation:(UITableViewRowAnimation)animation;- (void)reloadSections:(NSIndexSet *)sections withRowAnimation:(UITableViewRowAnimation)animation;" }, { "title": "PhotoKit 与 iCloud 图片", "url": "/posts/photokit-with-iCloud/", "categories": "", "tags": "iOS", "date": "2017-10-08 21:53:28 +0800", "snippet": "起因公司的 app 在前段时间的改版中，需要自定义一个相册界面，调研了一轮开源控件，感觉没有找到比较满意的，就尝试自己写了一个，用了 PhotoKit。基本上用下来也没多大问题。但是在处理iCloud图片的时候遇到了一个小问题。如果用户开启了优化 iPhone 存储空间，或者未加载好，PhotoKit 是会先拿到这些图片的缩略图，一般来说在相册列表显示多张图片时，为了防止占用内存过多，通常是调用 requestImage(for:targetSize:contentMode:options:resultHandler:) 来获取指定尺寸的图片资源，这时候如果你的相册列表显示的图片的尺寸跟缩略图的尺寸大小相同，是可以显示出来的。当你选择后，如果通过 PHCachingImageManager 或者 PHImageManager 调用 requestImageData(for:options:resultHandler:) 方法，你会发现 resultHandler 中的 data 为空。解决找到问题后开始着手解决。PHImageRequestOptions 中 isNetworkAccessAllowed 属性表示是否允许下载来自iCloud中的图片。设置为 true 之后调用 requestImageData(for:options:resultHandler:) 即可下载来自iCloud的图片。为了不浪费用户的流量，应该加多一个网络状态判断，如果是手机网络，则弹窗确认是否要同步该iCloud图片。同时为了更好的用户体验，对下载中的图片，在 UI 上应该加多一个 loading 的提示，针对这部分功能，我建了一个 Dictionary 来存储同步状态，key 为对应的 PHObject 的 localIdentifier，value 则为同步状态，每次 cell 复用时，都需要去检查是否存在对应的同步状态，有则对 UI 进行对应的修改。其它问题 获取相册专辑列表的时候，记得在设置对应的 PHFetchOptions 的 predicate 为 NSPredicate(format: &quot;estimatedAssetCount &amp;gt; 0&quot;) ，过滤掉空的相册专辑。 在 cell 复用时，记得调用 cancelImageRequest: 取消 cell 之前的加载请求。 " }, { "title": "《Swift进阶》阅读笔记 - 可选值", "url": "/posts/advanced-swift-optional/", "categories": "", "tags": "Swift, 阅读笔记", "date": "2017-03-14 23:45:17 +0800", "snippet": "哨岗值当返回一个“魔法数”来表示函数没有返回真实的值，这样的值称为“哨岗值”。哨岗值很容易产生问题，因为可能忘记检查哨岗值，并且不小心使用了它们。通过枚举解决魔法数的问题enum Optional&amp;lt;Wrapped&amp;gt; { case none case some(wrapped)}获取关联值的唯一方法是使用 switch 或者 if case 语句。和哨岗值不同，除非你显式地检查并解包，你是不可能意外地使用到一个 Optional 中的值的。var array = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;]switch array.index(of: &quot;four&quot;) {case let idx?: array.remove(at: idx)default: break}可选值概览 if let通常情况下可以使用if let来进行可选绑定：var array = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;]if let idx = array.index(of: &quot;four&quot;) { array.remove(at: idx)}// 可选绑定跟布尔语句搭配if let idx = array.index(of: &quot;four&quot;), idx != array.startIndex{ array.remove(at: idx)}// if语句绑定多个值，后面的绑定值可以调用之前成功解包的值来进行操作，每个let也可以跟一个布尔语句绑定let urlString = &quot;http://www.objc.io/logo.png&quot;if let url = URL(string: urlString), let data = try?Data(contentsOf: url), url.pathExtension == &quot;png&quot;, let image = UIImage(data: data) { let view = UIImageView(image: image) // ...}// 也可以为if let提供前置条件进行检查if segue.identifier == &quot;showUserDetailsSegue&quot;, let userDetailVC = segue.destination as? UserDetailViewController { userDetailVC.screenName = &quot;Hello&quot;} while let表示遇到nil时终止循环。// 跟布尔语句搭配while let line = readLine(), !line.isEmpty { print(line)} 双重可选值一个可选值本身被另一个可选值包装起来。next()函数返回的是一个Optional&amp;lt;Optional&amp;gt;值。let stringNumbers = [&quot;1&quot;, &quot;2&quot;, &quot;three&quot;]let maybeInts = stringNumbers.map { Int($0) }var iterator = maybeInts.makeIterator()while let maybeInt = iterator.next() { print(maybeInt)}/*Optional(1)Optional(2)nil*/// if case 模式匹配for case let i? in maybeInts { // i 将是 Int 值，而不是 Int? print(i, terminator: &quot; &quot;)}// 或者只对 nil 值进行循环for case nil in maybeInts {// 将对每个 nil 执行一次print(&quot;No value&quot;)} if var and while varvar也可以跟if，while和for搭配：let number = &quot;1&quot;if var i = Int(number) { i += 1 print(i) // 2}print(number) // 1, i为值类型，不会改变原来的值。 解包后的作用域使用guard let提早退出来避免if嵌套：extension String { var fileExtension: String? { guard let period = characters.index(of: &quot;.&quot;) else { return nil } let extensionRange = index(after: period)..&amp;lt;characters.endIndex return self[extensionRange] }}&quot;hello.txt&quot;.fileExtension等价于：extension String { var fileExtension: String? { let period: String.Index if let idx = characters.index(of: &quot;.&quot;) { period = idx } else { return nil } let extensionRange = index(after: period)..&amp;lt;characters.endIndex return self[extensionRange] }}在guard的else中必须离开当前的作用域，如return，fatalError，break或者continue等。如果没有的话，编译器会报错，因此应尽量使用guard。 可选链 在 Objective-C 中，对 nil 发消息什么都不会发生。Swift 里，我们可以通过“可选链 (optional chaining)”来达到同样的效果。delegate?.callback() nil合并运算符// 可用于提供默认值let stringteger = &quot;1&quot;let number = Int(stringteger) ?? 0// 也可以进行链接let i: Int? = nillet j: Int? = nillet k: Int? = 42i ?? j ?? k // Optional(42) 可选值map可选值的map跟序列中的map不同之处在于，可选值的map只会操作一个值，就是该可选值中那个可能的值。可选值可以看作包含零个或者一个值的集合。所以map要么不做处理，要么在有值的情况下进行转换：extension Optional { func map&amp;lt;U&amp;gt;(transform: (Wrapped) -&amp;gt; U) -&amp;gt; U? { if let value = self { return transform(value) } return nil }} 可选值判等 == 有一个接收两个可选值的版本：func ==&amp;lt;T: Equatable&amp;gt;(lhs: T?, rhs: T?) -&amp;gt; Bool { switch (lhs, rhs) { case (nil, nil): return true case let (x?, y?): return x == y case (_?, nil), (nil, _?): return false }}当你在使用一个非可选值时，如果需要匹配非可选值，Swift 会将它变成一个可选值然后使用 Equatable 和 ==数组中 == 操作符需要数组元素遵守 Equatable 协议。 switch－case 匹配可选值需要实现 Equatable 中的 ~= 运算符 强制解包的时机 当你能确定你的某个值不可能是 nil 时可以使用叹号，你应当会希望如果它不巧意外地是 nil 的话，这句程序直接挂掉。改进强制解包的错误信息infix operator !!func !!&amp;lt;T&amp;gt;(wrapped: T?, failureText: @autoclosure () -&amp;gt; String) -&amp;gt; T { if let x = wrapped { return x } fatalError(failureText())}let s = &quot;foo&quot;let i = Int(s) !! &quot;Expecting integer, got \\&quot;\\(s)\\&quot;&quot;在调试版本中进行断言在调试或者测试版本中进行断言，正式版本中提供默认值。infix operator !?func !?&amp;lt;T: ExpressibleByIntegerLiteral&amp;gt;(wrapped: T?, failureText: @autoclosure () -&amp;gt; String) -&amp;gt; T { assert(wrapped != nil, failureText) return wrapped ?? 0}ExpressibleByIntegerLiteral 改为 ExpressibleByArrayLiteral ，ExpressibleByStringLiteral则可以覆盖数组和字符串类型。挂起操作有三种方式： fatalError 无条件停止操作，可以接受一条信息 assert 会进行条件监测， false 时停止操作，正式版本中会被移除掉 precondition 跟 assert 比较类似，但是在正式版本中不会被移除" }, { "title": "《Swift进阶》阅读笔记 - 集合类型", "url": "/posts/advanced-swift-collections/", "categories": "", "tags": "Swift, 阅读笔记", "date": "2017-03-13 22:03:06 +0800", "snippet": "数组高阶函数实现map函数，把for循环中的代码模版部分用一个泛型函数封装起来。下面是可能的实现方式：extension Array { func map&amp;lt;T&amp;gt;(_ transform: (Element) -&amp;gt; T) -&amp;gt; [T] { var result: [T] = [] result.reserveCapacity(count) for x in self { result.append(transform(x)) } return result }}注：如果明确知道数组的大小，可以调用reserveCapacity(_:)方法，避免在添加元素过程中重复申请内存。array-reservecapacity map和flatMap —— 如何对元素进行变换let numbers = [1, 2, 3, 4, 5]let squareMapNumbers = numbers.map { $0 * 2}print(squareMapNumbers) //[2, 4, 6, 8, 10]let squareFlatMapNumbers = numbers.flatMap { $0 * 2}print(squareFlatMapNumbers) //[2, 4, 6, 8, 10]可以看到map跟flatMap的结果是相同的，那么map跟flatMap的不同之处在哪呢，当对二维数组进行操作时就可以看出不同了：let numbersCompound = [[1,2,3],[4,5,6]];let mapCompound = numbersCompound.map { $0.map{ $0 + 2 } }print(mapCompound) // [[2, 4, 6], [8, 10, 12]]let flatMapCompound = numbersCompound.flatMap { $0.map { $0 + 2 } }print(flatMapCompound) // [2, 4, 6, 8, 10, 12]可以看到二维数组经过map转换还是二维数组，而经过flatMap转换后被拍扁了，变成了一维数组。当数组中含有nil时，flatMap也会把nil去掉。let string = [&quot;ab&quot;, &quot;cc&quot;, nil, &quot;dd&quot;]let flatMapString = string.flatMap { $0 }print(flatMapString) // [&quot;ab&quot;, &quot;cc&quot;, &quot;dd&quot;]// 用filter和map组合实现flatMap过滤nil值的效果let mapString = string.filter { $0 != nil}.map { $0!}print(mapString) // [&quot;ab&quot;, &quot;cc&quot;, &quot;dd&quot;]flatMap还可以用于将不同数组里的元素进行配对。let chineseNumbers = [&quot;😢&quot;, &quot;😊&quot;, &quot;😓&quot;, &quot;🐶&quot;, &quot;🐱&quot;]let result = numbers.flatMap { number in chineseNumbers.map { chineseNumber in (number, chineseNumber) }}print(result) // [(1, &quot;😢&quot;), (1, &quot;😊&quot;), (1, &quot;😓&quot;), (1, &quot;🐶&quot;), (1, &quot;🐱&quot;), (2, &quot;😢&quot;), (2, &quot;😊&quot;), (2, &quot;😓&quot;), (2, &quot;🐶&quot;), (2, &quot;🐱&quot;), (3, &quot;😢&quot;), (3, &quot;😊&quot;), (3, &quot;😓&quot;), (3, &quot;🐶&quot;), (3, &quot;🐱&quot;), (4, &quot;😢&quot;), (4, &quot;😊&quot;), (4, &quot;😓&quot;), (4, &quot;🐶&quot;), (4, &quot;🐱&quot;), (5, &quot;😢&quot;), (5, &quot;😊&quot;), (5, &quot;😓&quot;), (5, &quot;🐶&quot;), (5, &quot;🐱&quot;)]详细的说明可以看这篇文章谈谈 Swift 中的 map 和 flatMap filter —— 元素是否应该被包含在结果中let filterNumbers = [1, 2, 3, 4, 5]let filteredNumbers = filterNumbers.filter { $0 &amp;gt; 3 }print(filteredNumbers) //prints [4, 5] reduce —— 如何将元素合并到一个总和的值中let reduceNumbers = [1, 2, 3, 4 ,5]let reducedNumber = reduceNumbers.reduce(0) { $0 + $1 }print(reducedNumber) //prints 15 sequence —— 序列中下一个元素应该是什么 forEach —— 对于一个元素，应该执行怎样的操作，需要注意的是forEach中的return语句不会终止循环，仅仅是从闭包中返回而已。 sort，lexicographicCompare和partition —— 两个元素应该以怎样的顺序进行排列 index，first 和 contains — 元素是否符合某个条件 min 和 max — 两个元素中的最小/最大值是哪个 elementsEqual 和 starts — 两个元素是否相等 split — 这个元素是否是一个分割符let name = &quot;Firts Lase&quot;let nameArray = name.characters.split { $0 == &quot; &quot; }.map(String.init)print(nameArray) // [&quot;Firts&quot;, &quot;Lase&quot;]切片Array中允许通过指定下标范围来获取某一段的值：let slice = numbers[1..&amp;lt;numbers.endIndex]print(slice) // [2, 3, 4, 5]slice的类型为ArraySlice。需要注意的是slice与numbers一开始是共用存储空间的。在上述例子中如果企图访问slice[0]编译器是会报错的，显示越界访问。字典字典中通过键获取值所花费的评价时间是常数量级的。数组中搜寻一个特定元素所花的时间与数组尺寸成正比的。可变性字典可以通过下表修改和删除对应的值。如果需要删除某个值的话，将下标对应的值设为nil即可。如果需要返回删除的值可以调用removeValue(forKey:)。更新操作也是，如果需要返回更新前的值，则可以调用updateValue(_:forKey:)有用的字典扩展 合并，用来合并的字典可以覆盖重复的值。extension Dictionary { mutating func merge&amp;lt;S&amp;gt;(_ other: S) where S: Sequence, S.Iterator.Element == (key: Key, value: Value) { for (k, v) in other { self[k] = v } }}必须是序列，以进行循环枚举，必须是key-value的形式。这样只要是key-value的形式都可以进行合并，不一定是字典。 使用一个key-value的序列来创建字典extension Dictionary { init&amp;lt;S: Sequence&amp;gt;(_ sequence: S) where S.Iterator.Element == (key: Key, value: Value) { self = [:] self.merge(sequence) }} 对字典中的值进行映射extension Dictionary { func mapValues&amp;lt;NewValue&amp;gt;(transform: (Value) -&amp;gt; NewValue) -&amp;gt; [Key:NewValue] { return Dictionary&amp;lt;Key, NewValue&amp;gt;(map { (key, value) in return (key, transform(value)) }) }}Set集合Set是一组无序的元素，每个元素只会出现一次。测试集合中是否包含某个元素是一个常数时间的操作。可以在一个集合中求另一个集合的补集，也可以求两个集合的交集，也可以求两个集合的并集。集合类型协议序列Sequence协议是集合类型结构中的基础。一个序列代表一系列具有相同类型的值，你可以对这些值进行迭代。Sequence协议：protocol Sequence { associatedtype Iterator: IteratorProtocol func makeIterator() -&amp;gt; Iterator}Sequence还有另外一个关联类型，叫做SubSequence：protocol Sequence { associatedtype Iterator: IteratorProtocol associatedtype SubSequence}在返回原序列的切片操作中，SubSequence被用作返回值的字类型： prefix和suffix——获取开头或者结尾n个元素 dropFirst和dropLast——返回移除掉前n个或后n个元素的字序列 split——将一个序列在指定的分隔元素时截断，返回子序列的数组迭代器IteratorProtocol协议中唯一的一个方法是next()，这个方法在每次调用时返回序列中的下一个值。当序列耗尽时返回nil：protocol IteratorProtocol { associatedtype Element mutating func next() -&amp;gt; Element?}集合类型集合类型指的是稳定的序列，它们能够被多次遍历且保持一致。Collection协议是建立在Sequence 协议上的。在Sequence协议的基础上，Collection还提供了比如count属性的新能力。protocol Collection: Indexable, Sequence { /// 一个表示集合中位置的类型 associatedtype Index: Comparable /// 一个非空集合首个元素的位置 var startIndex: Index { get } /// 集合中超过末位的位置，也就是比最后一个有效下标值大1的位置 var endIndex: Index { get } /// 返回在给定索引之后的那个索引值 func index(after i: Index) -&amp;gt; Index /// 访问特定位置的元素 subscript(position: Index) -&amp;gt; Element { get }}遵守ExpressibleByArrayLiteral协议遵守ExpressibleByArrayLiteral协议则可以以 [value1, value2, etc] 的方式创建一个队列：extension FIFOQueue: ExpressibleByArrayLiteral { public init(arrayLiteral elements: Element...) { self.init(left: elements.reversed(), right: []) }}索引每个集合都有两个特殊的索引，startIndex和endIndex。startIndex指定集合中第一个元素，endIndex是集合中最后一个元素之后的位置。endIndex并不是一个有效的下标索引。集合类型的Index必须实现Comparable。Comparable协议索引失效失效有两层含义： 索引本身有效，但是已经指向另外一个元素 索引本身已经无效，通过它来访问集合会造成崩溃链表/// 一个简单的链表枚举enum List&amp;lt;Element&amp;gt; { case end indirect case node(Element, next: List&amp;lt;Element&amp;gt;)}indirect关键字允许一个枚举成员能够持有引用。extension List { /// 在链表前方添加一个值为`x`的节点，并返回这个链表 func cons(_ x: Element) -&amp;gt; List { return .node(x, next: self) }}let list = List&amp;lt;Int&amp;gt;.end.cons(1).cons(2).cons(3)print(list) // node(3, List&amp;lt;Swift.Int&amp;gt;.node(2, List&amp;lt;Swift.Int&amp;gt;.node(1, List&amp;lt;Swift.Int&amp;gt;.end)))同样也可以添加ExpressibleByArrayLiteral协议。extension List: ExpressibleByArrayLiteral { init(arrayLiteral elements: Element...) { // 逆序操作，从根节点开始初始化 self = elements.reversed().reduce(.end) { partialList, element in partialList.cons(element) } }}let list2: List = [3, 2, 1]print(list2) // node(3, List&amp;lt;Swift.Int&amp;gt;.node(2, List&amp;lt;Swift.Int&amp;gt;.node(1, List&amp;lt;Swift.Int&amp;gt;.end)))栈定义一个通用的栈的协议：/// 一个进栈和出栈都是常数时间操作的后进先出（LIFO）栈protocol Stack { /// 栈中存储的元素的类型 associatedtype Element /// 将`x`入栈到`self`作为栈顶元素 /// - 复杂度：O(1) mutating func push(_ x: Element) /// 从`self`移除栈顶元素，并返回它 /// 如果`self`是空，返回`nil` /// - 复杂度：O(1) mutating func pop() -&amp;gt; Element?}为List添加Stack协议：extension List: Stack { mutating func push(_ x: Element) { self = self.cons(x) } mutating func pop() -&amp;gt; Element? { switch self { case .end: return nil case let .node(x, next:xs): self = xs return x } }}为List添加IteratorProtocol和Sequence协议，只需要添加next()方法：extension List: IteratorProtocol, Sequence { mutating func next() -&amp;gt; Element? { return pop() }}" }, { "title": "为什么使用 RxSwift", "url": "/posts/why-use-rxswift/", "categories": "", "tags": "RxSwift, 翻译", "date": "2017-03-09 15:31:00 +0800", "snippet": "原文链接:WhyRxSwift支持以声明的方式来构建App。BindingsObservable.combineLatest(firstName.rx.text, lastName.rx.text) { $0 + &quot; &quot; + $1 } .map { &quot;Greetings, \\($0)&quot; } .bindTo(greetingLabel.rx.text)也适用于UITableView和UICollectionView。viewModel .rows .bindTo(resultsTableView.rx.items(cellIdentifier: &quot;WikipediaSearchCell&quot;, cellType: WikipediaSearchCell.self)) { (_, viewModel, cell) in cell.title = viewModel.title cell.url = viewModel.url } .disposed(by: disposeBag)我们建议你使用.disposed(by: disposeBag)，即使它在简单的bindings中不是必须的。Retries如果API的调用不会失败是极好的，但是不幸的是它们会。让我们以下面的方法来进行说明：func doSomethingIncredible(forWho: String) throws -&amp;gt; IncredibleThing如果你正在使用这个函数，在它失败时进行重试是非常困难的。更不用说复杂性建模了。当然是可以进行重试的，但是代码可能会包含很多你不在意的临时状态，而且是不可重用的。在理想情况下，你想要获取到重试的本质，并将其应用于所有操作中。下面是你使用Rx来实现简单的重试的代码。doSomethingIncredible(&quot;me&quot;) .retry(3)你可以很容易地实现自定义的重试操作。Delegates使用下面的方式：self.resultsTableView .rx.contentOffset .map { $0.x } .bindTo(self.leftPositionConstraint.rx.constant)来替代繁琐和不明了的操作：public func scrollViewDidScroll(scrollView: UIScrollView) { [weak self] // what scroll view is this bound to? self?.leftPositionConstraint.constant = scrollView.contentOffset.x}KVO使用 rx.observe and rx.observeWeakly使用下面的方式：view.rx.observe(CGRect.self, &quot;frame&quot;) .subscribe(onNext: { frame in print(&quot;Got new frame \\(frame)&quot;) }) .disposed(by: disposeBag)或者：someSuspiciousViewController .rx.observeWeakly(Bool.self, &quot;behavingOk&quot;) .subscribe(onNext: { behavingOk in print(&quot;Cats can purr? \\(behavingOk)&quot;) }) .disposed(by: disposeBag)来替代：当`TickTock`被释放，Observers仍然监听这个对象时。监听者信息就会产生内存泄漏，甚至可能错误地附加到其它对象中。和-(void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)contextNotifications使用下面的方式：NotificationCenter.default .rx.notification(Notification.Name.UITextViewText, object: myTextView) .map{ /*do something with data*/ } ...来替代：@available(iOS 4.0, *)public func addObserverForName(name: String?, object obj: AnyObject?, queue: NSOperationQueue?, usingBlock block: (NSNotification) -&amp;gt; Void) -&amp;gt; NSObjectProtocolTransient state在编写异步程序时临时状态会有许多问题。一个典型的例子是自动填充搜索框。如果你曾在不使用Rx的情况下编写自动填充的代码，第一个问题是当打出abc中的c时，有一个关于ab的待处理请求，这个请求需要取消掉。OK，这应该不太难解决，你只需创建一个额外的变量来引用挂起的请求。下一个问题是如果请求失败了，你需要执行混乱的重试逻辑。一些捕获了重试次数的字段也需要进行清理。如果在程序向服务器发送请求之前等待一段时间是非常好的。毕竟我们不想在有人打一段很长的文字时不停地向服务器发送垃圾数据。或许需要添加一个额外的计时器字段。还需要处理执行搜索时在屏幕上显示的内容和所有重试都失败时需要显示什么。编写所有这些情况并正确测试它是乏味的。下面是使用Rx来编写具有相同逻辑的代码：searchTextField.rx.text .throttle(0.3, scheduler: MainScheduler.instance) .distinctUntilChanged() .flatMapLatest { query in API.getSearchResults(query) .retry(3) .startWith([]) // clears results on new search term .catchErrorJustReturn([]) } .subscribe(onNext: { results in // bind to ui }) .disposed(by: disposeBag)这里不需要任何额外的标志和字段。Rx负责处理所有混乱的临时状态。Compositional disposal让我们假设你需要在一个表格中展示模糊的照片。首先需要从 URL 中获取到图片，然后解码和让图片变得模糊。当图片不在表格的可见范围时，如果整个过程可以取消是非常好的。因为模糊操作会消耗大量的带宽和处理器的时间。当照片一出现在表格上时，如果我们不立即进行操作是非常好的。因为用户会快速滚动，会发起和取消大量的请求。如果我们可以限制同时处理照片的数量也是非常好的，因为模糊是个非常昂贵的操作。下面是我们使用Rx来进行处理的例子：let imageSubscription = imageURLs .throttle(0.2, scheduler: MainScheduler.instance) .flatMapLatest { imageURL in API.fetchImage(imageURL) } .observeOn(operationScheduler) .map { imageData in return decodeAndBlurImage(imageData) } .observeOn(MainScheduler.instance) .subscribe(onNext: { blurredImage in imageView.image = blurredImage }) .disposed(by: reuseDisposeBag)这部分代码会完成上述的所有操作。并且当imageSubscription被处理时，它将取消所有相关的异步操作，确保没有多余的图像绑定到UI。Aggregating network request当你需要发起两个请求并在它们都完成后处理结果时应该怎么做？嗯，你需要zip操作符。let userRequest: Observable&amp;lt;User&amp;gt; = API.getUser(&quot;me&quot;)let friendsRequest: Observable&amp;lt;[Friend]&amp;gt; = API.getFriends(&quot;me&quot;)Observable.zip(userRequest, friendsRequest) { user, friends in return (user, friends)}.subscribe(onNext: { user, friends in // bind them to the user interface}).disposed(by: disposeBag)那么，如果这些API是在后台线程返回结果，并且绑定必须发生在主线程上呢？你需要observeOn。let userRequest: Observable&amp;lt;User&amp;gt; = API.getUser(&quot;me&quot;)let friendsRequest: Observable&amp;lt;[Friend]&amp;gt; = API.getFriends(&quot;me&quot;)Observable.zip(userRequest, friendsRequest) { user, friends in return (user, friends)}.observeOn(MainScheduler.instance).subscribe(onNext: { user, friends in // bind them to the user interface}).disposed(by: disposeBag)State允许改变的语言使得容易访问全局状态并改变它。全局状态的不可控改变很容易导致 组合性爆炸。为了对抗组合性爆炸，通常使用的方法是保持状态尽可能地简单，和使用单向数据流来为导出数据建模。这是Rx真正闪耀的地方。Rx是函数式和命令式两个世界中的甜蜜地带。它让你以一种可靠可组合的方式去使用不可变的定义和纯代码，来处理可变状态的快照。那么实际的例子呢？Easy integration如果你需要创建你自己的Observable，应该怎么做呢？很简单。这部分代码取自RxCocoa，这是需要用URLSession封装HTTP请求的实现。extension URLSession { public func response(request: URLRequest) -&amp;gt; Observable&amp;lt;(Data, HTTPURLResponse)&amp;gt; { return Observable.create { observer in let task = self.base.dataTask(with: request) { (data, response, error) in guard let response = response, let data = data else { observer.on(.error(error ?? RxCocoaURLError.unknown)) return } guard let httpResponse = response as? HTTPURLResponse else { observer.on(.error(RxCocoaURLError.nonHTTPResponse(response: response))) return } observer.on(.next(data, httpResponse)) observer.on(.completed) } task.resume() return Disposables.create(with: task.cancel) } }}Benefits总之，使用Rx会使你的代码： 可组合 &amp;lt;- 因为Rx是组合的昵称 可重用 &amp;lt;- 因为它是可组合的 声明式 &amp;lt;- 因为定义是不可变的，只有数据是可变的 可理解和间接性 &amp;lt;- 提高抽象级别，消除临时状态 稳定性 &amp;lt;- 因为Rx的代码全部都经过单元测试的 无状态 &amp;lt;- 因为你使用单向数据流来为应用建模 无泄漏 &amp;lt;- 因为资源管理很容易It’s not all or nothing尽可能地使用Rx来编写应用程序通常是个好主意。但是如果你不知道所有的运算符，或者是否存在一些运算符符合你的特定情况时，该怎么办？好的，所有的Rx运算符都是基于数学的，应该是非常直观的。好消息是大概有10-15操作符可以覆盖大部分典型的用法。这个列表包括了一些熟悉的操作符，如：map，filter，zip，observeOn等等。这里是Rx操作符列表对于每个操作符，这里有个文档，有助于解释它是如何工作的。如果你需要的操作符不在列表上？你可以自己定义操作符。但是如果因为某些原因难于创建对应的操作符，或者你需要使用某些遗留的状态代码？好吧，你或许感到非常混乱，但是你可以轻易地跳出Rx monads，处理完数据再返回。" }, { "title": "2016", "url": "/posts/2016/", "categories": "", "tags": "summary", "date": "2016-12-31 19:08:41 +0800", "snippet": "总结差不多是时候开始新的一年了。没有写过年终总结之类的东西，一直都懒得总结。但是看到前面的一篇说希望以后能多写点东西，那就写一下吧。今年是作为iOS开发者完整渡过的第一年。年初开始的时候是负责写APM类的SDK，其实一开始是有点抗拒的，因为涉及的大多是底层的东西，比较枯燥。后来写着写着发现其实也挺不错的，可以学到很多有趣的东西。再后来发现这其实是个KPI产物，挺无奈的。8月份的时候由于某个项目的开发人员离职两个，于是临时抽调过去开发起App来，开始接触到界面开发的东西，终于可以用Storyboard拖拉控件了。最开心的是用Swfit重写了公司的一个小项目，带薪编译时间多了起来:]。年初的时候有了女朋友。从车陂搬到了粤垦路这边，环境也好多了。吉他练了又丢，丢了又练，到现在也不会弹什么。英雄联盟从8月份开始就很少玩了。本来打算今天在家里吃火锅的，也没吃成，点个外卖吧。2017年了，希望多读一些书，认真写代码，自己做出一个App来，Swift和Objective-C两手都要抓，两手都要硬。最后要说的是月结了，VPN又有流量了。清单硬件：Kindle PaperWhite 3酷冷至尊 烈焰枪 XT版Dell U2515HHHKB Pro2Magic Trackpad 2Bose QC20书：道士下山推拿银河帝国：基地ABC谋杀案人类简史余生皆假期最好的告别禅与Objective-C编程艺术The Swift Programming Language软件：Mac:CharlesMWebReederPiniOS:墨客StreaksReederP.cat" }, { "title": "图片资源的管理方式", "url": "/posts/how-to-manage-image-resources/", "categories": "", "tags": "iOS, Swift", "date": "2016-12-08 15:28:00 +0800", "snippet": "在开发app的过程中少不了要加载app内的图片资源，最简单的写法就是let image = UIImage(named: &quot;image&quot;)!我们并不希望在加载app内图片过程中出错，所以都会进行强制解析。但是这样写多了会很乱，有可能会拼错，图片资源删除了也要一个个去修改，也不会在编译时就报错。有可能上线了才发现缺失图片资源。静态属性方式Yep中采取扩展的方法来处理。extension UIImage { static var xxx_image: UIImage { return UIImage(named: &quot;image&quot;)! }}这样就可以通过调用UIImage.xxx_image来直接加载图片资源。nix也提供了脚步来批量生成需要的图片资源加载方法。Enum方式Enum 方式同样也是通过扩展来进行处理，不过是添加了enum计算属性先创建一个枚举变量，包含了所有的图片资源名字，然后创建便利构造器来根据enum.rawValue来加载图片资源。extension UIImage { enum AssetIentifier: String { case imageA, imageB, imageC, imageD } convenience init!(assetIdentifier: AssetIdentifier) { self.init(named: assetIdentifier.rawValue) }}通过以下方式进行调用：let image = UIImage(assetIdentifier: .imageA)SwiftGen提供很好的生成工具。R.swift方式也可以通过第三库R.swift来调用。普通的调用方式：let settingsIcon = UIImage(named: &quot;settings-icon&quot;)let gradientBackground = UIImage(named: &quot;gradient.jpg&quot;)R.swift的调用方式：let settingsIcon = R.image.settingsIcon()let gradientBackground = R.image.gradientJpg()R.swift作用不限于此，还可以Storyboards,Segue等也采用同样的调用方式。由于R.swift是在build时期运行的工具，并不是一个动态库。所以无法采取Carthage的方式来接入。现在在项目中也开始尝试使用R.swift。更安全和更便捷的调用资源。如果仅仅是为了管理图片资源，可以自己仿照Yep的方式用脚本生成。也可以通过使用SwiftGen来生成。如果想同时也对其它资源进行管理，可以试一下R.swift。最不推荐的方法是东写一个UIImage(named: &quot;image&quot;)!，西写一个UIImage(named: &quot;image&quot;)!，这样不只是浪费时间，最重要的是如果对图片进行了修改或者删除，有可能造成崩溃。同时最好采用单元测试来检测所有的图片资源，确保万无一失。" }, { "title": "网速才是第一生产力", "url": "/posts/first/", "categories": "", "tags": "", "date": "2016-07-30 23:03:08 +0800", "snippet": "从 Farbox 转到 Github Pages 了，希望以后可以多写点东西。" } ]
